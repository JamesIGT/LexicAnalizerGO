Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    MOD
    NOT
    PRINT
    RANGE
    UINT

Grammar

Rule 0     S' -> start
Rule 1     start -> PACKAGE VARIABLE import_stmt program
Rule 2     import_stmt -> IMPORT LPAREN STRING RPAREN
Rule 3     import_stmt -> IMPORT STRING
Rule 4     program -> statement
Rule 5     program -> statement program
Rule 6     statement -> declaration
Rule 7     statement -> assignment
Rule 8     statement -> print_stmt
Rule 9     statement -> input_stmt
Rule 10    statement -> continue_stmt
Rule 11    statement -> struct_method
Rule 12    statement -> func_def
Rule 13    statement -> func_no_params
Rule 14    statement -> func_no_params_void
Rule 15    statement -> func_with_map
Rule 16    statement -> func_call
Rule 17    statement -> if_stmt
Rule 18    statement -> for_stmt
Rule 19    statement -> struct_def
Rule 20    statement -> switch_stmt
Rule 21    statement -> map_declaration
Rule 22    statement -> map_declaration_values
Rule 23    statement -> array_declaration
Rule 24    statement -> array_literal
Rule 25    statement -> slice_declaration
Rule 26    statement -> make_stmt
Rule 27    statement -> new_stmt
Rule 28    statement -> break_stmt
Rule 29    statement -> increment_stmt
Rule 30    statement -> return_stmt
Rule 31    declaration -> VAR VARIABLE type
Rule 32    declaration -> VAR VARIABLE type ASIG expression
Rule 33    declaration -> VAR VARIABLE type ASSIGN expression
Rule 34    declaration -> VAR id_list type ASSIGN expr_list
Rule 35    declaration -> VAR id_list type ASIG expr_list
Rule 36    declaration -> VAR id_list ASSIGN expr_list
Rule 37    declaration -> VAR id_list ASIG expr_list
Rule 38    id_list -> VARIABLE
Rule 39    id_list -> VARIABLE COMMA id_list
Rule 40    expr_list -> expression
Rule 41    expr_list -> expression COMMA expr_list
Rule 42    assignment -> VARIABLE ASSIGN expression
Rule 43    assignment -> VARIABLE ASIG expression
Rule 44    print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
Rule 45    print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN
Rule 46    print_stmt -> FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN
Rule 47    input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
Rule 48    func_def -> func_header func_body
Rule 49    func_header -> FUNC VARIABLE LPAREN param_list RPAREN type
Rule 50    func_body -> LBRACE program RBRACE
Rule 51    return_stmt -> RETURN expression
Rule 52    func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body
Rule 53    func_no_params -> func_header_no_params block
Rule 54    func_header_no_params -> FUNC VARIABLE LPAREN RPAREN type
Rule 55    func_no_params_void -> FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE
Rule 56    func_call -> VARIABLE LPAREN arg_list RPAREN
Rule 57    func_call -> VARIABLE LPAREN RPAREN
Rule 58    param_list -> param
Rule 59    param_list -> param COMMA param_list
Rule 60    param -> VARIABLE type
Rule 61    arg_list -> expression
Rule 62    arg_list -> expression COMMA arg_list
Rule 63    expression -> term
Rule 64    expression -> expression PLUS term
Rule 65    expression -> expression MINUS term
Rule 66    expression -> expression AND expression
Rule 67    expression -> expression OR expression
Rule 68    expression -> expression EQ expression
Rule 69    expression -> expression NE expression
Rule 70    expression -> expression LT expression
Rule 71    expression -> expression GT expression
Rule 72    expression -> expression LE expression
Rule 73    expression -> expression GE expression
Rule 74    term -> factor
Rule 75    term -> term TIMES factor
Rule 76    term -> term DIVIDE factor
Rule 77    term -> VARIABLE
Rule 78    factor -> NUMBER
Rule 79    factor -> FLOAT
Rule 80    factor -> STRING
Rule 81    factor -> VARIABLE
Rule 82    factor -> TRUE
Rule 83    factor -> FALSE
Rule 84    factor -> LPAREN expression RPAREN
Rule 85    factor -> make_expr
Rule 86    factor -> struct_instance
Rule 87    factor -> func_call
Rule 88    type -> INT_TYPE
Rule 89    type -> FLOAT64_TYPE
Rule 90    type -> STRING_TYPE
Rule 91    type -> BOOL_TYPE
Rule 92    if_stmt -> IF expression block
Rule 93    if_stmt -> IF expression block ELSE block
Rule 94    for_stmt -> FOR expression for_block
Rule 95    for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update for_block
Rule 96    for_block -> begin_loop block end_loop
Rule 97    begin_loop -> <empty>
Rule 98    end_loop -> <empty>
Rule 99    continue_stmt -> CONTINUE
Rule 100   for_update -> assignment
Rule 101   for_update -> increment_stmt
Rule 102   block -> LBRACE program RBRACE
Rule 103   struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
Rule 104   struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
Rule 105   struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
Rule 106   struct_fields -> struct_field
Rule 107   struct_fields -> struct_field struct_fields
Rule 108   struct_field -> VARIABLE type
Rule 109   struct_field -> type
Rule 110   struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE
Rule 111   struct_fields_values -> field_value
Rule 112   struct_fields_values -> field_value COMMA struct_fields_values
Rule 113   field_value -> VARIABLE COLON expression
Rule 114   switch_stmt -> SWITCH expression LBRACE case_list RBRACE
Rule 115   switch_stmt -> SWITCH LBRACE case_list RBRACE
Rule 116   case_list -> case_clause
Rule 117   case_list -> case_clause case_list
Rule 118   case_clause -> CASE expression COLON program
Rule 119   case_clause -> DEFAULT COLON program
Rule 120   map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type
Rule 121   map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type
Rule 122   map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE
Rule 123   map_params -> map_param
Rule 124   map_params -> map_param COMMA map_params
Rule 125   map_param -> STRING COLON factor
Rule 126   make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
Rule 127   make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
Rule 128   make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
Rule 129   make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN
Rule 130   map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
Rule 131   map_kv_pairs -> map_kv_pair
Rule 132   map_kv_pairs -> map_kv_pair COMMA map_kv_pairs
Rule 133   map_kv_pair -> STRING COLON expression
Rule 134   array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type
Rule 135   array_declaration -> VAR VARIABLE ASSIGN array_literal
Rule 136   array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
Rule 137   array_values -> expression
Rule 138   array_values -> expression COMMA array_values
Rule 139   slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type
Rule 140   slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
Rule 141   slice_values -> expression
Rule 142   slice_values -> expression COMMA slice_values
Rule 143   new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
Rule 144   break_stmt -> BREAK
Rule 145   increment_stmt -> VARIABLE INCREMENT
Rule 146   increment_stmt -> VARIABLE DECREMENT

Terminals, with rules where they appear

AMPER                : 47
AND                  : 66
ASIG                 : 32 35 37 43 121 122 126 127 130 140 143
ASSIGN               : 33 34 36 42 135
BOOL_TYPE            : 91
BREAK                : 144
CASE                 : 118
COLON                : 113 118 119 125 133
COMMA                : 39 41 44 46 59 62 112 124 132 138 142
CONTINUE             : 99
DECREMENT            : 146
DEFAULT              : 119
DIVIDE               : 76
DOT                  : 44 45 46 47
ELSE                 : 93
EQ                   : 68
FALSE                : 83
FLOAT                : 79
FLOAT64_TYPE         : 89
FMT                  : 44 45 46 47
FOR                  : 94 95
FUNC                 : 49 52 54 55 103 104
GE                   : 73
GT                   : 71
IF                   : 92 93
IMPORT               : 2 3
INCREMENT            : 145
INT_TYPE             : 88
LBRACE               : 50 55 102 103 104 105 110 114 115 122 130 136 140
LBRACKET             : 52 120 121 122 126 127 128 129 130 134 136 139 140
LE                   : 72
LPAREN               : 2 44 45 46 47 49 52 54 55 56 57 84 103 103 104 104 126 127 128 129 143
LT                   : 70
MAKE                 : 126 127 128 129
MAP                  : 52 120 121 122 126 128 130
MINUS                : 65
MOD                  : 
NE                   : 69
NEW                  : 143
NOT                  : 
NUMBER               : 78 134 136
OR                   : 67
PACKAGE              : 1
PLUS                 : 64
PRINT                : 
PRINTF               : 44
PRINTLN              : 45 46
RANGE                : 
RBRACE               : 50 55 102 103 104 105 110 114 115 122 130 136 140
RBRACKET             : 52 120 121 122 126 127 128 129 130 134 136 139 140
RETURN               : 51
RPAREN               : 2 44 45 46 47 49 52 54 55 56 57 84 103 103 104 104 126 127 128 129 143
SCANLN               : 47
SEMICOLON            : 95 95
STRING               : 2 3 44 46 80 125 133
STRING_TYPE          : 90
STRUCT               : 105
SWITCH               : 114 115
TIMES                : 75
TRUE                 : 82
TYPE                 : 105
UINT                 : 
VAR                  : 31 32 33 34 35 36 37 120 134 135 139
VARIABLE             : 1 31 32 33 38 39 42 43 46 47 49 52 54 55 56 57 60 77 81 103 103 103 104 104 104 105 108 110 113 120 121 122 126 127 130 134 135 139 140 143 143 145 146
error                : 

Nonterminals, with rules where they appear

arg_list             : 56 62
array_declaration    : 23
array_literal        : 24 135
array_values         : 136 138
assignment           : 7 95 100
begin_loop           : 96
block                : 53 92 93 93 96
break_stmt           : 28
case_clause          : 116 117
case_list            : 114 115 117
continue_stmt        : 10
declaration          : 6
end_loop             : 96
expr_list            : 34 35 36 37 41
expression           : 32 33 40 41 42 43 44 45 51 61 62 64 65 66 66 67 67 68 68 69 69 70 70 71 71 72 72 73 73 84 92 93 94 95 113 114 118 133 137 138 141 142
factor               : 74 75 76 125
field_value          : 111 112
for_block            : 94 95
for_stmt             : 18
for_update           : 95
func_body            : 48 52
func_call            : 16 87
func_def             : 12
func_header          : 48
func_header_no_params : 53
func_no_params       : 13
func_no_params_void  : 14
func_with_map        : 15
id_list              : 34 35 36 37 39
if_stmt              : 17
import_stmt          : 1
increment_stmt       : 29 101
input_stmt           : 9
make_expr            : 85
make_stmt            : 26
map_declaration      : 21
map_declaration_values : 22
map_kv_pair          : 131 132
map_kv_pairs         : 130 132
map_param            : 123 124
map_params           : 122 124
new_stmt             : 27
param                : 58 59
param_list           : 49 59 103
print_stmt           : 8
program              : 1 5 50 55 102 103 104 118 119
return_stmt          : 30
slice_declaration    : 25
slice_values         : 140 142
start                : 0
statement            : 4 5
struct_def           : 19
struct_field         : 106 107
struct_fields        : 105 107
struct_fields_values : 110 112
struct_instance      : 86
struct_method        : 11
switch_stmt          : 20
term                 : 63 64 65 75 76
type                 : 31 32 33 34 35 49 52 52 54 60 103 104 108 109 120 120 121 121 122 122 126 126 127 128 128 129 130 130 134 136 139 140

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . PACKAGE VARIABLE import_stmt program

    PACKAGE         shift and go to state 2

    start                          shift and go to state 1

state 1

    (0) S' -> start .



state 2

    (1) start -> PACKAGE . VARIABLE import_stmt program

    VARIABLE        shift and go to state 3


state 3

    (1) start -> PACKAGE VARIABLE . import_stmt program
    (2) import_stmt -> . IMPORT LPAREN STRING RPAREN
    (3) import_stmt -> . IMPORT STRING

    IMPORT          shift and go to state 5

    import_stmt                    shift and go to state 4

state 4

    (1) start -> PACKAGE VARIABLE import_stmt . program
    (4) program -> . statement
    (5) program -> . statement program
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . print_stmt
    (9) statement -> . input_stmt
    (10) statement -> . continue_stmt
    (11) statement -> . struct_method
    (12) statement -> . func_def
    (13) statement -> . func_no_params
    (14) statement -> . func_no_params_void
    (15) statement -> . func_with_map
    (16) statement -> . func_call
    (17) statement -> . if_stmt
    (18) statement -> . for_stmt
    (19) statement -> . struct_def
    (20) statement -> . switch_stmt
    (21) statement -> . map_declaration
    (22) statement -> . map_declaration_values
    (23) statement -> . array_declaration
    (24) statement -> . array_literal
    (25) statement -> . slice_declaration
    (26) statement -> . make_stmt
    (27) statement -> . new_stmt
    (28) statement -> . break_stmt
    (29) statement -> . increment_stmt
    (30) statement -> . return_stmt
    (31) declaration -> . VAR VARIABLE type
    (32) declaration -> . VAR VARIABLE type ASIG expression
    (33) declaration -> . VAR VARIABLE type ASSIGN expression
    (34) declaration -> . VAR id_list type ASSIGN expr_list
    (35) declaration -> . VAR id_list type ASIG expr_list
    (36) declaration -> . VAR id_list ASSIGN expr_list
    (37) declaration -> . VAR id_list ASIG expr_list
    (42) assignment -> . VARIABLE ASSIGN expression
    (43) assignment -> . VARIABLE ASIG expression
    (44) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (45) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (46) print_stmt -> . FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN
    (47) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (99) continue_stmt -> . CONTINUE
    (103) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (104) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (48) func_def -> . func_header func_body
    (53) func_no_params -> . func_header_no_params block
    (55) func_no_params_void -> . FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE
    (52) func_with_map -> . FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN
    (92) if_stmt -> . IF expression block
    (93) if_stmt -> . IF expression block ELSE block
    (94) for_stmt -> . FOR expression for_block
    (95) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update for_block
    (105) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (114) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (115) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (120) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (121) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (122) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE
    (130) map_declaration_values -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
    (134) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (135) array_declaration -> . VAR VARIABLE ASSIGN array_literal
    (136) array_literal -> . LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (139) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (140) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (126) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (127) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (143) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (144) break_stmt -> . BREAK
    (145) increment_stmt -> . VARIABLE INCREMENT
    (146) increment_stmt -> . VARIABLE DECREMENT
    (51) return_stmt -> . RETURN expression
    (49) func_header -> . FUNC VARIABLE LPAREN param_list RPAREN type
    (54) func_header_no_params -> . FUNC VARIABLE LPAREN RPAREN type

    VAR             shift and go to state 34
    VARIABLE        shift and go to state 6
    FMT             shift and go to state 35
    CONTINUE        shift and go to state 36
    FUNC            shift and go to state 37
    IF              shift and go to state 41
    FOR             shift and go to state 42
    TYPE            shift and go to state 43
    SWITCH          shift and go to state 44
    LBRACKET        shift and go to state 40
    BREAK           shift and go to state 45
    RETURN          shift and go to state 46

    program                        shift and go to state 7
    statement                      shift and go to state 8
    declaration                    shift and go to state 9
    assignment                     shift and go to state 10
    print_stmt                     shift and go to state 11
    input_stmt                     shift and go to state 12
    continue_stmt                  shift and go to state 13
    struct_method                  shift and go to state 14
    func_def                       shift and go to state 15
    func_no_params                 shift and go to state 16
    func_no_params_void            shift and go to state 17
    func_with_map                  shift and go to state 18
    func_call                      shift and go to state 19
    if_stmt                        shift and go to state 20
    for_stmt                       shift and go to state 21
    struct_def                     shift and go to state 22
    switch_stmt                    shift and go to state 23
    map_declaration                shift and go to state 24
    map_declaration_values         shift and go to state 25
    array_declaration              shift and go to state 26
    array_literal                  shift and go to state 27
    slice_declaration              shift and go to state 28
    make_stmt                      shift and go to state 29
    new_stmt                       shift and go to state 30
    break_stmt                     shift and go to state 31
    increment_stmt                 shift and go to state 32
    return_stmt                    shift and go to state 33
    func_header                    shift and go to state 38
    func_header_no_params          shift and go to state 39

state 5

    (2) import_stmt -> IMPORT . LPAREN STRING RPAREN
    (3) import_stmt -> IMPORT . STRING

    LPAREN          shift and go to state 47
    STRING          shift and go to state 48


state 6

    (42) assignment -> VARIABLE . ASSIGN expression
    (43) assignment -> VARIABLE . ASIG expression
    (56) func_call -> VARIABLE . LPAREN arg_list RPAREN
    (57) func_call -> VARIABLE . LPAREN RPAREN
    (121) map_declaration -> VARIABLE . ASIG MAP LBRACKET type RBRACKET type
    (122) map_declaration -> VARIABLE . ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE
    (130) map_declaration_values -> VARIABLE . ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
    (140) slice_declaration -> VARIABLE . ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (126) make_stmt -> VARIABLE . ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (127) make_stmt -> VARIABLE . ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (143) new_stmt -> VARIABLE . ASIG NEW LPAREN VARIABLE RPAREN
    (145) increment_stmt -> VARIABLE . INCREMENT
    (146) increment_stmt -> VARIABLE . DECREMENT

    ASSIGN          shift and go to state 49
    ASIG            shift and go to state 50
    LPAREN          shift and go to state 51
    INCREMENT       shift and go to state 52
    DECREMENT       shift and go to state 53


state 7

    (1) start -> PACKAGE VARIABLE import_stmt program .

    $end            reduce using rule 1 (start -> PACKAGE VARIABLE import_stmt program .)


state 8

    (4) program -> statement .
    (5) program -> statement . program
    (4) program -> . statement
    (5) program -> . statement program
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . print_stmt
    (9) statement -> . input_stmt
    (10) statement -> . continue_stmt
    (11) statement -> . struct_method
    (12) statement -> . func_def
    (13) statement -> . func_no_params
    (14) statement -> . func_no_params_void
    (15) statement -> . func_with_map
    (16) statement -> . func_call
    (17) statement -> . if_stmt
    (18) statement -> . for_stmt
    (19) statement -> . struct_def
    (20) statement -> . switch_stmt
    (21) statement -> . map_declaration
    (22) statement -> . map_declaration_values
    (23) statement -> . array_declaration
    (24) statement -> . array_literal
    (25) statement -> . slice_declaration
    (26) statement -> . make_stmt
    (27) statement -> . new_stmt
    (28) statement -> . break_stmt
    (29) statement -> . increment_stmt
    (30) statement -> . return_stmt
    (31) declaration -> . VAR VARIABLE type
    (32) declaration -> . VAR VARIABLE type ASIG expression
    (33) declaration -> . VAR VARIABLE type ASSIGN expression
    (34) declaration -> . VAR id_list type ASSIGN expr_list
    (35) declaration -> . VAR id_list type ASIG expr_list
    (36) declaration -> . VAR id_list ASSIGN expr_list
    (37) declaration -> . VAR id_list ASIG expr_list
    (42) assignment -> . VARIABLE ASSIGN expression
    (43) assignment -> . VARIABLE ASIG expression
    (44) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (45) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (46) print_stmt -> . FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN
    (47) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (99) continue_stmt -> . CONTINUE
    (103) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (104) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (48) func_def -> . func_header func_body
    (53) func_no_params -> . func_header_no_params block
    (55) func_no_params_void -> . FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE
    (52) func_with_map -> . FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN
    (92) if_stmt -> . IF expression block
    (93) if_stmt -> . IF expression block ELSE block
    (94) for_stmt -> . FOR expression for_block
    (95) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update for_block
    (105) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (114) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (115) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (120) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (121) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (122) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE
    (130) map_declaration_values -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
    (134) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (135) array_declaration -> . VAR VARIABLE ASSIGN array_literal
    (136) array_literal -> . LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (139) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (140) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (126) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (127) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (143) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (144) break_stmt -> . BREAK
    (145) increment_stmt -> . VARIABLE INCREMENT
    (146) increment_stmt -> . VARIABLE DECREMENT
    (51) return_stmt -> . RETURN expression
    (49) func_header -> . FUNC VARIABLE LPAREN param_list RPAREN type
    (54) func_header_no_params -> . FUNC VARIABLE LPAREN RPAREN type

    $end            reduce using rule 4 (program -> statement .)
    RBRACE          reduce using rule 4 (program -> statement .)
    CASE            reduce using rule 4 (program -> statement .)
    DEFAULT         reduce using rule 4 (program -> statement .)
    VAR             shift and go to state 34
    VARIABLE        shift and go to state 6
    FMT             shift and go to state 35
    CONTINUE        shift and go to state 36
    FUNC            shift and go to state 37
    IF              shift and go to state 41
    FOR             shift and go to state 42
    TYPE            shift and go to state 43
    SWITCH          shift and go to state 44
    LBRACKET        shift and go to state 40
    BREAK           shift and go to state 45
    RETURN          shift and go to state 46

    statement                      shift and go to state 8
    program                        shift and go to state 54
    declaration                    shift and go to state 9
    assignment                     shift and go to state 10
    print_stmt                     shift and go to state 11
    input_stmt                     shift and go to state 12
    continue_stmt                  shift and go to state 13
    struct_method                  shift and go to state 14
    func_def                       shift and go to state 15
    func_no_params                 shift and go to state 16
    func_no_params_void            shift and go to state 17
    func_with_map                  shift and go to state 18
    func_call                      shift and go to state 19
    if_stmt                        shift and go to state 20
    for_stmt                       shift and go to state 21
    struct_def                     shift and go to state 22
    switch_stmt                    shift and go to state 23
    map_declaration                shift and go to state 24
    map_declaration_values         shift and go to state 25
    array_declaration              shift and go to state 26
    array_literal                  shift and go to state 27
    slice_declaration              shift and go to state 28
    make_stmt                      shift and go to state 29
    new_stmt                       shift and go to state 30
    break_stmt                     shift and go to state 31
    increment_stmt                 shift and go to state 32
    return_stmt                    shift and go to state 33
    func_header                    shift and go to state 38
    func_header_no_params          shift and go to state 39

state 9

    (6) statement -> declaration .

    VAR             reduce using rule 6 (statement -> declaration .)
    VARIABLE        reduce using rule 6 (statement -> declaration .)
    FMT             reduce using rule 6 (statement -> declaration .)
    CONTINUE        reduce using rule 6 (statement -> declaration .)
    FUNC            reduce using rule 6 (statement -> declaration .)
    IF              reduce using rule 6 (statement -> declaration .)
    FOR             reduce using rule 6 (statement -> declaration .)
    TYPE            reduce using rule 6 (statement -> declaration .)
    SWITCH          reduce using rule 6 (statement -> declaration .)
    LBRACKET        reduce using rule 6 (statement -> declaration .)
    BREAK           reduce using rule 6 (statement -> declaration .)
    RETURN          reduce using rule 6 (statement -> declaration .)
    $end            reduce using rule 6 (statement -> declaration .)
    RBRACE          reduce using rule 6 (statement -> declaration .)
    CASE            reduce using rule 6 (statement -> declaration .)
    DEFAULT         reduce using rule 6 (statement -> declaration .)


state 10

    (7) statement -> assignment .

    VAR             reduce using rule 7 (statement -> assignment .)
    VARIABLE        reduce using rule 7 (statement -> assignment .)
    FMT             reduce using rule 7 (statement -> assignment .)
    CONTINUE        reduce using rule 7 (statement -> assignment .)
    FUNC            reduce using rule 7 (statement -> assignment .)
    IF              reduce using rule 7 (statement -> assignment .)
    FOR             reduce using rule 7 (statement -> assignment .)
    TYPE            reduce using rule 7 (statement -> assignment .)
    SWITCH          reduce using rule 7 (statement -> assignment .)
    LBRACKET        reduce using rule 7 (statement -> assignment .)
    BREAK           reduce using rule 7 (statement -> assignment .)
    RETURN          reduce using rule 7 (statement -> assignment .)
    $end            reduce using rule 7 (statement -> assignment .)
    RBRACE          reduce using rule 7 (statement -> assignment .)
    CASE            reduce using rule 7 (statement -> assignment .)
    DEFAULT         reduce using rule 7 (statement -> assignment .)


state 11

    (8) statement -> print_stmt .

    VAR             reduce using rule 8 (statement -> print_stmt .)
    VARIABLE        reduce using rule 8 (statement -> print_stmt .)
    FMT             reduce using rule 8 (statement -> print_stmt .)
    CONTINUE        reduce using rule 8 (statement -> print_stmt .)
    FUNC            reduce using rule 8 (statement -> print_stmt .)
    IF              reduce using rule 8 (statement -> print_stmt .)
    FOR             reduce using rule 8 (statement -> print_stmt .)
    TYPE            reduce using rule 8 (statement -> print_stmt .)
    SWITCH          reduce using rule 8 (statement -> print_stmt .)
    LBRACKET        reduce using rule 8 (statement -> print_stmt .)
    BREAK           reduce using rule 8 (statement -> print_stmt .)
    RETURN          reduce using rule 8 (statement -> print_stmt .)
    $end            reduce using rule 8 (statement -> print_stmt .)
    RBRACE          reduce using rule 8 (statement -> print_stmt .)
    CASE            reduce using rule 8 (statement -> print_stmt .)
    DEFAULT         reduce using rule 8 (statement -> print_stmt .)


state 12

    (9) statement -> input_stmt .

    VAR             reduce using rule 9 (statement -> input_stmt .)
    VARIABLE        reduce using rule 9 (statement -> input_stmt .)
    FMT             reduce using rule 9 (statement -> input_stmt .)
    CONTINUE        reduce using rule 9 (statement -> input_stmt .)
    FUNC            reduce using rule 9 (statement -> input_stmt .)
    IF              reduce using rule 9 (statement -> input_stmt .)
    FOR             reduce using rule 9 (statement -> input_stmt .)
    TYPE            reduce using rule 9 (statement -> input_stmt .)
    SWITCH          reduce using rule 9 (statement -> input_stmt .)
    LBRACKET        reduce using rule 9 (statement -> input_stmt .)
    BREAK           reduce using rule 9 (statement -> input_stmt .)
    RETURN          reduce using rule 9 (statement -> input_stmt .)
    $end            reduce using rule 9 (statement -> input_stmt .)
    RBRACE          reduce using rule 9 (statement -> input_stmt .)
    CASE            reduce using rule 9 (statement -> input_stmt .)
    DEFAULT         reduce using rule 9 (statement -> input_stmt .)


state 13

    (10) statement -> continue_stmt .

    VAR             reduce using rule 10 (statement -> continue_stmt .)
    VARIABLE        reduce using rule 10 (statement -> continue_stmt .)
    FMT             reduce using rule 10 (statement -> continue_stmt .)
    CONTINUE        reduce using rule 10 (statement -> continue_stmt .)
    FUNC            reduce using rule 10 (statement -> continue_stmt .)
    IF              reduce using rule 10 (statement -> continue_stmt .)
    FOR             reduce using rule 10 (statement -> continue_stmt .)
    TYPE            reduce using rule 10 (statement -> continue_stmt .)
    SWITCH          reduce using rule 10 (statement -> continue_stmt .)
    LBRACKET        reduce using rule 10 (statement -> continue_stmt .)
    BREAK           reduce using rule 10 (statement -> continue_stmt .)
    RETURN          reduce using rule 10 (statement -> continue_stmt .)
    $end            reduce using rule 10 (statement -> continue_stmt .)
    RBRACE          reduce using rule 10 (statement -> continue_stmt .)
    CASE            reduce using rule 10 (statement -> continue_stmt .)
    DEFAULT         reduce using rule 10 (statement -> continue_stmt .)


state 14

    (11) statement -> struct_method .

    VAR             reduce using rule 11 (statement -> struct_method .)
    VARIABLE        reduce using rule 11 (statement -> struct_method .)
    FMT             reduce using rule 11 (statement -> struct_method .)
    CONTINUE        reduce using rule 11 (statement -> struct_method .)
    FUNC            reduce using rule 11 (statement -> struct_method .)
    IF              reduce using rule 11 (statement -> struct_method .)
    FOR             reduce using rule 11 (statement -> struct_method .)
    TYPE            reduce using rule 11 (statement -> struct_method .)
    SWITCH          reduce using rule 11 (statement -> struct_method .)
    LBRACKET        reduce using rule 11 (statement -> struct_method .)
    BREAK           reduce using rule 11 (statement -> struct_method .)
    RETURN          reduce using rule 11 (statement -> struct_method .)
    $end            reduce using rule 11 (statement -> struct_method .)
    RBRACE          reduce using rule 11 (statement -> struct_method .)
    CASE            reduce using rule 11 (statement -> struct_method .)
    DEFAULT         reduce using rule 11 (statement -> struct_method .)


state 15

    (12) statement -> func_def .

    VAR             reduce using rule 12 (statement -> func_def .)
    VARIABLE        reduce using rule 12 (statement -> func_def .)
    FMT             reduce using rule 12 (statement -> func_def .)
    CONTINUE        reduce using rule 12 (statement -> func_def .)
    FUNC            reduce using rule 12 (statement -> func_def .)
    IF              reduce using rule 12 (statement -> func_def .)
    FOR             reduce using rule 12 (statement -> func_def .)
    TYPE            reduce using rule 12 (statement -> func_def .)
    SWITCH          reduce using rule 12 (statement -> func_def .)
    LBRACKET        reduce using rule 12 (statement -> func_def .)
    BREAK           reduce using rule 12 (statement -> func_def .)
    RETURN          reduce using rule 12 (statement -> func_def .)
    $end            reduce using rule 12 (statement -> func_def .)
    RBRACE          reduce using rule 12 (statement -> func_def .)
    CASE            reduce using rule 12 (statement -> func_def .)
    DEFAULT         reduce using rule 12 (statement -> func_def .)


state 16

    (13) statement -> func_no_params .

    VAR             reduce using rule 13 (statement -> func_no_params .)
    VARIABLE        reduce using rule 13 (statement -> func_no_params .)
    FMT             reduce using rule 13 (statement -> func_no_params .)
    CONTINUE        reduce using rule 13 (statement -> func_no_params .)
    FUNC            reduce using rule 13 (statement -> func_no_params .)
    IF              reduce using rule 13 (statement -> func_no_params .)
    FOR             reduce using rule 13 (statement -> func_no_params .)
    TYPE            reduce using rule 13 (statement -> func_no_params .)
    SWITCH          reduce using rule 13 (statement -> func_no_params .)
    LBRACKET        reduce using rule 13 (statement -> func_no_params .)
    BREAK           reduce using rule 13 (statement -> func_no_params .)
    RETURN          reduce using rule 13 (statement -> func_no_params .)
    $end            reduce using rule 13 (statement -> func_no_params .)
    RBRACE          reduce using rule 13 (statement -> func_no_params .)
    CASE            reduce using rule 13 (statement -> func_no_params .)
    DEFAULT         reduce using rule 13 (statement -> func_no_params .)


state 17

    (14) statement -> func_no_params_void .

    VAR             reduce using rule 14 (statement -> func_no_params_void .)
    VARIABLE        reduce using rule 14 (statement -> func_no_params_void .)
    FMT             reduce using rule 14 (statement -> func_no_params_void .)
    CONTINUE        reduce using rule 14 (statement -> func_no_params_void .)
    FUNC            reduce using rule 14 (statement -> func_no_params_void .)
    IF              reduce using rule 14 (statement -> func_no_params_void .)
    FOR             reduce using rule 14 (statement -> func_no_params_void .)
    TYPE            reduce using rule 14 (statement -> func_no_params_void .)
    SWITCH          reduce using rule 14 (statement -> func_no_params_void .)
    LBRACKET        reduce using rule 14 (statement -> func_no_params_void .)
    BREAK           reduce using rule 14 (statement -> func_no_params_void .)
    RETURN          reduce using rule 14 (statement -> func_no_params_void .)
    $end            reduce using rule 14 (statement -> func_no_params_void .)
    RBRACE          reduce using rule 14 (statement -> func_no_params_void .)
    CASE            reduce using rule 14 (statement -> func_no_params_void .)
    DEFAULT         reduce using rule 14 (statement -> func_no_params_void .)


state 18

    (15) statement -> func_with_map .

    VAR             reduce using rule 15 (statement -> func_with_map .)
    VARIABLE        reduce using rule 15 (statement -> func_with_map .)
    FMT             reduce using rule 15 (statement -> func_with_map .)
    CONTINUE        reduce using rule 15 (statement -> func_with_map .)
    FUNC            reduce using rule 15 (statement -> func_with_map .)
    IF              reduce using rule 15 (statement -> func_with_map .)
    FOR             reduce using rule 15 (statement -> func_with_map .)
    TYPE            reduce using rule 15 (statement -> func_with_map .)
    SWITCH          reduce using rule 15 (statement -> func_with_map .)
    LBRACKET        reduce using rule 15 (statement -> func_with_map .)
    BREAK           reduce using rule 15 (statement -> func_with_map .)
    RETURN          reduce using rule 15 (statement -> func_with_map .)
    $end            reduce using rule 15 (statement -> func_with_map .)
    RBRACE          reduce using rule 15 (statement -> func_with_map .)
    CASE            reduce using rule 15 (statement -> func_with_map .)
    DEFAULT         reduce using rule 15 (statement -> func_with_map .)


state 19

    (16) statement -> func_call .

    VAR             reduce using rule 16 (statement -> func_call .)
    VARIABLE        reduce using rule 16 (statement -> func_call .)
    FMT             reduce using rule 16 (statement -> func_call .)
    CONTINUE        reduce using rule 16 (statement -> func_call .)
    FUNC            reduce using rule 16 (statement -> func_call .)
    IF              reduce using rule 16 (statement -> func_call .)
    FOR             reduce using rule 16 (statement -> func_call .)
    TYPE            reduce using rule 16 (statement -> func_call .)
    SWITCH          reduce using rule 16 (statement -> func_call .)
    LBRACKET        reduce using rule 16 (statement -> func_call .)
    BREAK           reduce using rule 16 (statement -> func_call .)
    RETURN          reduce using rule 16 (statement -> func_call .)
    $end            reduce using rule 16 (statement -> func_call .)
    RBRACE          reduce using rule 16 (statement -> func_call .)
    CASE            reduce using rule 16 (statement -> func_call .)
    DEFAULT         reduce using rule 16 (statement -> func_call .)


state 20

    (17) statement -> if_stmt .

    VAR             reduce using rule 17 (statement -> if_stmt .)
    VARIABLE        reduce using rule 17 (statement -> if_stmt .)
    FMT             reduce using rule 17 (statement -> if_stmt .)
    CONTINUE        reduce using rule 17 (statement -> if_stmt .)
    FUNC            reduce using rule 17 (statement -> if_stmt .)
    IF              reduce using rule 17 (statement -> if_stmt .)
    FOR             reduce using rule 17 (statement -> if_stmt .)
    TYPE            reduce using rule 17 (statement -> if_stmt .)
    SWITCH          reduce using rule 17 (statement -> if_stmt .)
    LBRACKET        reduce using rule 17 (statement -> if_stmt .)
    BREAK           reduce using rule 17 (statement -> if_stmt .)
    RETURN          reduce using rule 17 (statement -> if_stmt .)
    $end            reduce using rule 17 (statement -> if_stmt .)
    RBRACE          reduce using rule 17 (statement -> if_stmt .)
    CASE            reduce using rule 17 (statement -> if_stmt .)
    DEFAULT         reduce using rule 17 (statement -> if_stmt .)


state 21

    (18) statement -> for_stmt .

    VAR             reduce using rule 18 (statement -> for_stmt .)
    VARIABLE        reduce using rule 18 (statement -> for_stmt .)
    FMT             reduce using rule 18 (statement -> for_stmt .)
    CONTINUE        reduce using rule 18 (statement -> for_stmt .)
    FUNC            reduce using rule 18 (statement -> for_stmt .)
    IF              reduce using rule 18 (statement -> for_stmt .)
    FOR             reduce using rule 18 (statement -> for_stmt .)
    TYPE            reduce using rule 18 (statement -> for_stmt .)
    SWITCH          reduce using rule 18 (statement -> for_stmt .)
    LBRACKET        reduce using rule 18 (statement -> for_stmt .)
    BREAK           reduce using rule 18 (statement -> for_stmt .)
    RETURN          reduce using rule 18 (statement -> for_stmt .)
    $end            reduce using rule 18 (statement -> for_stmt .)
    RBRACE          reduce using rule 18 (statement -> for_stmt .)
    CASE            reduce using rule 18 (statement -> for_stmt .)
    DEFAULT         reduce using rule 18 (statement -> for_stmt .)


state 22

    (19) statement -> struct_def .

    VAR             reduce using rule 19 (statement -> struct_def .)
    VARIABLE        reduce using rule 19 (statement -> struct_def .)
    FMT             reduce using rule 19 (statement -> struct_def .)
    CONTINUE        reduce using rule 19 (statement -> struct_def .)
    FUNC            reduce using rule 19 (statement -> struct_def .)
    IF              reduce using rule 19 (statement -> struct_def .)
    FOR             reduce using rule 19 (statement -> struct_def .)
    TYPE            reduce using rule 19 (statement -> struct_def .)
    SWITCH          reduce using rule 19 (statement -> struct_def .)
    LBRACKET        reduce using rule 19 (statement -> struct_def .)
    BREAK           reduce using rule 19 (statement -> struct_def .)
    RETURN          reduce using rule 19 (statement -> struct_def .)
    $end            reduce using rule 19 (statement -> struct_def .)
    RBRACE          reduce using rule 19 (statement -> struct_def .)
    CASE            reduce using rule 19 (statement -> struct_def .)
    DEFAULT         reduce using rule 19 (statement -> struct_def .)


state 23

    (20) statement -> switch_stmt .

    VAR             reduce using rule 20 (statement -> switch_stmt .)
    VARIABLE        reduce using rule 20 (statement -> switch_stmt .)
    FMT             reduce using rule 20 (statement -> switch_stmt .)
    CONTINUE        reduce using rule 20 (statement -> switch_stmt .)
    FUNC            reduce using rule 20 (statement -> switch_stmt .)
    IF              reduce using rule 20 (statement -> switch_stmt .)
    FOR             reduce using rule 20 (statement -> switch_stmt .)
    TYPE            reduce using rule 20 (statement -> switch_stmt .)
    SWITCH          reduce using rule 20 (statement -> switch_stmt .)
    LBRACKET        reduce using rule 20 (statement -> switch_stmt .)
    BREAK           reduce using rule 20 (statement -> switch_stmt .)
    RETURN          reduce using rule 20 (statement -> switch_stmt .)
    $end            reduce using rule 20 (statement -> switch_stmt .)
    RBRACE          reduce using rule 20 (statement -> switch_stmt .)
    CASE            reduce using rule 20 (statement -> switch_stmt .)
    DEFAULT         reduce using rule 20 (statement -> switch_stmt .)


state 24

    (21) statement -> map_declaration .

    VAR             reduce using rule 21 (statement -> map_declaration .)
    VARIABLE        reduce using rule 21 (statement -> map_declaration .)
    FMT             reduce using rule 21 (statement -> map_declaration .)
    CONTINUE        reduce using rule 21 (statement -> map_declaration .)
    FUNC            reduce using rule 21 (statement -> map_declaration .)
    IF              reduce using rule 21 (statement -> map_declaration .)
    FOR             reduce using rule 21 (statement -> map_declaration .)
    TYPE            reduce using rule 21 (statement -> map_declaration .)
    SWITCH          reduce using rule 21 (statement -> map_declaration .)
    LBRACKET        reduce using rule 21 (statement -> map_declaration .)
    BREAK           reduce using rule 21 (statement -> map_declaration .)
    RETURN          reduce using rule 21 (statement -> map_declaration .)
    $end            reduce using rule 21 (statement -> map_declaration .)
    RBRACE          reduce using rule 21 (statement -> map_declaration .)
    CASE            reduce using rule 21 (statement -> map_declaration .)
    DEFAULT         reduce using rule 21 (statement -> map_declaration .)


state 25

    (22) statement -> map_declaration_values .

    VAR             reduce using rule 22 (statement -> map_declaration_values .)
    VARIABLE        reduce using rule 22 (statement -> map_declaration_values .)
    FMT             reduce using rule 22 (statement -> map_declaration_values .)
    CONTINUE        reduce using rule 22 (statement -> map_declaration_values .)
    FUNC            reduce using rule 22 (statement -> map_declaration_values .)
    IF              reduce using rule 22 (statement -> map_declaration_values .)
    FOR             reduce using rule 22 (statement -> map_declaration_values .)
    TYPE            reduce using rule 22 (statement -> map_declaration_values .)
    SWITCH          reduce using rule 22 (statement -> map_declaration_values .)
    LBRACKET        reduce using rule 22 (statement -> map_declaration_values .)
    BREAK           reduce using rule 22 (statement -> map_declaration_values .)
    RETURN          reduce using rule 22 (statement -> map_declaration_values .)
    $end            reduce using rule 22 (statement -> map_declaration_values .)
    RBRACE          reduce using rule 22 (statement -> map_declaration_values .)
    CASE            reduce using rule 22 (statement -> map_declaration_values .)
    DEFAULT         reduce using rule 22 (statement -> map_declaration_values .)


state 26

    (23) statement -> array_declaration .

    VAR             reduce using rule 23 (statement -> array_declaration .)
    VARIABLE        reduce using rule 23 (statement -> array_declaration .)
    FMT             reduce using rule 23 (statement -> array_declaration .)
    CONTINUE        reduce using rule 23 (statement -> array_declaration .)
    FUNC            reduce using rule 23 (statement -> array_declaration .)
    IF              reduce using rule 23 (statement -> array_declaration .)
    FOR             reduce using rule 23 (statement -> array_declaration .)
    TYPE            reduce using rule 23 (statement -> array_declaration .)
    SWITCH          reduce using rule 23 (statement -> array_declaration .)
    LBRACKET        reduce using rule 23 (statement -> array_declaration .)
    BREAK           reduce using rule 23 (statement -> array_declaration .)
    RETURN          reduce using rule 23 (statement -> array_declaration .)
    $end            reduce using rule 23 (statement -> array_declaration .)
    RBRACE          reduce using rule 23 (statement -> array_declaration .)
    CASE            reduce using rule 23 (statement -> array_declaration .)
    DEFAULT         reduce using rule 23 (statement -> array_declaration .)


state 27

    (24) statement -> array_literal .

    VAR             reduce using rule 24 (statement -> array_literal .)
    VARIABLE        reduce using rule 24 (statement -> array_literal .)
    FMT             reduce using rule 24 (statement -> array_literal .)
    CONTINUE        reduce using rule 24 (statement -> array_literal .)
    FUNC            reduce using rule 24 (statement -> array_literal .)
    IF              reduce using rule 24 (statement -> array_literal .)
    FOR             reduce using rule 24 (statement -> array_literal .)
    TYPE            reduce using rule 24 (statement -> array_literal .)
    SWITCH          reduce using rule 24 (statement -> array_literal .)
    LBRACKET        reduce using rule 24 (statement -> array_literal .)
    BREAK           reduce using rule 24 (statement -> array_literal .)
    RETURN          reduce using rule 24 (statement -> array_literal .)
    $end            reduce using rule 24 (statement -> array_literal .)
    RBRACE          reduce using rule 24 (statement -> array_literal .)
    CASE            reduce using rule 24 (statement -> array_literal .)
    DEFAULT         reduce using rule 24 (statement -> array_literal .)


state 28

    (25) statement -> slice_declaration .

    VAR             reduce using rule 25 (statement -> slice_declaration .)
    VARIABLE        reduce using rule 25 (statement -> slice_declaration .)
    FMT             reduce using rule 25 (statement -> slice_declaration .)
    CONTINUE        reduce using rule 25 (statement -> slice_declaration .)
    FUNC            reduce using rule 25 (statement -> slice_declaration .)
    IF              reduce using rule 25 (statement -> slice_declaration .)
    FOR             reduce using rule 25 (statement -> slice_declaration .)
    TYPE            reduce using rule 25 (statement -> slice_declaration .)
    SWITCH          reduce using rule 25 (statement -> slice_declaration .)
    LBRACKET        reduce using rule 25 (statement -> slice_declaration .)
    BREAK           reduce using rule 25 (statement -> slice_declaration .)
    RETURN          reduce using rule 25 (statement -> slice_declaration .)
    $end            reduce using rule 25 (statement -> slice_declaration .)
    RBRACE          reduce using rule 25 (statement -> slice_declaration .)
    CASE            reduce using rule 25 (statement -> slice_declaration .)
    DEFAULT         reduce using rule 25 (statement -> slice_declaration .)


state 29

    (26) statement -> make_stmt .

    VAR             reduce using rule 26 (statement -> make_stmt .)
    VARIABLE        reduce using rule 26 (statement -> make_stmt .)
    FMT             reduce using rule 26 (statement -> make_stmt .)
    CONTINUE        reduce using rule 26 (statement -> make_stmt .)
    FUNC            reduce using rule 26 (statement -> make_stmt .)
    IF              reduce using rule 26 (statement -> make_stmt .)
    FOR             reduce using rule 26 (statement -> make_stmt .)
    TYPE            reduce using rule 26 (statement -> make_stmt .)
    SWITCH          reduce using rule 26 (statement -> make_stmt .)
    LBRACKET        reduce using rule 26 (statement -> make_stmt .)
    BREAK           reduce using rule 26 (statement -> make_stmt .)
    RETURN          reduce using rule 26 (statement -> make_stmt .)
    $end            reduce using rule 26 (statement -> make_stmt .)
    RBRACE          reduce using rule 26 (statement -> make_stmt .)
    CASE            reduce using rule 26 (statement -> make_stmt .)
    DEFAULT         reduce using rule 26 (statement -> make_stmt .)


state 30

    (27) statement -> new_stmt .

    VAR             reduce using rule 27 (statement -> new_stmt .)
    VARIABLE        reduce using rule 27 (statement -> new_stmt .)
    FMT             reduce using rule 27 (statement -> new_stmt .)
    CONTINUE        reduce using rule 27 (statement -> new_stmt .)
    FUNC            reduce using rule 27 (statement -> new_stmt .)
    IF              reduce using rule 27 (statement -> new_stmt .)
    FOR             reduce using rule 27 (statement -> new_stmt .)
    TYPE            reduce using rule 27 (statement -> new_stmt .)
    SWITCH          reduce using rule 27 (statement -> new_stmt .)
    LBRACKET        reduce using rule 27 (statement -> new_stmt .)
    BREAK           reduce using rule 27 (statement -> new_stmt .)
    RETURN          reduce using rule 27 (statement -> new_stmt .)
    $end            reduce using rule 27 (statement -> new_stmt .)
    RBRACE          reduce using rule 27 (statement -> new_stmt .)
    CASE            reduce using rule 27 (statement -> new_stmt .)
    DEFAULT         reduce using rule 27 (statement -> new_stmt .)


state 31

    (28) statement -> break_stmt .

    VAR             reduce using rule 28 (statement -> break_stmt .)
    VARIABLE        reduce using rule 28 (statement -> break_stmt .)
    FMT             reduce using rule 28 (statement -> break_stmt .)
    CONTINUE        reduce using rule 28 (statement -> break_stmt .)
    FUNC            reduce using rule 28 (statement -> break_stmt .)
    IF              reduce using rule 28 (statement -> break_stmt .)
    FOR             reduce using rule 28 (statement -> break_stmt .)
    TYPE            reduce using rule 28 (statement -> break_stmt .)
    SWITCH          reduce using rule 28 (statement -> break_stmt .)
    LBRACKET        reduce using rule 28 (statement -> break_stmt .)
    BREAK           reduce using rule 28 (statement -> break_stmt .)
    RETURN          reduce using rule 28 (statement -> break_stmt .)
    $end            reduce using rule 28 (statement -> break_stmt .)
    RBRACE          reduce using rule 28 (statement -> break_stmt .)
    CASE            reduce using rule 28 (statement -> break_stmt .)
    DEFAULT         reduce using rule 28 (statement -> break_stmt .)


state 32

    (29) statement -> increment_stmt .

    VAR             reduce using rule 29 (statement -> increment_stmt .)
    VARIABLE        reduce using rule 29 (statement -> increment_stmt .)
    FMT             reduce using rule 29 (statement -> increment_stmt .)
    CONTINUE        reduce using rule 29 (statement -> increment_stmt .)
    FUNC            reduce using rule 29 (statement -> increment_stmt .)
    IF              reduce using rule 29 (statement -> increment_stmt .)
    FOR             reduce using rule 29 (statement -> increment_stmt .)
    TYPE            reduce using rule 29 (statement -> increment_stmt .)
    SWITCH          reduce using rule 29 (statement -> increment_stmt .)
    LBRACKET        reduce using rule 29 (statement -> increment_stmt .)
    BREAK           reduce using rule 29 (statement -> increment_stmt .)
    RETURN          reduce using rule 29 (statement -> increment_stmt .)
    $end            reduce using rule 29 (statement -> increment_stmt .)
    RBRACE          reduce using rule 29 (statement -> increment_stmt .)
    CASE            reduce using rule 29 (statement -> increment_stmt .)
    DEFAULT         reduce using rule 29 (statement -> increment_stmt .)


state 33

    (30) statement -> return_stmt .

    VAR             reduce using rule 30 (statement -> return_stmt .)
    VARIABLE        reduce using rule 30 (statement -> return_stmt .)
    FMT             reduce using rule 30 (statement -> return_stmt .)
    CONTINUE        reduce using rule 30 (statement -> return_stmt .)
    FUNC            reduce using rule 30 (statement -> return_stmt .)
    IF              reduce using rule 30 (statement -> return_stmt .)
    FOR             reduce using rule 30 (statement -> return_stmt .)
    TYPE            reduce using rule 30 (statement -> return_stmt .)
    SWITCH          reduce using rule 30 (statement -> return_stmt .)
    LBRACKET        reduce using rule 30 (statement -> return_stmt .)
    BREAK           reduce using rule 30 (statement -> return_stmt .)
    RETURN          reduce using rule 30 (statement -> return_stmt .)
    $end            reduce using rule 30 (statement -> return_stmt .)
    RBRACE          reduce using rule 30 (statement -> return_stmt .)
    CASE            reduce using rule 30 (statement -> return_stmt .)
    DEFAULT         reduce using rule 30 (statement -> return_stmt .)


state 34

    (31) declaration -> VAR . VARIABLE type
    (32) declaration -> VAR . VARIABLE type ASIG expression
    (33) declaration -> VAR . VARIABLE type ASSIGN expression
    (34) declaration -> VAR . id_list type ASSIGN expr_list
    (35) declaration -> VAR . id_list type ASIG expr_list
    (36) declaration -> VAR . id_list ASSIGN expr_list
    (37) declaration -> VAR . id_list ASIG expr_list
    (120) map_declaration -> VAR . VARIABLE MAP LBRACKET type RBRACKET type
    (134) array_declaration -> VAR . VARIABLE LBRACKET NUMBER RBRACKET type
    (135) array_declaration -> VAR . VARIABLE ASSIGN array_literal
    (139) slice_declaration -> VAR . VARIABLE LBRACKET RBRACKET type
    (38) id_list -> . VARIABLE
    (39) id_list -> . VARIABLE COMMA id_list

    VARIABLE        shift and go to state 55

    id_list                        shift and go to state 56

state 35

    (44) print_stmt -> FMT . DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (45) print_stmt -> FMT . DOT PRINTLN LPAREN expression RPAREN
    (46) print_stmt -> FMT . DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN
    (47) input_stmt -> FMT . DOT SCANLN LPAREN AMPER VARIABLE RPAREN

    DOT             shift and go to state 57


state 36

    (99) continue_stmt -> CONTINUE .

    VAR             reduce using rule 99 (continue_stmt -> CONTINUE .)
    VARIABLE        reduce using rule 99 (continue_stmt -> CONTINUE .)
    FMT             reduce using rule 99 (continue_stmt -> CONTINUE .)
    CONTINUE        reduce using rule 99 (continue_stmt -> CONTINUE .)
    FUNC            reduce using rule 99 (continue_stmt -> CONTINUE .)
    IF              reduce using rule 99 (continue_stmt -> CONTINUE .)
    FOR             reduce using rule 99 (continue_stmt -> CONTINUE .)
    TYPE            reduce using rule 99 (continue_stmt -> CONTINUE .)
    SWITCH          reduce using rule 99 (continue_stmt -> CONTINUE .)
    LBRACKET        reduce using rule 99 (continue_stmt -> CONTINUE .)
    BREAK           reduce using rule 99 (continue_stmt -> CONTINUE .)
    RETURN          reduce using rule 99 (continue_stmt -> CONTINUE .)
    $end            reduce using rule 99 (continue_stmt -> CONTINUE .)
    RBRACE          reduce using rule 99 (continue_stmt -> CONTINUE .)
    CASE            reduce using rule 99 (continue_stmt -> CONTINUE .)
    DEFAULT         reduce using rule 99 (continue_stmt -> CONTINUE .)


state 37

    (103) struct_method -> FUNC . LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (104) struct_method -> FUNC . LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (55) func_no_params_void -> FUNC . VARIABLE LPAREN RPAREN LBRACE program RBRACE
    (52) func_with_map -> FUNC . VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body
    (49) func_header -> FUNC . VARIABLE LPAREN param_list RPAREN type
    (54) func_header_no_params -> FUNC . VARIABLE LPAREN RPAREN type

    LPAREN          shift and go to state 58
    VARIABLE        shift and go to state 59


state 38

    (48) func_def -> func_header . func_body
    (50) func_body -> . LBRACE program RBRACE

    LBRACE          shift and go to state 61

    func_body                      shift and go to state 60

state 39

    (53) func_no_params -> func_header_no_params . block
    (102) block -> . LBRACE program RBRACE

    LBRACE          shift and go to state 63

    block                          shift and go to state 62

state 40

    (136) array_literal -> LBRACKET . NUMBER RBRACKET type LBRACE array_values RBRACE

    NUMBER          shift and go to state 64


state 41

    (92) if_stmt -> IF . expression block
    (93) if_stmt -> IF . expression block ELSE block
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 65
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 42

    (94) for_stmt -> FOR . expression for_block
    (95) for_stmt -> FOR . assignment SEMICOLON expression SEMICOLON for_update for_block
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (42) assignment -> . VARIABLE ASSIGN expression
    (43) assignment -> . VARIABLE ASIG expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 81
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 79
    assignment                     shift and go to state 80
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 43

    (105) struct_def -> TYPE . VARIABLE STRUCT LBRACE struct_fields RBRACE

    VARIABLE        shift and go to state 82


state 44

    (114) switch_stmt -> SWITCH . expression LBRACE case_list RBRACE
    (115) switch_stmt -> SWITCH . LBRACE case_list RBRACE
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    LBRACE          shift and go to state 84
    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 83
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 45

    (144) break_stmt -> BREAK .

    VAR             reduce using rule 144 (break_stmt -> BREAK .)
    VARIABLE        reduce using rule 144 (break_stmt -> BREAK .)
    FMT             reduce using rule 144 (break_stmt -> BREAK .)
    CONTINUE        reduce using rule 144 (break_stmt -> BREAK .)
    FUNC            reduce using rule 144 (break_stmt -> BREAK .)
    IF              reduce using rule 144 (break_stmt -> BREAK .)
    FOR             reduce using rule 144 (break_stmt -> BREAK .)
    TYPE            reduce using rule 144 (break_stmt -> BREAK .)
    SWITCH          reduce using rule 144 (break_stmt -> BREAK .)
    LBRACKET        reduce using rule 144 (break_stmt -> BREAK .)
    BREAK           reduce using rule 144 (break_stmt -> BREAK .)
    RETURN          reduce using rule 144 (break_stmt -> BREAK .)
    $end            reduce using rule 144 (break_stmt -> BREAK .)
    RBRACE          reduce using rule 144 (break_stmt -> BREAK .)
    CASE            reduce using rule 144 (break_stmt -> BREAK .)
    DEFAULT         reduce using rule 144 (break_stmt -> BREAK .)


state 46

    (51) return_stmt -> RETURN . expression
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 85
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 47

    (2) import_stmt -> IMPORT LPAREN . STRING RPAREN

    STRING          shift and go to state 86


state 48

    (3) import_stmt -> IMPORT STRING .

    VAR             reduce using rule 3 (import_stmt -> IMPORT STRING .)
    VARIABLE        reduce using rule 3 (import_stmt -> IMPORT STRING .)
    FMT             reduce using rule 3 (import_stmt -> IMPORT STRING .)
    CONTINUE        reduce using rule 3 (import_stmt -> IMPORT STRING .)
    FUNC            reduce using rule 3 (import_stmt -> IMPORT STRING .)
    IF              reduce using rule 3 (import_stmt -> IMPORT STRING .)
    FOR             reduce using rule 3 (import_stmt -> IMPORT STRING .)
    TYPE            reduce using rule 3 (import_stmt -> IMPORT STRING .)
    SWITCH          reduce using rule 3 (import_stmt -> IMPORT STRING .)
    LBRACKET        reduce using rule 3 (import_stmt -> IMPORT STRING .)
    BREAK           reduce using rule 3 (import_stmt -> IMPORT STRING .)
    RETURN          reduce using rule 3 (import_stmt -> IMPORT STRING .)


state 49

    (42) assignment -> VARIABLE ASSIGN . expression
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 87
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 50

    (43) assignment -> VARIABLE ASIG . expression
    (121) map_declaration -> VARIABLE ASIG . MAP LBRACKET type RBRACKET type
    (122) map_declaration -> VARIABLE ASIG . MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE
    (130) map_declaration_values -> VARIABLE ASIG . MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
    (140) slice_declaration -> VARIABLE ASIG . LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (126) make_stmt -> VARIABLE ASIG . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (127) make_stmt -> VARIABLE ASIG . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (143) new_stmt -> VARIABLE ASIG . NEW LPAREN VARIABLE RPAREN
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    MAP             shift and go to state 89
    LBRACKET        shift and go to state 90
    MAKE            shift and go to state 91
    NEW             shift and go to state 92
    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74

    expression                     shift and go to state 88
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 51

    (56) func_call -> VARIABLE LPAREN . arg_list RPAREN
    (57) func_call -> VARIABLE LPAREN . RPAREN
    (61) arg_list -> . expression
    (62) arg_list -> . expression COMMA arg_list
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    RPAREN          shift and go to state 94
    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    arg_list                       shift and go to state 93
    expression                     shift and go to state 95
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 52

    (145) increment_stmt -> VARIABLE INCREMENT .

    VAR             reduce using rule 145 (increment_stmt -> VARIABLE INCREMENT .)
    VARIABLE        reduce using rule 145 (increment_stmt -> VARIABLE INCREMENT .)
    FMT             reduce using rule 145 (increment_stmt -> VARIABLE INCREMENT .)
    CONTINUE        reduce using rule 145 (increment_stmt -> VARIABLE INCREMENT .)
    FUNC            reduce using rule 145 (increment_stmt -> VARIABLE INCREMENT .)
    IF              reduce using rule 145 (increment_stmt -> VARIABLE INCREMENT .)
    FOR             reduce using rule 145 (increment_stmt -> VARIABLE INCREMENT .)
    TYPE            reduce using rule 145 (increment_stmt -> VARIABLE INCREMENT .)
    SWITCH          reduce using rule 145 (increment_stmt -> VARIABLE INCREMENT .)
    LBRACKET        reduce using rule 145 (increment_stmt -> VARIABLE INCREMENT .)
    BREAK           reduce using rule 145 (increment_stmt -> VARIABLE INCREMENT .)
    RETURN          reduce using rule 145 (increment_stmt -> VARIABLE INCREMENT .)
    $end            reduce using rule 145 (increment_stmt -> VARIABLE INCREMENT .)
    RBRACE          reduce using rule 145 (increment_stmt -> VARIABLE INCREMENT .)
    CASE            reduce using rule 145 (increment_stmt -> VARIABLE INCREMENT .)
    DEFAULT         reduce using rule 145 (increment_stmt -> VARIABLE INCREMENT .)
    LBRACE          reduce using rule 145 (increment_stmt -> VARIABLE INCREMENT .)


state 53

    (146) increment_stmt -> VARIABLE DECREMENT .

    VAR             reduce using rule 146 (increment_stmt -> VARIABLE DECREMENT .)
    VARIABLE        reduce using rule 146 (increment_stmt -> VARIABLE DECREMENT .)
    FMT             reduce using rule 146 (increment_stmt -> VARIABLE DECREMENT .)
    CONTINUE        reduce using rule 146 (increment_stmt -> VARIABLE DECREMENT .)
    FUNC            reduce using rule 146 (increment_stmt -> VARIABLE DECREMENT .)
    IF              reduce using rule 146 (increment_stmt -> VARIABLE DECREMENT .)
    FOR             reduce using rule 146 (increment_stmt -> VARIABLE DECREMENT .)
    TYPE            reduce using rule 146 (increment_stmt -> VARIABLE DECREMENT .)
    SWITCH          reduce using rule 146 (increment_stmt -> VARIABLE DECREMENT .)
    LBRACKET        reduce using rule 146 (increment_stmt -> VARIABLE DECREMENT .)
    BREAK           reduce using rule 146 (increment_stmt -> VARIABLE DECREMENT .)
    RETURN          reduce using rule 146 (increment_stmt -> VARIABLE DECREMENT .)
    $end            reduce using rule 146 (increment_stmt -> VARIABLE DECREMENT .)
    RBRACE          reduce using rule 146 (increment_stmt -> VARIABLE DECREMENT .)
    CASE            reduce using rule 146 (increment_stmt -> VARIABLE DECREMENT .)
    DEFAULT         reduce using rule 146 (increment_stmt -> VARIABLE DECREMENT .)
    LBRACE          reduce using rule 146 (increment_stmt -> VARIABLE DECREMENT .)


state 54

    (5) program -> statement program .

    $end            reduce using rule 5 (program -> statement program .)
    RBRACE          reduce using rule 5 (program -> statement program .)
    CASE            reduce using rule 5 (program -> statement program .)
    DEFAULT         reduce using rule 5 (program -> statement program .)


state 55

    (31) declaration -> VAR VARIABLE . type
    (32) declaration -> VAR VARIABLE . type ASIG expression
    (33) declaration -> VAR VARIABLE . type ASSIGN expression
    (120) map_declaration -> VAR VARIABLE . MAP LBRACKET type RBRACKET type
    (134) array_declaration -> VAR VARIABLE . LBRACKET NUMBER RBRACKET type
    (135) array_declaration -> VAR VARIABLE . ASSIGN array_literal
    (139) slice_declaration -> VAR VARIABLE . LBRACKET RBRACKET type
    (38) id_list -> VARIABLE .
    (39) id_list -> VARIABLE . COMMA id_list
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

  ! shift/reduce conflict for ASSIGN resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for FLOAT64_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
    MAP             shift and go to state 98
    LBRACKET        shift and go to state 99
    ASSIGN          shift and go to state 97
    ASIG            reduce using rule 38 (id_list -> VARIABLE .)
    COMMA           shift and go to state 100
    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

  ! ASSIGN          [ reduce using rule 38 (id_list -> VARIABLE .) ]
  ! INT_TYPE        [ reduce using rule 38 (id_list -> VARIABLE .) ]
  ! FLOAT64_TYPE    [ reduce using rule 38 (id_list -> VARIABLE .) ]
  ! STRING_TYPE     [ reduce using rule 38 (id_list -> VARIABLE .) ]
  ! BOOL_TYPE       [ reduce using rule 38 (id_list -> VARIABLE .) ]

    type                           shift and go to state 96

state 56

    (34) declaration -> VAR id_list . type ASSIGN expr_list
    (35) declaration -> VAR id_list . type ASIG expr_list
    (36) declaration -> VAR id_list . ASSIGN expr_list
    (37) declaration -> VAR id_list . ASIG expr_list
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    ASSIGN          shift and go to state 106
    ASIG            shift and go to state 107
    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 105

state 57

    (44) print_stmt -> FMT DOT . PRINTF LPAREN STRING COMMA expression RPAREN
    (45) print_stmt -> FMT DOT . PRINTLN LPAREN expression RPAREN
    (46) print_stmt -> FMT DOT . PRINTLN LPAREN STRING COMMA VARIABLE RPAREN
    (47) input_stmt -> FMT DOT . SCANLN LPAREN AMPER VARIABLE RPAREN

    PRINTF          shift and go to state 108
    PRINTLN         shift and go to state 109
    SCANLN          shift and go to state 110


state 58

    (103) struct_method -> FUNC LPAREN . VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (104) struct_method -> FUNC LPAREN . VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE

    VARIABLE        shift and go to state 111


state 59

    (55) func_no_params_void -> FUNC VARIABLE . LPAREN RPAREN LBRACE program RBRACE
    (52) func_with_map -> FUNC VARIABLE . LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body
    (49) func_header -> FUNC VARIABLE . LPAREN param_list RPAREN type
    (54) func_header_no_params -> FUNC VARIABLE . LPAREN RPAREN type

    LPAREN          shift and go to state 112


state 60

    (48) func_def -> func_header func_body .

    VAR             reduce using rule 48 (func_def -> func_header func_body .)
    VARIABLE        reduce using rule 48 (func_def -> func_header func_body .)
    FMT             reduce using rule 48 (func_def -> func_header func_body .)
    CONTINUE        reduce using rule 48 (func_def -> func_header func_body .)
    FUNC            reduce using rule 48 (func_def -> func_header func_body .)
    IF              reduce using rule 48 (func_def -> func_header func_body .)
    FOR             reduce using rule 48 (func_def -> func_header func_body .)
    TYPE            reduce using rule 48 (func_def -> func_header func_body .)
    SWITCH          reduce using rule 48 (func_def -> func_header func_body .)
    LBRACKET        reduce using rule 48 (func_def -> func_header func_body .)
    BREAK           reduce using rule 48 (func_def -> func_header func_body .)
    RETURN          reduce using rule 48 (func_def -> func_header func_body .)
    $end            reduce using rule 48 (func_def -> func_header func_body .)
    RBRACE          reduce using rule 48 (func_def -> func_header func_body .)
    CASE            reduce using rule 48 (func_def -> func_header func_body .)
    DEFAULT         reduce using rule 48 (func_def -> func_header func_body .)


state 61

    (50) func_body -> LBRACE . program RBRACE
    (4) program -> . statement
    (5) program -> . statement program
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . print_stmt
    (9) statement -> . input_stmt
    (10) statement -> . continue_stmt
    (11) statement -> . struct_method
    (12) statement -> . func_def
    (13) statement -> . func_no_params
    (14) statement -> . func_no_params_void
    (15) statement -> . func_with_map
    (16) statement -> . func_call
    (17) statement -> . if_stmt
    (18) statement -> . for_stmt
    (19) statement -> . struct_def
    (20) statement -> . switch_stmt
    (21) statement -> . map_declaration
    (22) statement -> . map_declaration_values
    (23) statement -> . array_declaration
    (24) statement -> . array_literal
    (25) statement -> . slice_declaration
    (26) statement -> . make_stmt
    (27) statement -> . new_stmt
    (28) statement -> . break_stmt
    (29) statement -> . increment_stmt
    (30) statement -> . return_stmt
    (31) declaration -> . VAR VARIABLE type
    (32) declaration -> . VAR VARIABLE type ASIG expression
    (33) declaration -> . VAR VARIABLE type ASSIGN expression
    (34) declaration -> . VAR id_list type ASSIGN expr_list
    (35) declaration -> . VAR id_list type ASIG expr_list
    (36) declaration -> . VAR id_list ASSIGN expr_list
    (37) declaration -> . VAR id_list ASIG expr_list
    (42) assignment -> . VARIABLE ASSIGN expression
    (43) assignment -> . VARIABLE ASIG expression
    (44) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (45) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (46) print_stmt -> . FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN
    (47) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (99) continue_stmt -> . CONTINUE
    (103) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (104) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (48) func_def -> . func_header func_body
    (53) func_no_params -> . func_header_no_params block
    (55) func_no_params_void -> . FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE
    (52) func_with_map -> . FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN
    (92) if_stmt -> . IF expression block
    (93) if_stmt -> . IF expression block ELSE block
    (94) for_stmt -> . FOR expression for_block
    (95) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update for_block
    (105) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (114) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (115) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (120) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (121) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (122) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE
    (130) map_declaration_values -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
    (134) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (135) array_declaration -> . VAR VARIABLE ASSIGN array_literal
    (136) array_literal -> . LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (139) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (140) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (126) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (127) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (143) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (144) break_stmt -> . BREAK
    (145) increment_stmt -> . VARIABLE INCREMENT
    (146) increment_stmt -> . VARIABLE DECREMENT
    (51) return_stmt -> . RETURN expression
    (49) func_header -> . FUNC VARIABLE LPAREN param_list RPAREN type
    (54) func_header_no_params -> . FUNC VARIABLE LPAREN RPAREN type

    VAR             shift and go to state 34
    VARIABLE        shift and go to state 6
    FMT             shift and go to state 35
    CONTINUE        shift and go to state 36
    FUNC            shift and go to state 37
    IF              shift and go to state 41
    FOR             shift and go to state 42
    TYPE            shift and go to state 43
    SWITCH          shift and go to state 44
    LBRACKET        shift and go to state 40
    BREAK           shift and go to state 45
    RETURN          shift and go to state 46

    program                        shift and go to state 113
    statement                      shift and go to state 8
    declaration                    shift and go to state 9
    assignment                     shift and go to state 10
    print_stmt                     shift and go to state 11
    input_stmt                     shift and go to state 12
    continue_stmt                  shift and go to state 13
    struct_method                  shift and go to state 14
    func_def                       shift and go to state 15
    func_no_params                 shift and go to state 16
    func_no_params_void            shift and go to state 17
    func_with_map                  shift and go to state 18
    func_call                      shift and go to state 19
    if_stmt                        shift and go to state 20
    for_stmt                       shift and go to state 21
    struct_def                     shift and go to state 22
    switch_stmt                    shift and go to state 23
    map_declaration                shift and go to state 24
    map_declaration_values         shift and go to state 25
    array_declaration              shift and go to state 26
    array_literal                  shift and go to state 27
    slice_declaration              shift and go to state 28
    make_stmt                      shift and go to state 29
    new_stmt                       shift and go to state 30
    break_stmt                     shift and go to state 31
    increment_stmt                 shift and go to state 32
    return_stmt                    shift and go to state 33
    func_header                    shift and go to state 38
    func_header_no_params          shift and go to state 39

state 62

    (53) func_no_params -> func_header_no_params block .

    VAR             reduce using rule 53 (func_no_params -> func_header_no_params block .)
    VARIABLE        reduce using rule 53 (func_no_params -> func_header_no_params block .)
    FMT             reduce using rule 53 (func_no_params -> func_header_no_params block .)
    CONTINUE        reduce using rule 53 (func_no_params -> func_header_no_params block .)
    FUNC            reduce using rule 53 (func_no_params -> func_header_no_params block .)
    IF              reduce using rule 53 (func_no_params -> func_header_no_params block .)
    FOR             reduce using rule 53 (func_no_params -> func_header_no_params block .)
    TYPE            reduce using rule 53 (func_no_params -> func_header_no_params block .)
    SWITCH          reduce using rule 53 (func_no_params -> func_header_no_params block .)
    LBRACKET        reduce using rule 53 (func_no_params -> func_header_no_params block .)
    BREAK           reduce using rule 53 (func_no_params -> func_header_no_params block .)
    RETURN          reduce using rule 53 (func_no_params -> func_header_no_params block .)
    $end            reduce using rule 53 (func_no_params -> func_header_no_params block .)
    RBRACE          reduce using rule 53 (func_no_params -> func_header_no_params block .)
    CASE            reduce using rule 53 (func_no_params -> func_header_no_params block .)
    DEFAULT         reduce using rule 53 (func_no_params -> func_header_no_params block .)


state 63

    (102) block -> LBRACE . program RBRACE
    (4) program -> . statement
    (5) program -> . statement program
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . print_stmt
    (9) statement -> . input_stmt
    (10) statement -> . continue_stmt
    (11) statement -> . struct_method
    (12) statement -> . func_def
    (13) statement -> . func_no_params
    (14) statement -> . func_no_params_void
    (15) statement -> . func_with_map
    (16) statement -> . func_call
    (17) statement -> . if_stmt
    (18) statement -> . for_stmt
    (19) statement -> . struct_def
    (20) statement -> . switch_stmt
    (21) statement -> . map_declaration
    (22) statement -> . map_declaration_values
    (23) statement -> . array_declaration
    (24) statement -> . array_literal
    (25) statement -> . slice_declaration
    (26) statement -> . make_stmt
    (27) statement -> . new_stmt
    (28) statement -> . break_stmt
    (29) statement -> . increment_stmt
    (30) statement -> . return_stmt
    (31) declaration -> . VAR VARIABLE type
    (32) declaration -> . VAR VARIABLE type ASIG expression
    (33) declaration -> . VAR VARIABLE type ASSIGN expression
    (34) declaration -> . VAR id_list type ASSIGN expr_list
    (35) declaration -> . VAR id_list type ASIG expr_list
    (36) declaration -> . VAR id_list ASSIGN expr_list
    (37) declaration -> . VAR id_list ASIG expr_list
    (42) assignment -> . VARIABLE ASSIGN expression
    (43) assignment -> . VARIABLE ASIG expression
    (44) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (45) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (46) print_stmt -> . FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN
    (47) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (99) continue_stmt -> . CONTINUE
    (103) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (104) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (48) func_def -> . func_header func_body
    (53) func_no_params -> . func_header_no_params block
    (55) func_no_params_void -> . FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE
    (52) func_with_map -> . FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN
    (92) if_stmt -> . IF expression block
    (93) if_stmt -> . IF expression block ELSE block
    (94) for_stmt -> . FOR expression for_block
    (95) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update for_block
    (105) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (114) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (115) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (120) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (121) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (122) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE
    (130) map_declaration_values -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
    (134) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (135) array_declaration -> . VAR VARIABLE ASSIGN array_literal
    (136) array_literal -> . LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (139) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (140) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (126) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (127) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (143) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (144) break_stmt -> . BREAK
    (145) increment_stmt -> . VARIABLE INCREMENT
    (146) increment_stmt -> . VARIABLE DECREMENT
    (51) return_stmt -> . RETURN expression
    (49) func_header -> . FUNC VARIABLE LPAREN param_list RPAREN type
    (54) func_header_no_params -> . FUNC VARIABLE LPAREN RPAREN type

    VAR             shift and go to state 34
    VARIABLE        shift and go to state 6
    FMT             shift and go to state 35
    CONTINUE        shift and go to state 36
    FUNC            shift and go to state 37
    IF              shift and go to state 41
    FOR             shift and go to state 42
    TYPE            shift and go to state 43
    SWITCH          shift and go to state 44
    LBRACKET        shift and go to state 40
    BREAK           shift and go to state 45
    RETURN          shift and go to state 46

    program                        shift and go to state 114
    statement                      shift and go to state 8
    declaration                    shift and go to state 9
    assignment                     shift and go to state 10
    print_stmt                     shift and go to state 11
    input_stmt                     shift and go to state 12
    continue_stmt                  shift and go to state 13
    struct_method                  shift and go to state 14
    func_def                       shift and go to state 15
    func_no_params                 shift and go to state 16
    func_no_params_void            shift and go to state 17
    func_with_map                  shift and go to state 18
    func_call                      shift and go to state 19
    if_stmt                        shift and go to state 20
    for_stmt                       shift and go to state 21
    struct_def                     shift and go to state 22
    switch_stmt                    shift and go to state 23
    map_declaration                shift and go to state 24
    map_declaration_values         shift and go to state 25
    array_declaration              shift and go to state 26
    array_literal                  shift and go to state 27
    slice_declaration              shift and go to state 28
    make_stmt                      shift and go to state 29
    new_stmt                       shift and go to state 30
    break_stmt                     shift and go to state 31
    increment_stmt                 shift and go to state 32
    return_stmt                    shift and go to state 33
    func_header                    shift and go to state 38
    func_header_no_params          shift and go to state 39

state 64

    (136) array_literal -> LBRACKET NUMBER . RBRACKET type LBRACE array_values RBRACE

    RBRACKET        shift and go to state 115


state 65

    (92) if_stmt -> IF expression . block
    (93) if_stmt -> IF expression . block ELSE block
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression
    (102) block -> . LBRACE program RBRACE

    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126
    LBRACE          shift and go to state 63

    block                          shift and go to state 116

state 66

    (63) expression -> term .
    (75) term -> term . TIMES factor
    (76) term -> term . DIVIDE factor

    PLUS            reduce using rule 63 (expression -> term .)
    MINUS           reduce using rule 63 (expression -> term .)
    AND             reduce using rule 63 (expression -> term .)
    OR              reduce using rule 63 (expression -> term .)
    EQ              reduce using rule 63 (expression -> term .)
    NE              reduce using rule 63 (expression -> term .)
    LT              reduce using rule 63 (expression -> term .)
    GT              reduce using rule 63 (expression -> term .)
    LE              reduce using rule 63 (expression -> term .)
    GE              reduce using rule 63 (expression -> term .)
    LBRACE          reduce using rule 63 (expression -> term .)
    VAR             reduce using rule 63 (expression -> term .)
    VARIABLE        reduce using rule 63 (expression -> term .)
    FMT             reduce using rule 63 (expression -> term .)
    CONTINUE        reduce using rule 63 (expression -> term .)
    FUNC            reduce using rule 63 (expression -> term .)
    IF              reduce using rule 63 (expression -> term .)
    FOR             reduce using rule 63 (expression -> term .)
    TYPE            reduce using rule 63 (expression -> term .)
    SWITCH          reduce using rule 63 (expression -> term .)
    LBRACKET        reduce using rule 63 (expression -> term .)
    BREAK           reduce using rule 63 (expression -> term .)
    RETURN          reduce using rule 63 (expression -> term .)
    $end            reduce using rule 63 (expression -> term .)
    RBRACE          reduce using rule 63 (expression -> term .)
    CASE            reduce using rule 63 (expression -> term .)
    DEFAULT         reduce using rule 63 (expression -> term .)
    SEMICOLON       reduce using rule 63 (expression -> term .)
    COMMA           reduce using rule 63 (expression -> term .)
    RPAREN          reduce using rule 63 (expression -> term .)
    COLON           reduce using rule 63 (expression -> term .)
    TIMES           shift and go to state 127
    DIVIDE          shift and go to state 128


state 67

    (74) term -> factor .

    TIMES           reduce using rule 74 (term -> factor .)
    DIVIDE          reduce using rule 74 (term -> factor .)
    PLUS            reduce using rule 74 (term -> factor .)
    MINUS           reduce using rule 74 (term -> factor .)
    AND             reduce using rule 74 (term -> factor .)
    OR              reduce using rule 74 (term -> factor .)
    EQ              reduce using rule 74 (term -> factor .)
    NE              reduce using rule 74 (term -> factor .)
    LT              reduce using rule 74 (term -> factor .)
    GT              reduce using rule 74 (term -> factor .)
    LE              reduce using rule 74 (term -> factor .)
    GE              reduce using rule 74 (term -> factor .)
    LBRACE          reduce using rule 74 (term -> factor .)
    VAR             reduce using rule 74 (term -> factor .)
    VARIABLE        reduce using rule 74 (term -> factor .)
    FMT             reduce using rule 74 (term -> factor .)
    CONTINUE        reduce using rule 74 (term -> factor .)
    FUNC            reduce using rule 74 (term -> factor .)
    IF              reduce using rule 74 (term -> factor .)
    FOR             reduce using rule 74 (term -> factor .)
    TYPE            reduce using rule 74 (term -> factor .)
    SWITCH          reduce using rule 74 (term -> factor .)
    LBRACKET        reduce using rule 74 (term -> factor .)
    BREAK           reduce using rule 74 (term -> factor .)
    RETURN          reduce using rule 74 (term -> factor .)
    $end            reduce using rule 74 (term -> factor .)
    RBRACE          reduce using rule 74 (term -> factor .)
    CASE            reduce using rule 74 (term -> factor .)
    DEFAULT         reduce using rule 74 (term -> factor .)
    SEMICOLON       reduce using rule 74 (term -> factor .)
    COMMA           reduce using rule 74 (term -> factor .)
    RPAREN          reduce using rule 74 (term -> factor .)
    COLON           reduce using rule 74 (term -> factor .)


state 68

    (77) term -> VARIABLE .
    (81) factor -> VARIABLE .
    (110) struct_instance -> VARIABLE . LBRACE struct_fields_values RBRACE
    (56) func_call -> VARIABLE . LPAREN arg_list RPAREN
    (57) func_call -> VARIABLE . LPAREN RPAREN

  ! reduce/reduce conflict for TIMES resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for PLUS resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for MINUS resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for AND resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for OR resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for EQ resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for NE resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for LT resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for GT resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for LE resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for GE resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for LBRACE resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for VAR resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for FMT resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for FUNC resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for IF resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for FOR resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for TYPE resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for SWITCH resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for BREAK resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for RETURN resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for $end resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for RBRACE resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for CASE resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for COMMA resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for RPAREN resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for COLON resolved using rule 77 (term -> VARIABLE .)
  ! shift/reduce conflict for LBRACE resolved as shift
    TIMES           reduce using rule 77 (term -> VARIABLE .)
    DIVIDE          reduce using rule 77 (term -> VARIABLE .)
    PLUS            reduce using rule 77 (term -> VARIABLE .)
    MINUS           reduce using rule 77 (term -> VARIABLE .)
    AND             reduce using rule 77 (term -> VARIABLE .)
    OR              reduce using rule 77 (term -> VARIABLE .)
    EQ              reduce using rule 77 (term -> VARIABLE .)
    NE              reduce using rule 77 (term -> VARIABLE .)
    LT              reduce using rule 77 (term -> VARIABLE .)
    GT              reduce using rule 77 (term -> VARIABLE .)
    LE              reduce using rule 77 (term -> VARIABLE .)
    GE              reduce using rule 77 (term -> VARIABLE .)
    VAR             reduce using rule 77 (term -> VARIABLE .)
    VARIABLE        reduce using rule 77 (term -> VARIABLE .)
    FMT             reduce using rule 77 (term -> VARIABLE .)
    CONTINUE        reduce using rule 77 (term -> VARIABLE .)
    FUNC            reduce using rule 77 (term -> VARIABLE .)
    IF              reduce using rule 77 (term -> VARIABLE .)
    FOR             reduce using rule 77 (term -> VARIABLE .)
    TYPE            reduce using rule 77 (term -> VARIABLE .)
    SWITCH          reduce using rule 77 (term -> VARIABLE .)
    LBRACKET        reduce using rule 77 (term -> VARIABLE .)
    BREAK           reduce using rule 77 (term -> VARIABLE .)
    RETURN          reduce using rule 77 (term -> VARIABLE .)
    $end            reduce using rule 77 (term -> VARIABLE .)
    RBRACE          reduce using rule 77 (term -> VARIABLE .)
    CASE            reduce using rule 77 (term -> VARIABLE .)
    DEFAULT         reduce using rule 77 (term -> VARIABLE .)
    SEMICOLON       reduce using rule 77 (term -> VARIABLE .)
    COMMA           reduce using rule 77 (term -> VARIABLE .)
    RPAREN          reduce using rule 77 (term -> VARIABLE .)
    COLON           reduce using rule 77 (term -> VARIABLE .)
    LBRACE          shift and go to state 129
    LPAREN          shift and go to state 51

  ! LBRACE          [ reduce using rule 77 (term -> VARIABLE .) ]
  ! TIMES           [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! DIVIDE          [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! PLUS            [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! MINUS           [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! AND             [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! OR              [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! EQ              [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! NE              [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! LT              [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! GT              [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! LE              [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! GE              [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! LBRACE          [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! VAR             [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! VARIABLE        [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! FMT             [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! CONTINUE        [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! FUNC            [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! IF              [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! FOR             [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! TYPE            [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! SWITCH          [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! LBRACKET        [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! BREAK           [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! RETURN          [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! $end            [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! RBRACE          [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! CASE            [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! DEFAULT         [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! SEMICOLON       [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! COMMA           [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! RPAREN          [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! COLON           [ reduce using rule 81 (factor -> VARIABLE .) ]


state 69

    (78) factor -> NUMBER .

    TIMES           reduce using rule 78 (factor -> NUMBER .)
    DIVIDE          reduce using rule 78 (factor -> NUMBER .)
    PLUS            reduce using rule 78 (factor -> NUMBER .)
    MINUS           reduce using rule 78 (factor -> NUMBER .)
    AND             reduce using rule 78 (factor -> NUMBER .)
    OR              reduce using rule 78 (factor -> NUMBER .)
    EQ              reduce using rule 78 (factor -> NUMBER .)
    NE              reduce using rule 78 (factor -> NUMBER .)
    LT              reduce using rule 78 (factor -> NUMBER .)
    GT              reduce using rule 78 (factor -> NUMBER .)
    LE              reduce using rule 78 (factor -> NUMBER .)
    GE              reduce using rule 78 (factor -> NUMBER .)
    LBRACE          reduce using rule 78 (factor -> NUMBER .)
    VAR             reduce using rule 78 (factor -> NUMBER .)
    VARIABLE        reduce using rule 78 (factor -> NUMBER .)
    FMT             reduce using rule 78 (factor -> NUMBER .)
    CONTINUE        reduce using rule 78 (factor -> NUMBER .)
    FUNC            reduce using rule 78 (factor -> NUMBER .)
    IF              reduce using rule 78 (factor -> NUMBER .)
    FOR             reduce using rule 78 (factor -> NUMBER .)
    TYPE            reduce using rule 78 (factor -> NUMBER .)
    SWITCH          reduce using rule 78 (factor -> NUMBER .)
    LBRACKET        reduce using rule 78 (factor -> NUMBER .)
    BREAK           reduce using rule 78 (factor -> NUMBER .)
    RETURN          reduce using rule 78 (factor -> NUMBER .)
    $end            reduce using rule 78 (factor -> NUMBER .)
    RBRACE          reduce using rule 78 (factor -> NUMBER .)
    CASE            reduce using rule 78 (factor -> NUMBER .)
    DEFAULT         reduce using rule 78 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 78 (factor -> NUMBER .)
    COMMA           reduce using rule 78 (factor -> NUMBER .)
    RPAREN          reduce using rule 78 (factor -> NUMBER .)
    COLON           reduce using rule 78 (factor -> NUMBER .)


state 70

    (79) factor -> FLOAT .

    TIMES           reduce using rule 79 (factor -> FLOAT .)
    DIVIDE          reduce using rule 79 (factor -> FLOAT .)
    PLUS            reduce using rule 79 (factor -> FLOAT .)
    MINUS           reduce using rule 79 (factor -> FLOAT .)
    AND             reduce using rule 79 (factor -> FLOAT .)
    OR              reduce using rule 79 (factor -> FLOAT .)
    EQ              reduce using rule 79 (factor -> FLOAT .)
    NE              reduce using rule 79 (factor -> FLOAT .)
    LT              reduce using rule 79 (factor -> FLOAT .)
    GT              reduce using rule 79 (factor -> FLOAT .)
    LE              reduce using rule 79 (factor -> FLOAT .)
    GE              reduce using rule 79 (factor -> FLOAT .)
    LBRACE          reduce using rule 79 (factor -> FLOAT .)
    VAR             reduce using rule 79 (factor -> FLOAT .)
    VARIABLE        reduce using rule 79 (factor -> FLOAT .)
    FMT             reduce using rule 79 (factor -> FLOAT .)
    CONTINUE        reduce using rule 79 (factor -> FLOAT .)
    FUNC            reduce using rule 79 (factor -> FLOAT .)
    IF              reduce using rule 79 (factor -> FLOAT .)
    FOR             reduce using rule 79 (factor -> FLOAT .)
    TYPE            reduce using rule 79 (factor -> FLOAT .)
    SWITCH          reduce using rule 79 (factor -> FLOAT .)
    LBRACKET        reduce using rule 79 (factor -> FLOAT .)
    BREAK           reduce using rule 79 (factor -> FLOAT .)
    RETURN          reduce using rule 79 (factor -> FLOAT .)
    $end            reduce using rule 79 (factor -> FLOAT .)
    RBRACE          reduce using rule 79 (factor -> FLOAT .)
    CASE            reduce using rule 79 (factor -> FLOAT .)
    DEFAULT         reduce using rule 79 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 79 (factor -> FLOAT .)
    COMMA           reduce using rule 79 (factor -> FLOAT .)
    RPAREN          reduce using rule 79 (factor -> FLOAT .)
    COLON           reduce using rule 79 (factor -> FLOAT .)


state 71

    (80) factor -> STRING .

    TIMES           reduce using rule 80 (factor -> STRING .)
    DIVIDE          reduce using rule 80 (factor -> STRING .)
    PLUS            reduce using rule 80 (factor -> STRING .)
    MINUS           reduce using rule 80 (factor -> STRING .)
    AND             reduce using rule 80 (factor -> STRING .)
    OR              reduce using rule 80 (factor -> STRING .)
    EQ              reduce using rule 80 (factor -> STRING .)
    NE              reduce using rule 80 (factor -> STRING .)
    LT              reduce using rule 80 (factor -> STRING .)
    GT              reduce using rule 80 (factor -> STRING .)
    LE              reduce using rule 80 (factor -> STRING .)
    GE              reduce using rule 80 (factor -> STRING .)
    LBRACE          reduce using rule 80 (factor -> STRING .)
    VAR             reduce using rule 80 (factor -> STRING .)
    VARIABLE        reduce using rule 80 (factor -> STRING .)
    FMT             reduce using rule 80 (factor -> STRING .)
    CONTINUE        reduce using rule 80 (factor -> STRING .)
    FUNC            reduce using rule 80 (factor -> STRING .)
    IF              reduce using rule 80 (factor -> STRING .)
    FOR             reduce using rule 80 (factor -> STRING .)
    TYPE            reduce using rule 80 (factor -> STRING .)
    SWITCH          reduce using rule 80 (factor -> STRING .)
    LBRACKET        reduce using rule 80 (factor -> STRING .)
    BREAK           reduce using rule 80 (factor -> STRING .)
    RETURN          reduce using rule 80 (factor -> STRING .)
    $end            reduce using rule 80 (factor -> STRING .)
    RBRACE          reduce using rule 80 (factor -> STRING .)
    CASE            reduce using rule 80 (factor -> STRING .)
    DEFAULT         reduce using rule 80 (factor -> STRING .)
    SEMICOLON       reduce using rule 80 (factor -> STRING .)
    COMMA           reduce using rule 80 (factor -> STRING .)
    RPAREN          reduce using rule 80 (factor -> STRING .)
    COLON           reduce using rule 80 (factor -> STRING .)


state 72

    (82) factor -> TRUE .

    TIMES           reduce using rule 82 (factor -> TRUE .)
    DIVIDE          reduce using rule 82 (factor -> TRUE .)
    PLUS            reduce using rule 82 (factor -> TRUE .)
    MINUS           reduce using rule 82 (factor -> TRUE .)
    AND             reduce using rule 82 (factor -> TRUE .)
    OR              reduce using rule 82 (factor -> TRUE .)
    EQ              reduce using rule 82 (factor -> TRUE .)
    NE              reduce using rule 82 (factor -> TRUE .)
    LT              reduce using rule 82 (factor -> TRUE .)
    GT              reduce using rule 82 (factor -> TRUE .)
    LE              reduce using rule 82 (factor -> TRUE .)
    GE              reduce using rule 82 (factor -> TRUE .)
    LBRACE          reduce using rule 82 (factor -> TRUE .)
    VAR             reduce using rule 82 (factor -> TRUE .)
    VARIABLE        reduce using rule 82 (factor -> TRUE .)
    FMT             reduce using rule 82 (factor -> TRUE .)
    CONTINUE        reduce using rule 82 (factor -> TRUE .)
    FUNC            reduce using rule 82 (factor -> TRUE .)
    IF              reduce using rule 82 (factor -> TRUE .)
    FOR             reduce using rule 82 (factor -> TRUE .)
    TYPE            reduce using rule 82 (factor -> TRUE .)
    SWITCH          reduce using rule 82 (factor -> TRUE .)
    LBRACKET        reduce using rule 82 (factor -> TRUE .)
    BREAK           reduce using rule 82 (factor -> TRUE .)
    RETURN          reduce using rule 82 (factor -> TRUE .)
    $end            reduce using rule 82 (factor -> TRUE .)
    RBRACE          reduce using rule 82 (factor -> TRUE .)
    CASE            reduce using rule 82 (factor -> TRUE .)
    DEFAULT         reduce using rule 82 (factor -> TRUE .)
    SEMICOLON       reduce using rule 82 (factor -> TRUE .)
    COMMA           reduce using rule 82 (factor -> TRUE .)
    RPAREN          reduce using rule 82 (factor -> TRUE .)
    COLON           reduce using rule 82 (factor -> TRUE .)


state 73

    (83) factor -> FALSE .

    TIMES           reduce using rule 83 (factor -> FALSE .)
    DIVIDE          reduce using rule 83 (factor -> FALSE .)
    PLUS            reduce using rule 83 (factor -> FALSE .)
    MINUS           reduce using rule 83 (factor -> FALSE .)
    AND             reduce using rule 83 (factor -> FALSE .)
    OR              reduce using rule 83 (factor -> FALSE .)
    EQ              reduce using rule 83 (factor -> FALSE .)
    NE              reduce using rule 83 (factor -> FALSE .)
    LT              reduce using rule 83 (factor -> FALSE .)
    GT              reduce using rule 83 (factor -> FALSE .)
    LE              reduce using rule 83 (factor -> FALSE .)
    GE              reduce using rule 83 (factor -> FALSE .)
    LBRACE          reduce using rule 83 (factor -> FALSE .)
    VAR             reduce using rule 83 (factor -> FALSE .)
    VARIABLE        reduce using rule 83 (factor -> FALSE .)
    FMT             reduce using rule 83 (factor -> FALSE .)
    CONTINUE        reduce using rule 83 (factor -> FALSE .)
    FUNC            reduce using rule 83 (factor -> FALSE .)
    IF              reduce using rule 83 (factor -> FALSE .)
    FOR             reduce using rule 83 (factor -> FALSE .)
    TYPE            reduce using rule 83 (factor -> FALSE .)
    SWITCH          reduce using rule 83 (factor -> FALSE .)
    LBRACKET        reduce using rule 83 (factor -> FALSE .)
    BREAK           reduce using rule 83 (factor -> FALSE .)
    RETURN          reduce using rule 83 (factor -> FALSE .)
    $end            reduce using rule 83 (factor -> FALSE .)
    RBRACE          reduce using rule 83 (factor -> FALSE .)
    CASE            reduce using rule 83 (factor -> FALSE .)
    DEFAULT         reduce using rule 83 (factor -> FALSE .)
    SEMICOLON       reduce using rule 83 (factor -> FALSE .)
    COMMA           reduce using rule 83 (factor -> FALSE .)
    RPAREN          reduce using rule 83 (factor -> FALSE .)
    COLON           reduce using rule 83 (factor -> FALSE .)


state 74

    (84) factor -> LPAREN . expression RPAREN
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 130
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 75

    (85) factor -> make_expr .

    TIMES           reduce using rule 85 (factor -> make_expr .)
    DIVIDE          reduce using rule 85 (factor -> make_expr .)
    PLUS            reduce using rule 85 (factor -> make_expr .)
    MINUS           reduce using rule 85 (factor -> make_expr .)
    AND             reduce using rule 85 (factor -> make_expr .)
    OR              reduce using rule 85 (factor -> make_expr .)
    EQ              reduce using rule 85 (factor -> make_expr .)
    NE              reduce using rule 85 (factor -> make_expr .)
    LT              reduce using rule 85 (factor -> make_expr .)
    GT              reduce using rule 85 (factor -> make_expr .)
    LE              reduce using rule 85 (factor -> make_expr .)
    GE              reduce using rule 85 (factor -> make_expr .)
    LBRACE          reduce using rule 85 (factor -> make_expr .)
    VAR             reduce using rule 85 (factor -> make_expr .)
    VARIABLE        reduce using rule 85 (factor -> make_expr .)
    FMT             reduce using rule 85 (factor -> make_expr .)
    CONTINUE        reduce using rule 85 (factor -> make_expr .)
    FUNC            reduce using rule 85 (factor -> make_expr .)
    IF              reduce using rule 85 (factor -> make_expr .)
    FOR             reduce using rule 85 (factor -> make_expr .)
    TYPE            reduce using rule 85 (factor -> make_expr .)
    SWITCH          reduce using rule 85 (factor -> make_expr .)
    LBRACKET        reduce using rule 85 (factor -> make_expr .)
    BREAK           reduce using rule 85 (factor -> make_expr .)
    RETURN          reduce using rule 85 (factor -> make_expr .)
    $end            reduce using rule 85 (factor -> make_expr .)
    RBRACE          reduce using rule 85 (factor -> make_expr .)
    CASE            reduce using rule 85 (factor -> make_expr .)
    DEFAULT         reduce using rule 85 (factor -> make_expr .)
    SEMICOLON       reduce using rule 85 (factor -> make_expr .)
    COMMA           reduce using rule 85 (factor -> make_expr .)
    RPAREN          reduce using rule 85 (factor -> make_expr .)
    COLON           reduce using rule 85 (factor -> make_expr .)


state 76

    (86) factor -> struct_instance .

    TIMES           reduce using rule 86 (factor -> struct_instance .)
    DIVIDE          reduce using rule 86 (factor -> struct_instance .)
    PLUS            reduce using rule 86 (factor -> struct_instance .)
    MINUS           reduce using rule 86 (factor -> struct_instance .)
    AND             reduce using rule 86 (factor -> struct_instance .)
    OR              reduce using rule 86 (factor -> struct_instance .)
    EQ              reduce using rule 86 (factor -> struct_instance .)
    NE              reduce using rule 86 (factor -> struct_instance .)
    LT              reduce using rule 86 (factor -> struct_instance .)
    GT              reduce using rule 86 (factor -> struct_instance .)
    LE              reduce using rule 86 (factor -> struct_instance .)
    GE              reduce using rule 86 (factor -> struct_instance .)
    LBRACE          reduce using rule 86 (factor -> struct_instance .)
    VAR             reduce using rule 86 (factor -> struct_instance .)
    VARIABLE        reduce using rule 86 (factor -> struct_instance .)
    FMT             reduce using rule 86 (factor -> struct_instance .)
    CONTINUE        reduce using rule 86 (factor -> struct_instance .)
    FUNC            reduce using rule 86 (factor -> struct_instance .)
    IF              reduce using rule 86 (factor -> struct_instance .)
    FOR             reduce using rule 86 (factor -> struct_instance .)
    TYPE            reduce using rule 86 (factor -> struct_instance .)
    SWITCH          reduce using rule 86 (factor -> struct_instance .)
    LBRACKET        reduce using rule 86 (factor -> struct_instance .)
    BREAK           reduce using rule 86 (factor -> struct_instance .)
    RETURN          reduce using rule 86 (factor -> struct_instance .)
    $end            reduce using rule 86 (factor -> struct_instance .)
    RBRACE          reduce using rule 86 (factor -> struct_instance .)
    CASE            reduce using rule 86 (factor -> struct_instance .)
    DEFAULT         reduce using rule 86 (factor -> struct_instance .)
    SEMICOLON       reduce using rule 86 (factor -> struct_instance .)
    COMMA           reduce using rule 86 (factor -> struct_instance .)
    RPAREN          reduce using rule 86 (factor -> struct_instance .)
    COLON           reduce using rule 86 (factor -> struct_instance .)


state 77

    (87) factor -> func_call .

    TIMES           reduce using rule 87 (factor -> func_call .)
    DIVIDE          reduce using rule 87 (factor -> func_call .)
    PLUS            reduce using rule 87 (factor -> func_call .)
    MINUS           reduce using rule 87 (factor -> func_call .)
    AND             reduce using rule 87 (factor -> func_call .)
    OR              reduce using rule 87 (factor -> func_call .)
    EQ              reduce using rule 87 (factor -> func_call .)
    NE              reduce using rule 87 (factor -> func_call .)
    LT              reduce using rule 87 (factor -> func_call .)
    GT              reduce using rule 87 (factor -> func_call .)
    LE              reduce using rule 87 (factor -> func_call .)
    GE              reduce using rule 87 (factor -> func_call .)
    LBRACE          reduce using rule 87 (factor -> func_call .)
    VAR             reduce using rule 87 (factor -> func_call .)
    VARIABLE        reduce using rule 87 (factor -> func_call .)
    FMT             reduce using rule 87 (factor -> func_call .)
    CONTINUE        reduce using rule 87 (factor -> func_call .)
    FUNC            reduce using rule 87 (factor -> func_call .)
    IF              reduce using rule 87 (factor -> func_call .)
    FOR             reduce using rule 87 (factor -> func_call .)
    TYPE            reduce using rule 87 (factor -> func_call .)
    SWITCH          reduce using rule 87 (factor -> func_call .)
    LBRACKET        reduce using rule 87 (factor -> func_call .)
    BREAK           reduce using rule 87 (factor -> func_call .)
    RETURN          reduce using rule 87 (factor -> func_call .)
    $end            reduce using rule 87 (factor -> func_call .)
    RBRACE          reduce using rule 87 (factor -> func_call .)
    CASE            reduce using rule 87 (factor -> func_call .)
    DEFAULT         reduce using rule 87 (factor -> func_call .)
    SEMICOLON       reduce using rule 87 (factor -> func_call .)
    COMMA           reduce using rule 87 (factor -> func_call .)
    RPAREN          reduce using rule 87 (factor -> func_call .)
    COLON           reduce using rule 87 (factor -> func_call .)


state 78

    (128) make_expr -> MAKE . LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> MAKE . LPAREN LBRACKET RBRACKET type RPAREN

    LPAREN          shift and go to state 131


state 79

    (94) for_stmt -> FOR expression . for_block
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression
    (96) for_block -> . begin_loop block end_loop
    (97) begin_loop -> .

    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126
    LBRACE          reduce using rule 97 (begin_loop -> .)

    for_block                      shift and go to state 132
    begin_loop                     shift and go to state 133

state 80

    (95) for_stmt -> FOR assignment . SEMICOLON expression SEMICOLON for_update for_block

    SEMICOLON       shift and go to state 134


state 81

    (42) assignment -> VARIABLE . ASSIGN expression
    (43) assignment -> VARIABLE . ASIG expression
    (77) term -> VARIABLE .
    (81) factor -> VARIABLE .
    (110) struct_instance -> VARIABLE . LBRACE struct_fields_values RBRACE
    (56) func_call -> VARIABLE . LPAREN arg_list RPAREN
    (57) func_call -> VARIABLE . LPAREN RPAREN

  ! reduce/reduce conflict for TIMES resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for PLUS resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for MINUS resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for AND resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for OR resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for EQ resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for NE resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for LT resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for GT resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for LE resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for GE resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for LBRACE resolved using rule 77 (term -> VARIABLE .)
  ! shift/reduce conflict for LBRACE resolved as shift
    ASSIGN          shift and go to state 49
    ASIG            shift and go to state 135
    TIMES           reduce using rule 77 (term -> VARIABLE .)
    DIVIDE          reduce using rule 77 (term -> VARIABLE .)
    PLUS            reduce using rule 77 (term -> VARIABLE .)
    MINUS           reduce using rule 77 (term -> VARIABLE .)
    AND             reduce using rule 77 (term -> VARIABLE .)
    OR              reduce using rule 77 (term -> VARIABLE .)
    EQ              reduce using rule 77 (term -> VARIABLE .)
    NE              reduce using rule 77 (term -> VARIABLE .)
    LT              reduce using rule 77 (term -> VARIABLE .)
    GT              reduce using rule 77 (term -> VARIABLE .)
    LE              reduce using rule 77 (term -> VARIABLE .)
    GE              reduce using rule 77 (term -> VARIABLE .)
    LBRACE          shift and go to state 129
    LPAREN          shift and go to state 51

  ! LBRACE          [ reduce using rule 77 (term -> VARIABLE .) ]
  ! TIMES           [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! DIVIDE          [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! PLUS            [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! MINUS           [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! AND             [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! OR              [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! EQ              [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! NE              [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! LT              [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! GT              [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! LE              [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! GE              [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! LBRACE          [ reduce using rule 81 (factor -> VARIABLE .) ]


state 82

    (105) struct_def -> TYPE VARIABLE . STRUCT LBRACE struct_fields RBRACE

    STRUCT          shift and go to state 136


state 83

    (114) switch_stmt -> SWITCH expression . LBRACE case_list RBRACE
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

    LBRACE          shift and go to state 137
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126


state 84

    (115) switch_stmt -> SWITCH LBRACE . case_list RBRACE
    (116) case_list -> . case_clause
    (117) case_list -> . case_clause case_list
    (118) case_clause -> . CASE expression COLON program
    (119) case_clause -> . DEFAULT COLON program

    CASE            shift and go to state 140
    DEFAULT         shift and go to state 141

    case_list                      shift and go to state 138
    case_clause                    shift and go to state 139

state 85

    (51) return_stmt -> RETURN expression .
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

    VAR             reduce using rule 51 (return_stmt -> RETURN expression .)
    VARIABLE        reduce using rule 51 (return_stmt -> RETURN expression .)
    FMT             reduce using rule 51 (return_stmt -> RETURN expression .)
    CONTINUE        reduce using rule 51 (return_stmt -> RETURN expression .)
    FUNC            reduce using rule 51 (return_stmt -> RETURN expression .)
    IF              reduce using rule 51 (return_stmt -> RETURN expression .)
    FOR             reduce using rule 51 (return_stmt -> RETURN expression .)
    TYPE            reduce using rule 51 (return_stmt -> RETURN expression .)
    SWITCH          reduce using rule 51 (return_stmt -> RETURN expression .)
    LBRACKET        reduce using rule 51 (return_stmt -> RETURN expression .)
    BREAK           reduce using rule 51 (return_stmt -> RETURN expression .)
    RETURN          reduce using rule 51 (return_stmt -> RETURN expression .)
    $end            reduce using rule 51 (return_stmt -> RETURN expression .)
    RBRACE          reduce using rule 51 (return_stmt -> RETURN expression .)
    CASE            reduce using rule 51 (return_stmt -> RETURN expression .)
    DEFAULT         reduce using rule 51 (return_stmt -> RETURN expression .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126


state 86

    (2) import_stmt -> IMPORT LPAREN STRING . RPAREN

    RPAREN          shift and go to state 142


state 87

    (42) assignment -> VARIABLE ASSIGN expression .
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

    VAR             reduce using rule 42 (assignment -> VARIABLE ASSIGN expression .)
    VARIABLE        reduce using rule 42 (assignment -> VARIABLE ASSIGN expression .)
    FMT             reduce using rule 42 (assignment -> VARIABLE ASSIGN expression .)
    CONTINUE        reduce using rule 42 (assignment -> VARIABLE ASSIGN expression .)
    FUNC            reduce using rule 42 (assignment -> VARIABLE ASSIGN expression .)
    IF              reduce using rule 42 (assignment -> VARIABLE ASSIGN expression .)
    FOR             reduce using rule 42 (assignment -> VARIABLE ASSIGN expression .)
    TYPE            reduce using rule 42 (assignment -> VARIABLE ASSIGN expression .)
    SWITCH          reduce using rule 42 (assignment -> VARIABLE ASSIGN expression .)
    LBRACKET        reduce using rule 42 (assignment -> VARIABLE ASSIGN expression .)
    BREAK           reduce using rule 42 (assignment -> VARIABLE ASSIGN expression .)
    RETURN          reduce using rule 42 (assignment -> VARIABLE ASSIGN expression .)
    $end            reduce using rule 42 (assignment -> VARIABLE ASSIGN expression .)
    RBRACE          reduce using rule 42 (assignment -> VARIABLE ASSIGN expression .)
    CASE            reduce using rule 42 (assignment -> VARIABLE ASSIGN expression .)
    DEFAULT         reduce using rule 42 (assignment -> VARIABLE ASSIGN expression .)
    SEMICOLON       reduce using rule 42 (assignment -> VARIABLE ASSIGN expression .)
    LBRACE          reduce using rule 42 (assignment -> VARIABLE ASSIGN expression .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126


state 88

    (43) assignment -> VARIABLE ASIG expression .
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

    VAR             reduce using rule 43 (assignment -> VARIABLE ASIG expression .)
    VARIABLE        reduce using rule 43 (assignment -> VARIABLE ASIG expression .)
    FMT             reduce using rule 43 (assignment -> VARIABLE ASIG expression .)
    CONTINUE        reduce using rule 43 (assignment -> VARIABLE ASIG expression .)
    FUNC            reduce using rule 43 (assignment -> VARIABLE ASIG expression .)
    IF              reduce using rule 43 (assignment -> VARIABLE ASIG expression .)
    FOR             reduce using rule 43 (assignment -> VARIABLE ASIG expression .)
    TYPE            reduce using rule 43 (assignment -> VARIABLE ASIG expression .)
    SWITCH          reduce using rule 43 (assignment -> VARIABLE ASIG expression .)
    LBRACKET        reduce using rule 43 (assignment -> VARIABLE ASIG expression .)
    BREAK           reduce using rule 43 (assignment -> VARIABLE ASIG expression .)
    RETURN          reduce using rule 43 (assignment -> VARIABLE ASIG expression .)
    $end            reduce using rule 43 (assignment -> VARIABLE ASIG expression .)
    RBRACE          reduce using rule 43 (assignment -> VARIABLE ASIG expression .)
    CASE            reduce using rule 43 (assignment -> VARIABLE ASIG expression .)
    DEFAULT         reduce using rule 43 (assignment -> VARIABLE ASIG expression .)
    SEMICOLON       reduce using rule 43 (assignment -> VARIABLE ASIG expression .)
    LBRACE          reduce using rule 43 (assignment -> VARIABLE ASIG expression .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126


state 89

    (121) map_declaration -> VARIABLE ASIG MAP . LBRACKET type RBRACKET type
    (122) map_declaration -> VARIABLE ASIG MAP . LBRACKET type RBRACKET type LBRACE map_params RBRACE
    (130) map_declaration_values -> VARIABLE ASIG MAP . LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE

    LBRACKET        shift and go to state 143


state 90

    (140) slice_declaration -> VARIABLE ASIG LBRACKET . RBRACKET type LBRACE slice_values RBRACE

    RBRACKET        shift and go to state 144


state 91

    (126) make_stmt -> VARIABLE ASIG MAKE . LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (127) make_stmt -> VARIABLE ASIG MAKE . LPAREN LBRACKET RBRACKET type RPAREN
    (128) make_expr -> MAKE . LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> MAKE . LPAREN LBRACKET RBRACKET type RPAREN

    LPAREN          shift and go to state 145


state 92

    (143) new_stmt -> VARIABLE ASIG NEW . LPAREN VARIABLE RPAREN

    LPAREN          shift and go to state 146


state 93

    (56) func_call -> VARIABLE LPAREN arg_list . RPAREN

    RPAREN          shift and go to state 147


state 94

    (57) func_call -> VARIABLE LPAREN RPAREN .

    VAR             reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    VARIABLE        reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    FMT             reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    CONTINUE        reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    FUNC            reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    IF              reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    FOR             reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    TYPE            reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    SWITCH          reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    LBRACKET        reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    BREAK           reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    RETURN          reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    $end            reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    RBRACE          reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    CASE            reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    DEFAULT         reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    TIMES           reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    DIVIDE          reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    PLUS            reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    MINUS           reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    AND             reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    OR              reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    EQ              reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    NE              reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    LT              reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    GT              reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    LE              reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    GE              reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    LBRACE          reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    SEMICOLON       reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    COMMA           reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    RPAREN          reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)
    COLON           reduce using rule 57 (func_call -> VARIABLE LPAREN RPAREN .)


state 95

    (61) arg_list -> expression .
    (62) arg_list -> expression . COMMA arg_list
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

    RPAREN          reduce using rule 61 (arg_list -> expression .)
    COMMA           shift and go to state 148
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126


state 96

    (31) declaration -> VAR VARIABLE type .
    (32) declaration -> VAR VARIABLE type . ASIG expression
    (33) declaration -> VAR VARIABLE type . ASSIGN expression

    VAR             reduce using rule 31 (declaration -> VAR VARIABLE type .)
    VARIABLE        reduce using rule 31 (declaration -> VAR VARIABLE type .)
    FMT             reduce using rule 31 (declaration -> VAR VARIABLE type .)
    CONTINUE        reduce using rule 31 (declaration -> VAR VARIABLE type .)
    FUNC            reduce using rule 31 (declaration -> VAR VARIABLE type .)
    IF              reduce using rule 31 (declaration -> VAR VARIABLE type .)
    FOR             reduce using rule 31 (declaration -> VAR VARIABLE type .)
    TYPE            reduce using rule 31 (declaration -> VAR VARIABLE type .)
    SWITCH          reduce using rule 31 (declaration -> VAR VARIABLE type .)
    LBRACKET        reduce using rule 31 (declaration -> VAR VARIABLE type .)
    BREAK           reduce using rule 31 (declaration -> VAR VARIABLE type .)
    RETURN          reduce using rule 31 (declaration -> VAR VARIABLE type .)
    $end            reduce using rule 31 (declaration -> VAR VARIABLE type .)
    RBRACE          reduce using rule 31 (declaration -> VAR VARIABLE type .)
    CASE            reduce using rule 31 (declaration -> VAR VARIABLE type .)
    DEFAULT         reduce using rule 31 (declaration -> VAR VARIABLE type .)
    ASIG            shift and go to state 149
    ASSIGN          shift and go to state 150


state 97

    (135) array_declaration -> VAR VARIABLE ASSIGN . array_literal
    (136) array_literal -> . LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE

    LBRACKET        shift and go to state 40

    array_literal                  shift and go to state 151

state 98

    (120) map_declaration -> VAR VARIABLE MAP . LBRACKET type RBRACKET type

    LBRACKET        shift and go to state 152


state 99

    (134) array_declaration -> VAR VARIABLE LBRACKET . NUMBER RBRACKET type
    (139) slice_declaration -> VAR VARIABLE LBRACKET . RBRACKET type

    NUMBER          shift and go to state 153
    RBRACKET        shift and go to state 154


state 100

    (39) id_list -> VARIABLE COMMA . id_list
    (38) id_list -> . VARIABLE
    (39) id_list -> . VARIABLE COMMA id_list

    VARIABLE        shift and go to state 155

    id_list                        shift and go to state 156

state 101

    (88) type -> INT_TYPE .

    ASIG            reduce using rule 88 (type -> INT_TYPE .)
    ASSIGN          reduce using rule 88 (type -> INT_TYPE .)
    VAR             reduce using rule 88 (type -> INT_TYPE .)
    VARIABLE        reduce using rule 88 (type -> INT_TYPE .)
    FMT             reduce using rule 88 (type -> INT_TYPE .)
    CONTINUE        reduce using rule 88 (type -> INT_TYPE .)
    FUNC            reduce using rule 88 (type -> INT_TYPE .)
    IF              reduce using rule 88 (type -> INT_TYPE .)
    FOR             reduce using rule 88 (type -> INT_TYPE .)
    TYPE            reduce using rule 88 (type -> INT_TYPE .)
    SWITCH          reduce using rule 88 (type -> INT_TYPE .)
    LBRACKET        reduce using rule 88 (type -> INT_TYPE .)
    BREAK           reduce using rule 88 (type -> INT_TYPE .)
    RETURN          reduce using rule 88 (type -> INT_TYPE .)
    $end            reduce using rule 88 (type -> INT_TYPE .)
    RBRACE          reduce using rule 88 (type -> INT_TYPE .)
    CASE            reduce using rule 88 (type -> INT_TYPE .)
    DEFAULT         reduce using rule 88 (type -> INT_TYPE .)
    LBRACE          reduce using rule 88 (type -> INT_TYPE .)
    RBRACKET        reduce using rule 88 (type -> INT_TYPE .)
    COMMA           reduce using rule 88 (type -> INT_TYPE .)
    RPAREN          reduce using rule 88 (type -> INT_TYPE .)
    INT_TYPE        reduce using rule 88 (type -> INT_TYPE .)
    FLOAT64_TYPE    reduce using rule 88 (type -> INT_TYPE .)
    STRING_TYPE     reduce using rule 88 (type -> INT_TYPE .)
    BOOL_TYPE       reduce using rule 88 (type -> INT_TYPE .)


state 102

    (89) type -> FLOAT64_TYPE .

    ASIG            reduce using rule 89 (type -> FLOAT64_TYPE .)
    ASSIGN          reduce using rule 89 (type -> FLOAT64_TYPE .)
    VAR             reduce using rule 89 (type -> FLOAT64_TYPE .)
    VARIABLE        reduce using rule 89 (type -> FLOAT64_TYPE .)
    FMT             reduce using rule 89 (type -> FLOAT64_TYPE .)
    CONTINUE        reduce using rule 89 (type -> FLOAT64_TYPE .)
    FUNC            reduce using rule 89 (type -> FLOAT64_TYPE .)
    IF              reduce using rule 89 (type -> FLOAT64_TYPE .)
    FOR             reduce using rule 89 (type -> FLOAT64_TYPE .)
    TYPE            reduce using rule 89 (type -> FLOAT64_TYPE .)
    SWITCH          reduce using rule 89 (type -> FLOAT64_TYPE .)
    LBRACKET        reduce using rule 89 (type -> FLOAT64_TYPE .)
    BREAK           reduce using rule 89 (type -> FLOAT64_TYPE .)
    RETURN          reduce using rule 89 (type -> FLOAT64_TYPE .)
    $end            reduce using rule 89 (type -> FLOAT64_TYPE .)
    RBRACE          reduce using rule 89 (type -> FLOAT64_TYPE .)
    CASE            reduce using rule 89 (type -> FLOAT64_TYPE .)
    DEFAULT         reduce using rule 89 (type -> FLOAT64_TYPE .)
    LBRACE          reduce using rule 89 (type -> FLOAT64_TYPE .)
    RBRACKET        reduce using rule 89 (type -> FLOAT64_TYPE .)
    COMMA           reduce using rule 89 (type -> FLOAT64_TYPE .)
    RPAREN          reduce using rule 89 (type -> FLOAT64_TYPE .)
    INT_TYPE        reduce using rule 89 (type -> FLOAT64_TYPE .)
    FLOAT64_TYPE    reduce using rule 89 (type -> FLOAT64_TYPE .)
    STRING_TYPE     reduce using rule 89 (type -> FLOAT64_TYPE .)
    BOOL_TYPE       reduce using rule 89 (type -> FLOAT64_TYPE .)


state 103

    (90) type -> STRING_TYPE .

    ASIG            reduce using rule 90 (type -> STRING_TYPE .)
    ASSIGN          reduce using rule 90 (type -> STRING_TYPE .)
    VAR             reduce using rule 90 (type -> STRING_TYPE .)
    VARIABLE        reduce using rule 90 (type -> STRING_TYPE .)
    FMT             reduce using rule 90 (type -> STRING_TYPE .)
    CONTINUE        reduce using rule 90 (type -> STRING_TYPE .)
    FUNC            reduce using rule 90 (type -> STRING_TYPE .)
    IF              reduce using rule 90 (type -> STRING_TYPE .)
    FOR             reduce using rule 90 (type -> STRING_TYPE .)
    TYPE            reduce using rule 90 (type -> STRING_TYPE .)
    SWITCH          reduce using rule 90 (type -> STRING_TYPE .)
    LBRACKET        reduce using rule 90 (type -> STRING_TYPE .)
    BREAK           reduce using rule 90 (type -> STRING_TYPE .)
    RETURN          reduce using rule 90 (type -> STRING_TYPE .)
    $end            reduce using rule 90 (type -> STRING_TYPE .)
    RBRACE          reduce using rule 90 (type -> STRING_TYPE .)
    CASE            reduce using rule 90 (type -> STRING_TYPE .)
    DEFAULT         reduce using rule 90 (type -> STRING_TYPE .)
    LBRACE          reduce using rule 90 (type -> STRING_TYPE .)
    RBRACKET        reduce using rule 90 (type -> STRING_TYPE .)
    COMMA           reduce using rule 90 (type -> STRING_TYPE .)
    RPAREN          reduce using rule 90 (type -> STRING_TYPE .)
    INT_TYPE        reduce using rule 90 (type -> STRING_TYPE .)
    FLOAT64_TYPE    reduce using rule 90 (type -> STRING_TYPE .)
    STRING_TYPE     reduce using rule 90 (type -> STRING_TYPE .)
    BOOL_TYPE       reduce using rule 90 (type -> STRING_TYPE .)


state 104

    (91) type -> BOOL_TYPE .

    ASIG            reduce using rule 91 (type -> BOOL_TYPE .)
    ASSIGN          reduce using rule 91 (type -> BOOL_TYPE .)
    VAR             reduce using rule 91 (type -> BOOL_TYPE .)
    VARIABLE        reduce using rule 91 (type -> BOOL_TYPE .)
    FMT             reduce using rule 91 (type -> BOOL_TYPE .)
    CONTINUE        reduce using rule 91 (type -> BOOL_TYPE .)
    FUNC            reduce using rule 91 (type -> BOOL_TYPE .)
    IF              reduce using rule 91 (type -> BOOL_TYPE .)
    FOR             reduce using rule 91 (type -> BOOL_TYPE .)
    TYPE            reduce using rule 91 (type -> BOOL_TYPE .)
    SWITCH          reduce using rule 91 (type -> BOOL_TYPE .)
    LBRACKET        reduce using rule 91 (type -> BOOL_TYPE .)
    BREAK           reduce using rule 91 (type -> BOOL_TYPE .)
    RETURN          reduce using rule 91 (type -> BOOL_TYPE .)
    $end            reduce using rule 91 (type -> BOOL_TYPE .)
    RBRACE          reduce using rule 91 (type -> BOOL_TYPE .)
    CASE            reduce using rule 91 (type -> BOOL_TYPE .)
    DEFAULT         reduce using rule 91 (type -> BOOL_TYPE .)
    LBRACE          reduce using rule 91 (type -> BOOL_TYPE .)
    RBRACKET        reduce using rule 91 (type -> BOOL_TYPE .)
    COMMA           reduce using rule 91 (type -> BOOL_TYPE .)
    RPAREN          reduce using rule 91 (type -> BOOL_TYPE .)
    INT_TYPE        reduce using rule 91 (type -> BOOL_TYPE .)
    FLOAT64_TYPE    reduce using rule 91 (type -> BOOL_TYPE .)
    STRING_TYPE     reduce using rule 91 (type -> BOOL_TYPE .)
    BOOL_TYPE       reduce using rule 91 (type -> BOOL_TYPE .)


state 105

    (34) declaration -> VAR id_list type . ASSIGN expr_list
    (35) declaration -> VAR id_list type . ASIG expr_list

    ASSIGN          shift and go to state 157
    ASIG            shift and go to state 158


state 106

    (36) declaration -> VAR id_list ASSIGN . expr_list
    (40) expr_list -> . expression
    (41) expr_list -> . expression COMMA expr_list
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expr_list                      shift and go to state 159
    expression                     shift and go to state 160
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 107

    (37) declaration -> VAR id_list ASIG . expr_list
    (40) expr_list -> . expression
    (41) expr_list -> . expression COMMA expr_list
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expr_list                      shift and go to state 161
    expression                     shift and go to state 160
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 108

    (44) print_stmt -> FMT DOT PRINTF . LPAREN STRING COMMA expression RPAREN

    LPAREN          shift and go to state 162


state 109

    (45) print_stmt -> FMT DOT PRINTLN . LPAREN expression RPAREN
    (46) print_stmt -> FMT DOT PRINTLN . LPAREN STRING COMMA VARIABLE RPAREN

    LPAREN          shift and go to state 163


state 110

    (47) input_stmt -> FMT DOT SCANLN . LPAREN AMPER VARIABLE RPAREN

    LPAREN          shift and go to state 164


state 111

    (103) struct_method -> FUNC LPAREN VARIABLE . VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (104) struct_method -> FUNC LPAREN VARIABLE . VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE

    VARIABLE        shift and go to state 165


state 112

    (55) func_no_params_void -> FUNC VARIABLE LPAREN . RPAREN LBRACE program RBRACE
    (52) func_with_map -> FUNC VARIABLE LPAREN . RPAREN MAP LBRACKET type RBRACKET type func_body
    (49) func_header -> FUNC VARIABLE LPAREN . param_list RPAREN type
    (54) func_header_no_params -> FUNC VARIABLE LPAREN . RPAREN type
    (58) param_list -> . param
    (59) param_list -> . param COMMA param_list
    (60) param -> . VARIABLE type

    RPAREN          shift and go to state 167
    VARIABLE        shift and go to state 166

    param_list                     shift and go to state 168
    param                          shift and go to state 169

state 113

    (50) func_body -> LBRACE program . RBRACE

    RBRACE          shift and go to state 170


state 114

    (102) block -> LBRACE program . RBRACE

    RBRACE          shift and go to state 171


state 115

    (136) array_literal -> LBRACKET NUMBER RBRACKET . type LBRACE array_values RBRACE
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 172

state 116

    (92) if_stmt -> IF expression block .
    (93) if_stmt -> IF expression block . ELSE block

    VAR             reduce using rule 92 (if_stmt -> IF expression block .)
    VARIABLE        reduce using rule 92 (if_stmt -> IF expression block .)
    FMT             reduce using rule 92 (if_stmt -> IF expression block .)
    CONTINUE        reduce using rule 92 (if_stmt -> IF expression block .)
    FUNC            reduce using rule 92 (if_stmt -> IF expression block .)
    IF              reduce using rule 92 (if_stmt -> IF expression block .)
    FOR             reduce using rule 92 (if_stmt -> IF expression block .)
    TYPE            reduce using rule 92 (if_stmt -> IF expression block .)
    SWITCH          reduce using rule 92 (if_stmt -> IF expression block .)
    LBRACKET        reduce using rule 92 (if_stmt -> IF expression block .)
    BREAK           reduce using rule 92 (if_stmt -> IF expression block .)
    RETURN          reduce using rule 92 (if_stmt -> IF expression block .)
    $end            reduce using rule 92 (if_stmt -> IF expression block .)
    RBRACE          reduce using rule 92 (if_stmt -> IF expression block .)
    CASE            reduce using rule 92 (if_stmt -> IF expression block .)
    DEFAULT         reduce using rule 92 (if_stmt -> IF expression block .)
    ELSE            shift and go to state 173


state 117

    (64) expression -> expression PLUS . term
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    term                           shift and go to state 174
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 118

    (65) expression -> expression MINUS . term
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    term                           shift and go to state 175
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 119

    (66) expression -> expression AND . expression
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 176
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 120

    (67) expression -> expression OR . expression
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 177
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 121

    (68) expression -> expression EQ . expression
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 178
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 122

    (69) expression -> expression NE . expression
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 179
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 123

    (70) expression -> expression LT . expression
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 180
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 124

    (71) expression -> expression GT . expression
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 181
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 125

    (72) expression -> expression LE . expression
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 182
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 126

    (73) expression -> expression GE . expression
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 183
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 127

    (75) term -> term TIMES . factor
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    VARIABLE        shift and go to state 185
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    factor                         shift and go to state 184
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 128

    (76) term -> term DIVIDE . factor
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    VARIABLE        shift and go to state 185
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    factor                         shift and go to state 186
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 129

    (110) struct_instance -> VARIABLE LBRACE . struct_fields_values RBRACE
    (111) struct_fields_values -> . field_value
    (112) struct_fields_values -> . field_value COMMA struct_fields_values
    (113) field_value -> . VARIABLE COLON expression

    VARIABLE        shift and go to state 187

    struct_fields_values           shift and go to state 188
    field_value                    shift and go to state 189

state 130

    (84) factor -> LPAREN expression . RPAREN
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

    RPAREN          shift and go to state 190
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126


state 131

    (128) make_expr -> MAKE LPAREN . MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> MAKE LPAREN . LBRACKET RBRACKET type RPAREN

    MAP             shift and go to state 191
    LBRACKET        shift and go to state 192


state 132

    (94) for_stmt -> FOR expression for_block .

    VAR             reduce using rule 94 (for_stmt -> FOR expression for_block .)
    VARIABLE        reduce using rule 94 (for_stmt -> FOR expression for_block .)
    FMT             reduce using rule 94 (for_stmt -> FOR expression for_block .)
    CONTINUE        reduce using rule 94 (for_stmt -> FOR expression for_block .)
    FUNC            reduce using rule 94 (for_stmt -> FOR expression for_block .)
    IF              reduce using rule 94 (for_stmt -> FOR expression for_block .)
    FOR             reduce using rule 94 (for_stmt -> FOR expression for_block .)
    TYPE            reduce using rule 94 (for_stmt -> FOR expression for_block .)
    SWITCH          reduce using rule 94 (for_stmt -> FOR expression for_block .)
    LBRACKET        reduce using rule 94 (for_stmt -> FOR expression for_block .)
    BREAK           reduce using rule 94 (for_stmt -> FOR expression for_block .)
    RETURN          reduce using rule 94 (for_stmt -> FOR expression for_block .)
    $end            reduce using rule 94 (for_stmt -> FOR expression for_block .)
    RBRACE          reduce using rule 94 (for_stmt -> FOR expression for_block .)
    CASE            reduce using rule 94 (for_stmt -> FOR expression for_block .)
    DEFAULT         reduce using rule 94 (for_stmt -> FOR expression for_block .)


state 133

    (96) for_block -> begin_loop . block end_loop
    (102) block -> . LBRACE program RBRACE

    LBRACE          shift and go to state 63

    block                          shift and go to state 193

state 134

    (95) for_stmt -> FOR assignment SEMICOLON . expression SEMICOLON for_update for_block
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 194
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 135

    (43) assignment -> VARIABLE ASIG . expression
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 88
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 136

    (105) struct_def -> TYPE VARIABLE STRUCT . LBRACE struct_fields RBRACE

    LBRACE          shift and go to state 195


state 137

    (114) switch_stmt -> SWITCH expression LBRACE . case_list RBRACE
    (116) case_list -> . case_clause
    (117) case_list -> . case_clause case_list
    (118) case_clause -> . CASE expression COLON program
    (119) case_clause -> . DEFAULT COLON program

    CASE            shift and go to state 140
    DEFAULT         shift and go to state 141

    case_list                      shift and go to state 196
    case_clause                    shift and go to state 139

state 138

    (115) switch_stmt -> SWITCH LBRACE case_list . RBRACE

    RBRACE          shift and go to state 197


state 139

    (116) case_list -> case_clause .
    (117) case_list -> case_clause . case_list
    (116) case_list -> . case_clause
    (117) case_list -> . case_clause case_list
    (118) case_clause -> . CASE expression COLON program
    (119) case_clause -> . DEFAULT COLON program

    RBRACE          reduce using rule 116 (case_list -> case_clause .)
    CASE            shift and go to state 140
    DEFAULT         shift and go to state 141

    case_clause                    shift and go to state 139
    case_list                      shift and go to state 198

state 140

    (118) case_clause -> CASE . expression COLON program
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 199
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 141

    (119) case_clause -> DEFAULT . COLON program

    COLON           shift and go to state 200


state 142

    (2) import_stmt -> IMPORT LPAREN STRING RPAREN .

    VAR             reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)
    VARIABLE        reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)
    FMT             reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)
    CONTINUE        reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)
    FUNC            reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)
    IF              reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)
    FOR             reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)
    TYPE            reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)
    SWITCH          reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)
    LBRACKET        reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)
    BREAK           reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)
    RETURN          reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)


state 143

    (121) map_declaration -> VARIABLE ASIG MAP LBRACKET . type RBRACKET type
    (122) map_declaration -> VARIABLE ASIG MAP LBRACKET . type RBRACKET type LBRACE map_params RBRACE
    (130) map_declaration_values -> VARIABLE ASIG MAP LBRACKET . type RBRACKET type LBRACE map_kv_pairs RBRACE
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 201

state 144

    (140) slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET . type LBRACE slice_values RBRACE
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 202

state 145

    (126) make_stmt -> VARIABLE ASIG MAKE LPAREN . MAP LBRACKET type RBRACKET type RPAREN
    (127) make_stmt -> VARIABLE ASIG MAKE LPAREN . LBRACKET RBRACKET type RPAREN
    (128) make_expr -> MAKE LPAREN . MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> MAKE LPAREN . LBRACKET RBRACKET type RPAREN

    MAP             shift and go to state 203
    LBRACKET        shift and go to state 204


state 146

    (143) new_stmt -> VARIABLE ASIG NEW LPAREN . VARIABLE RPAREN

    VARIABLE        shift and go to state 205


state 147

    (56) func_call -> VARIABLE LPAREN arg_list RPAREN .

    VAR             reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    VARIABLE        reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    FMT             reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    CONTINUE        reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    FUNC            reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    IF              reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    FOR             reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    TYPE            reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    SWITCH          reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    LBRACKET        reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    BREAK           reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    RETURN          reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    $end            reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    RBRACE          reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    CASE            reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    DEFAULT         reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    TIMES           reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    DIVIDE          reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    PLUS            reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    MINUS           reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    AND             reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    OR              reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    EQ              reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    NE              reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    LT              reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    GT              reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    LE              reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    GE              reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    LBRACE          reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    SEMICOLON       reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    COMMA           reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    RPAREN          reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    COLON           reduce using rule 56 (func_call -> VARIABLE LPAREN arg_list RPAREN .)


state 148

    (62) arg_list -> expression COMMA . arg_list
    (61) arg_list -> . expression
    (62) arg_list -> . expression COMMA arg_list
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 95
    arg_list                       shift and go to state 206
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 149

    (32) declaration -> VAR VARIABLE type ASIG . expression
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 207
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 150

    (33) declaration -> VAR VARIABLE type ASSIGN . expression
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 208
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 151

    (135) array_declaration -> VAR VARIABLE ASSIGN array_literal .

    VAR             reduce using rule 135 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    VARIABLE        reduce using rule 135 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    FMT             reduce using rule 135 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    CONTINUE        reduce using rule 135 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    FUNC            reduce using rule 135 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    IF              reduce using rule 135 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    FOR             reduce using rule 135 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    TYPE            reduce using rule 135 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    SWITCH          reduce using rule 135 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    LBRACKET        reduce using rule 135 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    BREAK           reduce using rule 135 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    RETURN          reduce using rule 135 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    $end            reduce using rule 135 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    RBRACE          reduce using rule 135 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    CASE            reduce using rule 135 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    DEFAULT         reduce using rule 135 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)


state 152

    (120) map_declaration -> VAR VARIABLE MAP LBRACKET . type RBRACKET type
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 209

state 153

    (134) array_declaration -> VAR VARIABLE LBRACKET NUMBER . RBRACKET type

    RBRACKET        shift and go to state 210


state 154

    (139) slice_declaration -> VAR VARIABLE LBRACKET RBRACKET . type
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 211

state 155

    (38) id_list -> VARIABLE .
    (39) id_list -> VARIABLE . COMMA id_list

    ASSIGN          reduce using rule 38 (id_list -> VARIABLE .)
    ASIG            reduce using rule 38 (id_list -> VARIABLE .)
    INT_TYPE        reduce using rule 38 (id_list -> VARIABLE .)
    FLOAT64_TYPE    reduce using rule 38 (id_list -> VARIABLE .)
    STRING_TYPE     reduce using rule 38 (id_list -> VARIABLE .)
    BOOL_TYPE       reduce using rule 38 (id_list -> VARIABLE .)
    COMMA           shift and go to state 100


state 156

    (39) id_list -> VARIABLE COMMA id_list .

    ASSIGN          reduce using rule 39 (id_list -> VARIABLE COMMA id_list .)
    ASIG            reduce using rule 39 (id_list -> VARIABLE COMMA id_list .)
    INT_TYPE        reduce using rule 39 (id_list -> VARIABLE COMMA id_list .)
    FLOAT64_TYPE    reduce using rule 39 (id_list -> VARIABLE COMMA id_list .)
    STRING_TYPE     reduce using rule 39 (id_list -> VARIABLE COMMA id_list .)
    BOOL_TYPE       reduce using rule 39 (id_list -> VARIABLE COMMA id_list .)


state 157

    (34) declaration -> VAR id_list type ASSIGN . expr_list
    (40) expr_list -> . expression
    (41) expr_list -> . expression COMMA expr_list
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expr_list                      shift and go to state 212
    expression                     shift and go to state 160
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 158

    (35) declaration -> VAR id_list type ASIG . expr_list
    (40) expr_list -> . expression
    (41) expr_list -> . expression COMMA expr_list
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expr_list                      shift and go to state 213
    expression                     shift and go to state 160
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 159

    (36) declaration -> VAR id_list ASSIGN expr_list .

    VAR             reduce using rule 36 (declaration -> VAR id_list ASSIGN expr_list .)
    VARIABLE        reduce using rule 36 (declaration -> VAR id_list ASSIGN expr_list .)
    FMT             reduce using rule 36 (declaration -> VAR id_list ASSIGN expr_list .)
    CONTINUE        reduce using rule 36 (declaration -> VAR id_list ASSIGN expr_list .)
    FUNC            reduce using rule 36 (declaration -> VAR id_list ASSIGN expr_list .)
    IF              reduce using rule 36 (declaration -> VAR id_list ASSIGN expr_list .)
    FOR             reduce using rule 36 (declaration -> VAR id_list ASSIGN expr_list .)
    TYPE            reduce using rule 36 (declaration -> VAR id_list ASSIGN expr_list .)
    SWITCH          reduce using rule 36 (declaration -> VAR id_list ASSIGN expr_list .)
    LBRACKET        reduce using rule 36 (declaration -> VAR id_list ASSIGN expr_list .)
    BREAK           reduce using rule 36 (declaration -> VAR id_list ASSIGN expr_list .)
    RETURN          reduce using rule 36 (declaration -> VAR id_list ASSIGN expr_list .)
    $end            reduce using rule 36 (declaration -> VAR id_list ASSIGN expr_list .)
    RBRACE          reduce using rule 36 (declaration -> VAR id_list ASSIGN expr_list .)
    CASE            reduce using rule 36 (declaration -> VAR id_list ASSIGN expr_list .)
    DEFAULT         reduce using rule 36 (declaration -> VAR id_list ASSIGN expr_list .)


state 160

    (40) expr_list -> expression .
    (41) expr_list -> expression . COMMA expr_list
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

    VAR             reduce using rule 40 (expr_list -> expression .)
    VARIABLE        reduce using rule 40 (expr_list -> expression .)
    FMT             reduce using rule 40 (expr_list -> expression .)
    CONTINUE        reduce using rule 40 (expr_list -> expression .)
    FUNC            reduce using rule 40 (expr_list -> expression .)
    IF              reduce using rule 40 (expr_list -> expression .)
    FOR             reduce using rule 40 (expr_list -> expression .)
    TYPE            reduce using rule 40 (expr_list -> expression .)
    SWITCH          reduce using rule 40 (expr_list -> expression .)
    LBRACKET        reduce using rule 40 (expr_list -> expression .)
    BREAK           reduce using rule 40 (expr_list -> expression .)
    RETURN          reduce using rule 40 (expr_list -> expression .)
    $end            reduce using rule 40 (expr_list -> expression .)
    RBRACE          reduce using rule 40 (expr_list -> expression .)
    CASE            reduce using rule 40 (expr_list -> expression .)
    DEFAULT         reduce using rule 40 (expr_list -> expression .)
    COMMA           shift and go to state 214
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126


state 161

    (37) declaration -> VAR id_list ASIG expr_list .

    VAR             reduce using rule 37 (declaration -> VAR id_list ASIG expr_list .)
    VARIABLE        reduce using rule 37 (declaration -> VAR id_list ASIG expr_list .)
    FMT             reduce using rule 37 (declaration -> VAR id_list ASIG expr_list .)
    CONTINUE        reduce using rule 37 (declaration -> VAR id_list ASIG expr_list .)
    FUNC            reduce using rule 37 (declaration -> VAR id_list ASIG expr_list .)
    IF              reduce using rule 37 (declaration -> VAR id_list ASIG expr_list .)
    FOR             reduce using rule 37 (declaration -> VAR id_list ASIG expr_list .)
    TYPE            reduce using rule 37 (declaration -> VAR id_list ASIG expr_list .)
    SWITCH          reduce using rule 37 (declaration -> VAR id_list ASIG expr_list .)
    LBRACKET        reduce using rule 37 (declaration -> VAR id_list ASIG expr_list .)
    BREAK           reduce using rule 37 (declaration -> VAR id_list ASIG expr_list .)
    RETURN          reduce using rule 37 (declaration -> VAR id_list ASIG expr_list .)
    $end            reduce using rule 37 (declaration -> VAR id_list ASIG expr_list .)
    RBRACE          reduce using rule 37 (declaration -> VAR id_list ASIG expr_list .)
    CASE            reduce using rule 37 (declaration -> VAR id_list ASIG expr_list .)
    DEFAULT         reduce using rule 37 (declaration -> VAR id_list ASIG expr_list .)


state 162

    (44) print_stmt -> FMT DOT PRINTF LPAREN . STRING COMMA expression RPAREN

    STRING          shift and go to state 215


state 163

    (45) print_stmt -> FMT DOT PRINTLN LPAREN . expression RPAREN
    (46) print_stmt -> FMT DOT PRINTLN LPAREN . STRING COMMA VARIABLE RPAREN
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    STRING          shift and go to state 217
    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 216
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 164

    (47) input_stmt -> FMT DOT SCANLN LPAREN . AMPER VARIABLE RPAREN

    AMPER           shift and go to state 218


state 165

    (103) struct_method -> FUNC LPAREN VARIABLE VARIABLE . RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (104) struct_method -> FUNC LPAREN VARIABLE VARIABLE . RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE

    RPAREN          shift and go to state 219


state 166

    (60) param -> VARIABLE . type
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 220

state 167

    (55) func_no_params_void -> FUNC VARIABLE LPAREN RPAREN . LBRACE program RBRACE
    (52) func_with_map -> FUNC VARIABLE LPAREN RPAREN . MAP LBRACKET type RBRACKET type func_body
    (54) func_header_no_params -> FUNC VARIABLE LPAREN RPAREN . type
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    LBRACE          shift and go to state 221
    MAP             shift and go to state 222
    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 223

state 168

    (49) func_header -> FUNC VARIABLE LPAREN param_list . RPAREN type

    RPAREN          shift and go to state 224


state 169

    (58) param_list -> param .
    (59) param_list -> param . COMMA param_list

    RPAREN          reduce using rule 58 (param_list -> param .)
    COMMA           shift and go to state 225


state 170

    (50) func_body -> LBRACE program RBRACE .

    VAR             reduce using rule 50 (func_body -> LBRACE program RBRACE .)
    VARIABLE        reduce using rule 50 (func_body -> LBRACE program RBRACE .)
    FMT             reduce using rule 50 (func_body -> LBRACE program RBRACE .)
    CONTINUE        reduce using rule 50 (func_body -> LBRACE program RBRACE .)
    FUNC            reduce using rule 50 (func_body -> LBRACE program RBRACE .)
    IF              reduce using rule 50 (func_body -> LBRACE program RBRACE .)
    FOR             reduce using rule 50 (func_body -> LBRACE program RBRACE .)
    TYPE            reduce using rule 50 (func_body -> LBRACE program RBRACE .)
    SWITCH          reduce using rule 50 (func_body -> LBRACE program RBRACE .)
    LBRACKET        reduce using rule 50 (func_body -> LBRACE program RBRACE .)
    BREAK           reduce using rule 50 (func_body -> LBRACE program RBRACE .)
    RETURN          reduce using rule 50 (func_body -> LBRACE program RBRACE .)
    $end            reduce using rule 50 (func_body -> LBRACE program RBRACE .)
    RBRACE          reduce using rule 50 (func_body -> LBRACE program RBRACE .)
    CASE            reduce using rule 50 (func_body -> LBRACE program RBRACE .)
    DEFAULT         reduce using rule 50 (func_body -> LBRACE program RBRACE .)


state 171

    (102) block -> LBRACE program RBRACE .

    VAR             reduce using rule 102 (block -> LBRACE program RBRACE .)
    VARIABLE        reduce using rule 102 (block -> LBRACE program RBRACE .)
    FMT             reduce using rule 102 (block -> LBRACE program RBRACE .)
    CONTINUE        reduce using rule 102 (block -> LBRACE program RBRACE .)
    FUNC            reduce using rule 102 (block -> LBRACE program RBRACE .)
    IF              reduce using rule 102 (block -> LBRACE program RBRACE .)
    FOR             reduce using rule 102 (block -> LBRACE program RBRACE .)
    TYPE            reduce using rule 102 (block -> LBRACE program RBRACE .)
    SWITCH          reduce using rule 102 (block -> LBRACE program RBRACE .)
    LBRACKET        reduce using rule 102 (block -> LBRACE program RBRACE .)
    BREAK           reduce using rule 102 (block -> LBRACE program RBRACE .)
    RETURN          reduce using rule 102 (block -> LBRACE program RBRACE .)
    $end            reduce using rule 102 (block -> LBRACE program RBRACE .)
    RBRACE          reduce using rule 102 (block -> LBRACE program RBRACE .)
    CASE            reduce using rule 102 (block -> LBRACE program RBRACE .)
    DEFAULT         reduce using rule 102 (block -> LBRACE program RBRACE .)
    ELSE            reduce using rule 102 (block -> LBRACE program RBRACE .)


state 172

    (136) array_literal -> LBRACKET NUMBER RBRACKET type . LBRACE array_values RBRACE

    LBRACE          shift and go to state 226


state 173

    (93) if_stmt -> IF expression block ELSE . block
    (102) block -> . LBRACE program RBRACE

    LBRACE          shift and go to state 63

    block                          shift and go to state 227

state 174

    (64) expression -> expression PLUS term .
    (75) term -> term . TIMES factor
    (76) term -> term . DIVIDE factor

    PLUS            reduce using rule 64 (expression -> expression PLUS term .)
    MINUS           reduce using rule 64 (expression -> expression PLUS term .)
    AND             reduce using rule 64 (expression -> expression PLUS term .)
    OR              reduce using rule 64 (expression -> expression PLUS term .)
    EQ              reduce using rule 64 (expression -> expression PLUS term .)
    NE              reduce using rule 64 (expression -> expression PLUS term .)
    LT              reduce using rule 64 (expression -> expression PLUS term .)
    GT              reduce using rule 64 (expression -> expression PLUS term .)
    LE              reduce using rule 64 (expression -> expression PLUS term .)
    GE              reduce using rule 64 (expression -> expression PLUS term .)
    LBRACE          reduce using rule 64 (expression -> expression PLUS term .)
    VAR             reduce using rule 64 (expression -> expression PLUS term .)
    VARIABLE        reduce using rule 64 (expression -> expression PLUS term .)
    FMT             reduce using rule 64 (expression -> expression PLUS term .)
    CONTINUE        reduce using rule 64 (expression -> expression PLUS term .)
    FUNC            reduce using rule 64 (expression -> expression PLUS term .)
    IF              reduce using rule 64 (expression -> expression PLUS term .)
    FOR             reduce using rule 64 (expression -> expression PLUS term .)
    TYPE            reduce using rule 64 (expression -> expression PLUS term .)
    SWITCH          reduce using rule 64 (expression -> expression PLUS term .)
    LBRACKET        reduce using rule 64 (expression -> expression PLUS term .)
    BREAK           reduce using rule 64 (expression -> expression PLUS term .)
    RETURN          reduce using rule 64 (expression -> expression PLUS term .)
    $end            reduce using rule 64 (expression -> expression PLUS term .)
    RBRACE          reduce using rule 64 (expression -> expression PLUS term .)
    CASE            reduce using rule 64 (expression -> expression PLUS term .)
    DEFAULT         reduce using rule 64 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 64 (expression -> expression PLUS term .)
    COMMA           reduce using rule 64 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 64 (expression -> expression PLUS term .)
    COLON           reduce using rule 64 (expression -> expression PLUS term .)
    TIMES           shift and go to state 127
    DIVIDE          shift and go to state 128


state 175

    (65) expression -> expression MINUS term .
    (75) term -> term . TIMES factor
    (76) term -> term . DIVIDE factor

    PLUS            reduce using rule 65 (expression -> expression MINUS term .)
    MINUS           reduce using rule 65 (expression -> expression MINUS term .)
    AND             reduce using rule 65 (expression -> expression MINUS term .)
    OR              reduce using rule 65 (expression -> expression MINUS term .)
    EQ              reduce using rule 65 (expression -> expression MINUS term .)
    NE              reduce using rule 65 (expression -> expression MINUS term .)
    LT              reduce using rule 65 (expression -> expression MINUS term .)
    GT              reduce using rule 65 (expression -> expression MINUS term .)
    LE              reduce using rule 65 (expression -> expression MINUS term .)
    GE              reduce using rule 65 (expression -> expression MINUS term .)
    LBRACE          reduce using rule 65 (expression -> expression MINUS term .)
    VAR             reduce using rule 65 (expression -> expression MINUS term .)
    VARIABLE        reduce using rule 65 (expression -> expression MINUS term .)
    FMT             reduce using rule 65 (expression -> expression MINUS term .)
    CONTINUE        reduce using rule 65 (expression -> expression MINUS term .)
    FUNC            reduce using rule 65 (expression -> expression MINUS term .)
    IF              reduce using rule 65 (expression -> expression MINUS term .)
    FOR             reduce using rule 65 (expression -> expression MINUS term .)
    TYPE            reduce using rule 65 (expression -> expression MINUS term .)
    SWITCH          reduce using rule 65 (expression -> expression MINUS term .)
    LBRACKET        reduce using rule 65 (expression -> expression MINUS term .)
    BREAK           reduce using rule 65 (expression -> expression MINUS term .)
    RETURN          reduce using rule 65 (expression -> expression MINUS term .)
    $end            reduce using rule 65 (expression -> expression MINUS term .)
    RBRACE          reduce using rule 65 (expression -> expression MINUS term .)
    CASE            reduce using rule 65 (expression -> expression MINUS term .)
    DEFAULT         reduce using rule 65 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 65 (expression -> expression MINUS term .)
    COMMA           reduce using rule 65 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 65 (expression -> expression MINUS term .)
    COLON           reduce using rule 65 (expression -> expression MINUS term .)
    TIMES           shift and go to state 127
    DIVIDE          shift and go to state 128


state 176

    (66) expression -> expression AND expression .
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 66 (expression -> expression AND expression .)
    VAR             reduce using rule 66 (expression -> expression AND expression .)
    VARIABLE        reduce using rule 66 (expression -> expression AND expression .)
    FMT             reduce using rule 66 (expression -> expression AND expression .)
    CONTINUE        reduce using rule 66 (expression -> expression AND expression .)
    FUNC            reduce using rule 66 (expression -> expression AND expression .)
    IF              reduce using rule 66 (expression -> expression AND expression .)
    FOR             reduce using rule 66 (expression -> expression AND expression .)
    TYPE            reduce using rule 66 (expression -> expression AND expression .)
    SWITCH          reduce using rule 66 (expression -> expression AND expression .)
    LBRACKET        reduce using rule 66 (expression -> expression AND expression .)
    BREAK           reduce using rule 66 (expression -> expression AND expression .)
    RETURN          reduce using rule 66 (expression -> expression AND expression .)
    $end            reduce using rule 66 (expression -> expression AND expression .)
    RBRACE          reduce using rule 66 (expression -> expression AND expression .)
    CASE            reduce using rule 66 (expression -> expression AND expression .)
    DEFAULT         reduce using rule 66 (expression -> expression AND expression .)
    SEMICOLON       reduce using rule 66 (expression -> expression AND expression .)
    COMMA           reduce using rule 66 (expression -> expression AND expression .)
    RPAREN          reduce using rule 66 (expression -> expression AND expression .)
    COLON           reduce using rule 66 (expression -> expression AND expression .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126

  ! PLUS            [ reduce using rule 66 (expression -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 66 (expression -> expression AND expression .) ]
  ! AND             [ reduce using rule 66 (expression -> expression AND expression .) ]
  ! OR              [ reduce using rule 66 (expression -> expression AND expression .) ]
  ! EQ              [ reduce using rule 66 (expression -> expression AND expression .) ]
  ! NE              [ reduce using rule 66 (expression -> expression AND expression .) ]
  ! LT              [ reduce using rule 66 (expression -> expression AND expression .) ]
  ! GT              [ reduce using rule 66 (expression -> expression AND expression .) ]
  ! LE              [ reduce using rule 66 (expression -> expression AND expression .) ]
  ! GE              [ reduce using rule 66 (expression -> expression AND expression .) ]


state 177

    (67) expression -> expression OR expression .
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 67 (expression -> expression OR expression .)
    VAR             reduce using rule 67 (expression -> expression OR expression .)
    VARIABLE        reduce using rule 67 (expression -> expression OR expression .)
    FMT             reduce using rule 67 (expression -> expression OR expression .)
    CONTINUE        reduce using rule 67 (expression -> expression OR expression .)
    FUNC            reduce using rule 67 (expression -> expression OR expression .)
    IF              reduce using rule 67 (expression -> expression OR expression .)
    FOR             reduce using rule 67 (expression -> expression OR expression .)
    TYPE            reduce using rule 67 (expression -> expression OR expression .)
    SWITCH          reduce using rule 67 (expression -> expression OR expression .)
    LBRACKET        reduce using rule 67 (expression -> expression OR expression .)
    BREAK           reduce using rule 67 (expression -> expression OR expression .)
    RETURN          reduce using rule 67 (expression -> expression OR expression .)
    $end            reduce using rule 67 (expression -> expression OR expression .)
    RBRACE          reduce using rule 67 (expression -> expression OR expression .)
    CASE            reduce using rule 67 (expression -> expression OR expression .)
    DEFAULT         reduce using rule 67 (expression -> expression OR expression .)
    SEMICOLON       reduce using rule 67 (expression -> expression OR expression .)
    COMMA           reduce using rule 67 (expression -> expression OR expression .)
    RPAREN          reduce using rule 67 (expression -> expression OR expression .)
    COLON           reduce using rule 67 (expression -> expression OR expression .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126

  ! PLUS            [ reduce using rule 67 (expression -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 67 (expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 67 (expression -> expression OR expression .) ]
  ! OR              [ reduce using rule 67 (expression -> expression OR expression .) ]
  ! EQ              [ reduce using rule 67 (expression -> expression OR expression .) ]
  ! NE              [ reduce using rule 67 (expression -> expression OR expression .) ]
  ! LT              [ reduce using rule 67 (expression -> expression OR expression .) ]
  ! GT              [ reduce using rule 67 (expression -> expression OR expression .) ]
  ! LE              [ reduce using rule 67 (expression -> expression OR expression .) ]
  ! GE              [ reduce using rule 67 (expression -> expression OR expression .) ]


state 178

    (68) expression -> expression EQ expression .
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 68 (expression -> expression EQ expression .)
    VAR             reduce using rule 68 (expression -> expression EQ expression .)
    VARIABLE        reduce using rule 68 (expression -> expression EQ expression .)
    FMT             reduce using rule 68 (expression -> expression EQ expression .)
    CONTINUE        reduce using rule 68 (expression -> expression EQ expression .)
    FUNC            reduce using rule 68 (expression -> expression EQ expression .)
    IF              reduce using rule 68 (expression -> expression EQ expression .)
    FOR             reduce using rule 68 (expression -> expression EQ expression .)
    TYPE            reduce using rule 68 (expression -> expression EQ expression .)
    SWITCH          reduce using rule 68 (expression -> expression EQ expression .)
    LBRACKET        reduce using rule 68 (expression -> expression EQ expression .)
    BREAK           reduce using rule 68 (expression -> expression EQ expression .)
    RETURN          reduce using rule 68 (expression -> expression EQ expression .)
    $end            reduce using rule 68 (expression -> expression EQ expression .)
    RBRACE          reduce using rule 68 (expression -> expression EQ expression .)
    CASE            reduce using rule 68 (expression -> expression EQ expression .)
    DEFAULT         reduce using rule 68 (expression -> expression EQ expression .)
    SEMICOLON       reduce using rule 68 (expression -> expression EQ expression .)
    COMMA           reduce using rule 68 (expression -> expression EQ expression .)
    RPAREN          reduce using rule 68 (expression -> expression EQ expression .)
    COLON           reduce using rule 68 (expression -> expression EQ expression .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126

  ! PLUS            [ reduce using rule 68 (expression -> expression EQ expression .) ]
  ! MINUS           [ reduce using rule 68 (expression -> expression EQ expression .) ]
  ! AND             [ reduce using rule 68 (expression -> expression EQ expression .) ]
  ! OR              [ reduce using rule 68 (expression -> expression EQ expression .) ]
  ! EQ              [ reduce using rule 68 (expression -> expression EQ expression .) ]
  ! NE              [ reduce using rule 68 (expression -> expression EQ expression .) ]
  ! LT              [ reduce using rule 68 (expression -> expression EQ expression .) ]
  ! GT              [ reduce using rule 68 (expression -> expression EQ expression .) ]
  ! LE              [ reduce using rule 68 (expression -> expression EQ expression .) ]
  ! GE              [ reduce using rule 68 (expression -> expression EQ expression .) ]


state 179

    (69) expression -> expression NE expression .
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 69 (expression -> expression NE expression .)
    VAR             reduce using rule 69 (expression -> expression NE expression .)
    VARIABLE        reduce using rule 69 (expression -> expression NE expression .)
    FMT             reduce using rule 69 (expression -> expression NE expression .)
    CONTINUE        reduce using rule 69 (expression -> expression NE expression .)
    FUNC            reduce using rule 69 (expression -> expression NE expression .)
    IF              reduce using rule 69 (expression -> expression NE expression .)
    FOR             reduce using rule 69 (expression -> expression NE expression .)
    TYPE            reduce using rule 69 (expression -> expression NE expression .)
    SWITCH          reduce using rule 69 (expression -> expression NE expression .)
    LBRACKET        reduce using rule 69 (expression -> expression NE expression .)
    BREAK           reduce using rule 69 (expression -> expression NE expression .)
    RETURN          reduce using rule 69 (expression -> expression NE expression .)
    $end            reduce using rule 69 (expression -> expression NE expression .)
    RBRACE          reduce using rule 69 (expression -> expression NE expression .)
    CASE            reduce using rule 69 (expression -> expression NE expression .)
    DEFAULT         reduce using rule 69 (expression -> expression NE expression .)
    SEMICOLON       reduce using rule 69 (expression -> expression NE expression .)
    COMMA           reduce using rule 69 (expression -> expression NE expression .)
    RPAREN          reduce using rule 69 (expression -> expression NE expression .)
    COLON           reduce using rule 69 (expression -> expression NE expression .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126

  ! PLUS            [ reduce using rule 69 (expression -> expression NE expression .) ]
  ! MINUS           [ reduce using rule 69 (expression -> expression NE expression .) ]
  ! AND             [ reduce using rule 69 (expression -> expression NE expression .) ]
  ! OR              [ reduce using rule 69 (expression -> expression NE expression .) ]
  ! EQ              [ reduce using rule 69 (expression -> expression NE expression .) ]
  ! NE              [ reduce using rule 69 (expression -> expression NE expression .) ]
  ! LT              [ reduce using rule 69 (expression -> expression NE expression .) ]
  ! GT              [ reduce using rule 69 (expression -> expression NE expression .) ]
  ! LE              [ reduce using rule 69 (expression -> expression NE expression .) ]
  ! GE              [ reduce using rule 69 (expression -> expression NE expression .) ]


state 180

    (70) expression -> expression LT expression .
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 70 (expression -> expression LT expression .)
    VAR             reduce using rule 70 (expression -> expression LT expression .)
    VARIABLE        reduce using rule 70 (expression -> expression LT expression .)
    FMT             reduce using rule 70 (expression -> expression LT expression .)
    CONTINUE        reduce using rule 70 (expression -> expression LT expression .)
    FUNC            reduce using rule 70 (expression -> expression LT expression .)
    IF              reduce using rule 70 (expression -> expression LT expression .)
    FOR             reduce using rule 70 (expression -> expression LT expression .)
    TYPE            reduce using rule 70 (expression -> expression LT expression .)
    SWITCH          reduce using rule 70 (expression -> expression LT expression .)
    LBRACKET        reduce using rule 70 (expression -> expression LT expression .)
    BREAK           reduce using rule 70 (expression -> expression LT expression .)
    RETURN          reduce using rule 70 (expression -> expression LT expression .)
    $end            reduce using rule 70 (expression -> expression LT expression .)
    RBRACE          reduce using rule 70 (expression -> expression LT expression .)
    CASE            reduce using rule 70 (expression -> expression LT expression .)
    DEFAULT         reduce using rule 70 (expression -> expression LT expression .)
    SEMICOLON       reduce using rule 70 (expression -> expression LT expression .)
    COMMA           reduce using rule 70 (expression -> expression LT expression .)
    RPAREN          reduce using rule 70 (expression -> expression LT expression .)
    COLON           reduce using rule 70 (expression -> expression LT expression .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126

  ! PLUS            [ reduce using rule 70 (expression -> expression LT expression .) ]
  ! MINUS           [ reduce using rule 70 (expression -> expression LT expression .) ]
  ! AND             [ reduce using rule 70 (expression -> expression LT expression .) ]
  ! OR              [ reduce using rule 70 (expression -> expression LT expression .) ]
  ! EQ              [ reduce using rule 70 (expression -> expression LT expression .) ]
  ! NE              [ reduce using rule 70 (expression -> expression LT expression .) ]
  ! LT              [ reduce using rule 70 (expression -> expression LT expression .) ]
  ! GT              [ reduce using rule 70 (expression -> expression LT expression .) ]
  ! LE              [ reduce using rule 70 (expression -> expression LT expression .) ]
  ! GE              [ reduce using rule 70 (expression -> expression LT expression .) ]


state 181

    (71) expression -> expression GT expression .
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 71 (expression -> expression GT expression .)
    VAR             reduce using rule 71 (expression -> expression GT expression .)
    VARIABLE        reduce using rule 71 (expression -> expression GT expression .)
    FMT             reduce using rule 71 (expression -> expression GT expression .)
    CONTINUE        reduce using rule 71 (expression -> expression GT expression .)
    FUNC            reduce using rule 71 (expression -> expression GT expression .)
    IF              reduce using rule 71 (expression -> expression GT expression .)
    FOR             reduce using rule 71 (expression -> expression GT expression .)
    TYPE            reduce using rule 71 (expression -> expression GT expression .)
    SWITCH          reduce using rule 71 (expression -> expression GT expression .)
    LBRACKET        reduce using rule 71 (expression -> expression GT expression .)
    BREAK           reduce using rule 71 (expression -> expression GT expression .)
    RETURN          reduce using rule 71 (expression -> expression GT expression .)
    $end            reduce using rule 71 (expression -> expression GT expression .)
    RBRACE          reduce using rule 71 (expression -> expression GT expression .)
    CASE            reduce using rule 71 (expression -> expression GT expression .)
    DEFAULT         reduce using rule 71 (expression -> expression GT expression .)
    SEMICOLON       reduce using rule 71 (expression -> expression GT expression .)
    COMMA           reduce using rule 71 (expression -> expression GT expression .)
    RPAREN          reduce using rule 71 (expression -> expression GT expression .)
    COLON           reduce using rule 71 (expression -> expression GT expression .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126

  ! PLUS            [ reduce using rule 71 (expression -> expression GT expression .) ]
  ! MINUS           [ reduce using rule 71 (expression -> expression GT expression .) ]
  ! AND             [ reduce using rule 71 (expression -> expression GT expression .) ]
  ! OR              [ reduce using rule 71 (expression -> expression GT expression .) ]
  ! EQ              [ reduce using rule 71 (expression -> expression GT expression .) ]
  ! NE              [ reduce using rule 71 (expression -> expression GT expression .) ]
  ! LT              [ reduce using rule 71 (expression -> expression GT expression .) ]
  ! GT              [ reduce using rule 71 (expression -> expression GT expression .) ]
  ! LE              [ reduce using rule 71 (expression -> expression GT expression .) ]
  ! GE              [ reduce using rule 71 (expression -> expression GT expression .) ]


state 182

    (72) expression -> expression LE expression .
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 72 (expression -> expression LE expression .)
    VAR             reduce using rule 72 (expression -> expression LE expression .)
    VARIABLE        reduce using rule 72 (expression -> expression LE expression .)
    FMT             reduce using rule 72 (expression -> expression LE expression .)
    CONTINUE        reduce using rule 72 (expression -> expression LE expression .)
    FUNC            reduce using rule 72 (expression -> expression LE expression .)
    IF              reduce using rule 72 (expression -> expression LE expression .)
    FOR             reduce using rule 72 (expression -> expression LE expression .)
    TYPE            reduce using rule 72 (expression -> expression LE expression .)
    SWITCH          reduce using rule 72 (expression -> expression LE expression .)
    LBRACKET        reduce using rule 72 (expression -> expression LE expression .)
    BREAK           reduce using rule 72 (expression -> expression LE expression .)
    RETURN          reduce using rule 72 (expression -> expression LE expression .)
    $end            reduce using rule 72 (expression -> expression LE expression .)
    RBRACE          reduce using rule 72 (expression -> expression LE expression .)
    CASE            reduce using rule 72 (expression -> expression LE expression .)
    DEFAULT         reduce using rule 72 (expression -> expression LE expression .)
    SEMICOLON       reduce using rule 72 (expression -> expression LE expression .)
    COMMA           reduce using rule 72 (expression -> expression LE expression .)
    RPAREN          reduce using rule 72 (expression -> expression LE expression .)
    COLON           reduce using rule 72 (expression -> expression LE expression .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126

  ! PLUS            [ reduce using rule 72 (expression -> expression LE expression .) ]
  ! MINUS           [ reduce using rule 72 (expression -> expression LE expression .) ]
  ! AND             [ reduce using rule 72 (expression -> expression LE expression .) ]
  ! OR              [ reduce using rule 72 (expression -> expression LE expression .) ]
  ! EQ              [ reduce using rule 72 (expression -> expression LE expression .) ]
  ! NE              [ reduce using rule 72 (expression -> expression LE expression .) ]
  ! LT              [ reduce using rule 72 (expression -> expression LE expression .) ]
  ! GT              [ reduce using rule 72 (expression -> expression LE expression .) ]
  ! LE              [ reduce using rule 72 (expression -> expression LE expression .) ]
  ! GE              [ reduce using rule 72 (expression -> expression LE expression .) ]


state 183

    (73) expression -> expression GE expression .
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 73 (expression -> expression GE expression .)
    VAR             reduce using rule 73 (expression -> expression GE expression .)
    VARIABLE        reduce using rule 73 (expression -> expression GE expression .)
    FMT             reduce using rule 73 (expression -> expression GE expression .)
    CONTINUE        reduce using rule 73 (expression -> expression GE expression .)
    FUNC            reduce using rule 73 (expression -> expression GE expression .)
    IF              reduce using rule 73 (expression -> expression GE expression .)
    FOR             reduce using rule 73 (expression -> expression GE expression .)
    TYPE            reduce using rule 73 (expression -> expression GE expression .)
    SWITCH          reduce using rule 73 (expression -> expression GE expression .)
    LBRACKET        reduce using rule 73 (expression -> expression GE expression .)
    BREAK           reduce using rule 73 (expression -> expression GE expression .)
    RETURN          reduce using rule 73 (expression -> expression GE expression .)
    $end            reduce using rule 73 (expression -> expression GE expression .)
    RBRACE          reduce using rule 73 (expression -> expression GE expression .)
    CASE            reduce using rule 73 (expression -> expression GE expression .)
    DEFAULT         reduce using rule 73 (expression -> expression GE expression .)
    SEMICOLON       reduce using rule 73 (expression -> expression GE expression .)
    COMMA           reduce using rule 73 (expression -> expression GE expression .)
    RPAREN          reduce using rule 73 (expression -> expression GE expression .)
    COLON           reduce using rule 73 (expression -> expression GE expression .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126

  ! PLUS            [ reduce using rule 73 (expression -> expression GE expression .) ]
  ! MINUS           [ reduce using rule 73 (expression -> expression GE expression .) ]
  ! AND             [ reduce using rule 73 (expression -> expression GE expression .) ]
  ! OR              [ reduce using rule 73 (expression -> expression GE expression .) ]
  ! EQ              [ reduce using rule 73 (expression -> expression GE expression .) ]
  ! NE              [ reduce using rule 73 (expression -> expression GE expression .) ]
  ! LT              [ reduce using rule 73 (expression -> expression GE expression .) ]
  ! GT              [ reduce using rule 73 (expression -> expression GE expression .) ]
  ! LE              [ reduce using rule 73 (expression -> expression GE expression .) ]
  ! GE              [ reduce using rule 73 (expression -> expression GE expression .) ]


state 184

    (75) term -> term TIMES factor .

    TIMES           reduce using rule 75 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 75 (term -> term TIMES factor .)
    PLUS            reduce using rule 75 (term -> term TIMES factor .)
    MINUS           reduce using rule 75 (term -> term TIMES factor .)
    AND             reduce using rule 75 (term -> term TIMES factor .)
    OR              reduce using rule 75 (term -> term TIMES factor .)
    EQ              reduce using rule 75 (term -> term TIMES factor .)
    NE              reduce using rule 75 (term -> term TIMES factor .)
    LT              reduce using rule 75 (term -> term TIMES factor .)
    GT              reduce using rule 75 (term -> term TIMES factor .)
    LE              reduce using rule 75 (term -> term TIMES factor .)
    GE              reduce using rule 75 (term -> term TIMES factor .)
    LBRACE          reduce using rule 75 (term -> term TIMES factor .)
    VAR             reduce using rule 75 (term -> term TIMES factor .)
    VARIABLE        reduce using rule 75 (term -> term TIMES factor .)
    FMT             reduce using rule 75 (term -> term TIMES factor .)
    CONTINUE        reduce using rule 75 (term -> term TIMES factor .)
    FUNC            reduce using rule 75 (term -> term TIMES factor .)
    IF              reduce using rule 75 (term -> term TIMES factor .)
    FOR             reduce using rule 75 (term -> term TIMES factor .)
    TYPE            reduce using rule 75 (term -> term TIMES factor .)
    SWITCH          reduce using rule 75 (term -> term TIMES factor .)
    LBRACKET        reduce using rule 75 (term -> term TIMES factor .)
    BREAK           reduce using rule 75 (term -> term TIMES factor .)
    RETURN          reduce using rule 75 (term -> term TIMES factor .)
    $end            reduce using rule 75 (term -> term TIMES factor .)
    RBRACE          reduce using rule 75 (term -> term TIMES factor .)
    CASE            reduce using rule 75 (term -> term TIMES factor .)
    DEFAULT         reduce using rule 75 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 75 (term -> term TIMES factor .)
    COMMA           reduce using rule 75 (term -> term TIMES factor .)
    RPAREN          reduce using rule 75 (term -> term TIMES factor .)
    COLON           reduce using rule 75 (term -> term TIMES factor .)


state 185

    (81) factor -> VARIABLE .
    (110) struct_instance -> VARIABLE . LBRACE struct_fields_values RBRACE
    (56) func_call -> VARIABLE . LPAREN arg_list RPAREN
    (57) func_call -> VARIABLE . LPAREN RPAREN

  ! shift/reduce conflict for LBRACE resolved as shift
    TIMES           reduce using rule 81 (factor -> VARIABLE .)
    DIVIDE          reduce using rule 81 (factor -> VARIABLE .)
    PLUS            reduce using rule 81 (factor -> VARIABLE .)
    MINUS           reduce using rule 81 (factor -> VARIABLE .)
    AND             reduce using rule 81 (factor -> VARIABLE .)
    OR              reduce using rule 81 (factor -> VARIABLE .)
    EQ              reduce using rule 81 (factor -> VARIABLE .)
    NE              reduce using rule 81 (factor -> VARIABLE .)
    LT              reduce using rule 81 (factor -> VARIABLE .)
    GT              reduce using rule 81 (factor -> VARIABLE .)
    LE              reduce using rule 81 (factor -> VARIABLE .)
    GE              reduce using rule 81 (factor -> VARIABLE .)
    VAR             reduce using rule 81 (factor -> VARIABLE .)
    VARIABLE        reduce using rule 81 (factor -> VARIABLE .)
    FMT             reduce using rule 81 (factor -> VARIABLE .)
    CONTINUE        reduce using rule 81 (factor -> VARIABLE .)
    FUNC            reduce using rule 81 (factor -> VARIABLE .)
    IF              reduce using rule 81 (factor -> VARIABLE .)
    FOR             reduce using rule 81 (factor -> VARIABLE .)
    TYPE            reduce using rule 81 (factor -> VARIABLE .)
    SWITCH          reduce using rule 81 (factor -> VARIABLE .)
    LBRACKET        reduce using rule 81 (factor -> VARIABLE .)
    BREAK           reduce using rule 81 (factor -> VARIABLE .)
    RETURN          reduce using rule 81 (factor -> VARIABLE .)
    $end            reduce using rule 81 (factor -> VARIABLE .)
    RBRACE          reduce using rule 81 (factor -> VARIABLE .)
    CASE            reduce using rule 81 (factor -> VARIABLE .)
    DEFAULT         reduce using rule 81 (factor -> VARIABLE .)
    SEMICOLON       reduce using rule 81 (factor -> VARIABLE .)
    COMMA           reduce using rule 81 (factor -> VARIABLE .)
    RPAREN          reduce using rule 81 (factor -> VARIABLE .)
    COLON           reduce using rule 81 (factor -> VARIABLE .)
    LBRACE          shift and go to state 129
    LPAREN          shift and go to state 51

  ! LBRACE          [ reduce using rule 81 (factor -> VARIABLE .) ]


state 186

    (76) term -> term DIVIDE factor .

    TIMES           reduce using rule 76 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 76 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 76 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 76 (term -> term DIVIDE factor .)
    AND             reduce using rule 76 (term -> term DIVIDE factor .)
    OR              reduce using rule 76 (term -> term DIVIDE factor .)
    EQ              reduce using rule 76 (term -> term DIVIDE factor .)
    NE              reduce using rule 76 (term -> term DIVIDE factor .)
    LT              reduce using rule 76 (term -> term DIVIDE factor .)
    GT              reduce using rule 76 (term -> term DIVIDE factor .)
    LE              reduce using rule 76 (term -> term DIVIDE factor .)
    GE              reduce using rule 76 (term -> term DIVIDE factor .)
    LBRACE          reduce using rule 76 (term -> term DIVIDE factor .)
    VAR             reduce using rule 76 (term -> term DIVIDE factor .)
    VARIABLE        reduce using rule 76 (term -> term DIVIDE factor .)
    FMT             reduce using rule 76 (term -> term DIVIDE factor .)
    CONTINUE        reduce using rule 76 (term -> term DIVIDE factor .)
    FUNC            reduce using rule 76 (term -> term DIVIDE factor .)
    IF              reduce using rule 76 (term -> term DIVIDE factor .)
    FOR             reduce using rule 76 (term -> term DIVIDE factor .)
    TYPE            reduce using rule 76 (term -> term DIVIDE factor .)
    SWITCH          reduce using rule 76 (term -> term DIVIDE factor .)
    LBRACKET        reduce using rule 76 (term -> term DIVIDE factor .)
    BREAK           reduce using rule 76 (term -> term DIVIDE factor .)
    RETURN          reduce using rule 76 (term -> term DIVIDE factor .)
    $end            reduce using rule 76 (term -> term DIVIDE factor .)
    RBRACE          reduce using rule 76 (term -> term DIVIDE factor .)
    CASE            reduce using rule 76 (term -> term DIVIDE factor .)
    DEFAULT         reduce using rule 76 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 76 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 76 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 76 (term -> term DIVIDE factor .)
    COLON           reduce using rule 76 (term -> term DIVIDE factor .)


state 187

    (113) field_value -> VARIABLE . COLON expression

    COLON           shift and go to state 228


state 188

    (110) struct_instance -> VARIABLE LBRACE struct_fields_values . RBRACE

    RBRACE          shift and go to state 229


state 189

    (111) struct_fields_values -> field_value .
    (112) struct_fields_values -> field_value . COMMA struct_fields_values

    RBRACE          reduce using rule 111 (struct_fields_values -> field_value .)
    COMMA           shift and go to state 230


state 190

    (84) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    EQ              reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    NE              reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    LE              reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    GE              reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    LBRACE          reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    VAR             reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    VARIABLE        reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    FMT             reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    CONTINUE        reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    FUNC            reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    IF              reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    FOR             reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    TYPE            reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    SWITCH          reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    BREAK           reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    CASE            reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    DEFAULT         reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 84 (factor -> LPAREN expression RPAREN .)
    COLON           reduce using rule 84 (factor -> LPAREN expression RPAREN .)


state 191

    (128) make_expr -> MAKE LPAREN MAP . LBRACKET type RBRACKET type RPAREN

    LBRACKET        shift and go to state 231


state 192

    (129) make_expr -> MAKE LPAREN LBRACKET . RBRACKET type RPAREN

    RBRACKET        shift and go to state 232


state 193

    (96) for_block -> begin_loop block . end_loop
    (98) end_loop -> .

    VAR             reduce using rule 98 (end_loop -> .)
    VARIABLE        reduce using rule 98 (end_loop -> .)
    FMT             reduce using rule 98 (end_loop -> .)
    CONTINUE        reduce using rule 98 (end_loop -> .)
    FUNC            reduce using rule 98 (end_loop -> .)
    IF              reduce using rule 98 (end_loop -> .)
    FOR             reduce using rule 98 (end_loop -> .)
    TYPE            reduce using rule 98 (end_loop -> .)
    SWITCH          reduce using rule 98 (end_loop -> .)
    LBRACKET        reduce using rule 98 (end_loop -> .)
    BREAK           reduce using rule 98 (end_loop -> .)
    RETURN          reduce using rule 98 (end_loop -> .)
    $end            reduce using rule 98 (end_loop -> .)
    RBRACE          reduce using rule 98 (end_loop -> .)
    CASE            reduce using rule 98 (end_loop -> .)
    DEFAULT         reduce using rule 98 (end_loop -> .)

    end_loop                       shift and go to state 233

state 194

    (95) for_stmt -> FOR assignment SEMICOLON expression . SEMICOLON for_update for_block
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

    SEMICOLON       shift and go to state 234
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126


state 195

    (105) struct_def -> TYPE VARIABLE STRUCT LBRACE . struct_fields RBRACE
    (106) struct_fields -> . struct_field
    (107) struct_fields -> . struct_field struct_fields
    (108) struct_field -> . VARIABLE type
    (109) struct_field -> . type
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    VARIABLE        shift and go to state 235
    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    struct_fields                  shift and go to state 236
    struct_field                   shift and go to state 237
    type                           shift and go to state 238

state 196

    (114) switch_stmt -> SWITCH expression LBRACE case_list . RBRACE

    RBRACE          shift and go to state 239


state 197

    (115) switch_stmt -> SWITCH LBRACE case_list RBRACE .

    VAR             reduce using rule 115 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    VARIABLE        reduce using rule 115 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    FMT             reduce using rule 115 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    CONTINUE        reduce using rule 115 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    FUNC            reduce using rule 115 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    IF              reduce using rule 115 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    FOR             reduce using rule 115 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    TYPE            reduce using rule 115 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    SWITCH          reduce using rule 115 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    LBRACKET        reduce using rule 115 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    BREAK           reduce using rule 115 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    RETURN          reduce using rule 115 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    $end            reduce using rule 115 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    RBRACE          reduce using rule 115 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    CASE            reduce using rule 115 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    DEFAULT         reduce using rule 115 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)


state 198

    (117) case_list -> case_clause case_list .

    RBRACE          reduce using rule 117 (case_list -> case_clause case_list .)


state 199

    (118) case_clause -> CASE expression . COLON program
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

    COLON           shift and go to state 240
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126


state 200

    (119) case_clause -> DEFAULT COLON . program
    (4) program -> . statement
    (5) program -> . statement program
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . print_stmt
    (9) statement -> . input_stmt
    (10) statement -> . continue_stmt
    (11) statement -> . struct_method
    (12) statement -> . func_def
    (13) statement -> . func_no_params
    (14) statement -> . func_no_params_void
    (15) statement -> . func_with_map
    (16) statement -> . func_call
    (17) statement -> . if_stmt
    (18) statement -> . for_stmt
    (19) statement -> . struct_def
    (20) statement -> . switch_stmt
    (21) statement -> . map_declaration
    (22) statement -> . map_declaration_values
    (23) statement -> . array_declaration
    (24) statement -> . array_literal
    (25) statement -> . slice_declaration
    (26) statement -> . make_stmt
    (27) statement -> . new_stmt
    (28) statement -> . break_stmt
    (29) statement -> . increment_stmt
    (30) statement -> . return_stmt
    (31) declaration -> . VAR VARIABLE type
    (32) declaration -> . VAR VARIABLE type ASIG expression
    (33) declaration -> . VAR VARIABLE type ASSIGN expression
    (34) declaration -> . VAR id_list type ASSIGN expr_list
    (35) declaration -> . VAR id_list type ASIG expr_list
    (36) declaration -> . VAR id_list ASSIGN expr_list
    (37) declaration -> . VAR id_list ASIG expr_list
    (42) assignment -> . VARIABLE ASSIGN expression
    (43) assignment -> . VARIABLE ASIG expression
    (44) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (45) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (46) print_stmt -> . FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN
    (47) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (99) continue_stmt -> . CONTINUE
    (103) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (104) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (48) func_def -> . func_header func_body
    (53) func_no_params -> . func_header_no_params block
    (55) func_no_params_void -> . FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE
    (52) func_with_map -> . FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN
    (92) if_stmt -> . IF expression block
    (93) if_stmt -> . IF expression block ELSE block
    (94) for_stmt -> . FOR expression for_block
    (95) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update for_block
    (105) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (114) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (115) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (120) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (121) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (122) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE
    (130) map_declaration_values -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
    (134) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (135) array_declaration -> . VAR VARIABLE ASSIGN array_literal
    (136) array_literal -> . LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (139) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (140) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (126) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (127) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (143) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (144) break_stmt -> . BREAK
    (145) increment_stmt -> . VARIABLE INCREMENT
    (146) increment_stmt -> . VARIABLE DECREMENT
    (51) return_stmt -> . RETURN expression
    (49) func_header -> . FUNC VARIABLE LPAREN param_list RPAREN type
    (54) func_header_no_params -> . FUNC VARIABLE LPAREN RPAREN type

    VAR             shift and go to state 34
    VARIABLE        shift and go to state 6
    FMT             shift and go to state 35
    CONTINUE        shift and go to state 36
    FUNC            shift and go to state 37
    IF              shift and go to state 41
    FOR             shift and go to state 42
    TYPE            shift and go to state 43
    SWITCH          shift and go to state 44
    LBRACKET        shift and go to state 40
    BREAK           shift and go to state 45
    RETURN          shift and go to state 46

    program                        shift and go to state 241
    statement                      shift and go to state 8
    declaration                    shift and go to state 9
    assignment                     shift and go to state 10
    print_stmt                     shift and go to state 11
    input_stmt                     shift and go to state 12
    continue_stmt                  shift and go to state 13
    struct_method                  shift and go to state 14
    func_def                       shift and go to state 15
    func_no_params                 shift and go to state 16
    func_no_params_void            shift and go to state 17
    func_with_map                  shift and go to state 18
    func_call                      shift and go to state 19
    if_stmt                        shift and go to state 20
    for_stmt                       shift and go to state 21
    struct_def                     shift and go to state 22
    switch_stmt                    shift and go to state 23
    map_declaration                shift and go to state 24
    map_declaration_values         shift and go to state 25
    array_declaration              shift and go to state 26
    array_literal                  shift and go to state 27
    slice_declaration              shift and go to state 28
    make_stmt                      shift and go to state 29
    new_stmt                       shift and go to state 30
    break_stmt                     shift and go to state 31
    increment_stmt                 shift and go to state 32
    return_stmt                    shift and go to state 33
    func_header                    shift and go to state 38
    func_header_no_params          shift and go to state 39

state 201

    (121) map_declaration -> VARIABLE ASIG MAP LBRACKET type . RBRACKET type
    (122) map_declaration -> VARIABLE ASIG MAP LBRACKET type . RBRACKET type LBRACE map_params RBRACE
    (130) map_declaration_values -> VARIABLE ASIG MAP LBRACKET type . RBRACKET type LBRACE map_kv_pairs RBRACE

    RBRACKET        shift and go to state 242


state 202

    (140) slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type . LBRACE slice_values RBRACE

    LBRACE          shift and go to state 243


state 203

    (126) make_stmt -> VARIABLE ASIG MAKE LPAREN MAP . LBRACKET type RBRACKET type RPAREN
    (128) make_expr -> MAKE LPAREN MAP . LBRACKET type RBRACKET type RPAREN

    LBRACKET        shift and go to state 244


state 204

    (127) make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET . RBRACKET type RPAREN
    (129) make_expr -> MAKE LPAREN LBRACKET . RBRACKET type RPAREN

    RBRACKET        shift and go to state 245


state 205

    (143) new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE . RPAREN

    RPAREN          shift and go to state 246


state 206

    (62) arg_list -> expression COMMA arg_list .

    RPAREN          reduce using rule 62 (arg_list -> expression COMMA arg_list .)


state 207

    (32) declaration -> VAR VARIABLE type ASIG expression .
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

    VAR             reduce using rule 32 (declaration -> VAR VARIABLE type ASIG expression .)
    VARIABLE        reduce using rule 32 (declaration -> VAR VARIABLE type ASIG expression .)
    FMT             reduce using rule 32 (declaration -> VAR VARIABLE type ASIG expression .)
    CONTINUE        reduce using rule 32 (declaration -> VAR VARIABLE type ASIG expression .)
    FUNC            reduce using rule 32 (declaration -> VAR VARIABLE type ASIG expression .)
    IF              reduce using rule 32 (declaration -> VAR VARIABLE type ASIG expression .)
    FOR             reduce using rule 32 (declaration -> VAR VARIABLE type ASIG expression .)
    TYPE            reduce using rule 32 (declaration -> VAR VARIABLE type ASIG expression .)
    SWITCH          reduce using rule 32 (declaration -> VAR VARIABLE type ASIG expression .)
    LBRACKET        reduce using rule 32 (declaration -> VAR VARIABLE type ASIG expression .)
    BREAK           reduce using rule 32 (declaration -> VAR VARIABLE type ASIG expression .)
    RETURN          reduce using rule 32 (declaration -> VAR VARIABLE type ASIG expression .)
    $end            reduce using rule 32 (declaration -> VAR VARIABLE type ASIG expression .)
    RBRACE          reduce using rule 32 (declaration -> VAR VARIABLE type ASIG expression .)
    CASE            reduce using rule 32 (declaration -> VAR VARIABLE type ASIG expression .)
    DEFAULT         reduce using rule 32 (declaration -> VAR VARIABLE type ASIG expression .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126


state 208

    (33) declaration -> VAR VARIABLE type ASSIGN expression .
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

    VAR             reduce using rule 33 (declaration -> VAR VARIABLE type ASSIGN expression .)
    VARIABLE        reduce using rule 33 (declaration -> VAR VARIABLE type ASSIGN expression .)
    FMT             reduce using rule 33 (declaration -> VAR VARIABLE type ASSIGN expression .)
    CONTINUE        reduce using rule 33 (declaration -> VAR VARIABLE type ASSIGN expression .)
    FUNC            reduce using rule 33 (declaration -> VAR VARIABLE type ASSIGN expression .)
    IF              reduce using rule 33 (declaration -> VAR VARIABLE type ASSIGN expression .)
    FOR             reduce using rule 33 (declaration -> VAR VARIABLE type ASSIGN expression .)
    TYPE            reduce using rule 33 (declaration -> VAR VARIABLE type ASSIGN expression .)
    SWITCH          reduce using rule 33 (declaration -> VAR VARIABLE type ASSIGN expression .)
    LBRACKET        reduce using rule 33 (declaration -> VAR VARIABLE type ASSIGN expression .)
    BREAK           reduce using rule 33 (declaration -> VAR VARIABLE type ASSIGN expression .)
    RETURN          reduce using rule 33 (declaration -> VAR VARIABLE type ASSIGN expression .)
    $end            reduce using rule 33 (declaration -> VAR VARIABLE type ASSIGN expression .)
    RBRACE          reduce using rule 33 (declaration -> VAR VARIABLE type ASSIGN expression .)
    CASE            reduce using rule 33 (declaration -> VAR VARIABLE type ASSIGN expression .)
    DEFAULT         reduce using rule 33 (declaration -> VAR VARIABLE type ASSIGN expression .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126


state 209

    (120) map_declaration -> VAR VARIABLE MAP LBRACKET type . RBRACKET type

    RBRACKET        shift and go to state 247


state 210

    (134) array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET . type
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 248

state 211

    (139) slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .

    VAR             reduce using rule 139 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    VARIABLE        reduce using rule 139 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    FMT             reduce using rule 139 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    CONTINUE        reduce using rule 139 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    FUNC            reduce using rule 139 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    IF              reduce using rule 139 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    FOR             reduce using rule 139 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    TYPE            reduce using rule 139 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    SWITCH          reduce using rule 139 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    LBRACKET        reduce using rule 139 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    BREAK           reduce using rule 139 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    RETURN          reduce using rule 139 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    $end            reduce using rule 139 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    RBRACE          reduce using rule 139 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    CASE            reduce using rule 139 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    DEFAULT         reduce using rule 139 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)


state 212

    (34) declaration -> VAR id_list type ASSIGN expr_list .

    VAR             reduce using rule 34 (declaration -> VAR id_list type ASSIGN expr_list .)
    VARIABLE        reduce using rule 34 (declaration -> VAR id_list type ASSIGN expr_list .)
    FMT             reduce using rule 34 (declaration -> VAR id_list type ASSIGN expr_list .)
    CONTINUE        reduce using rule 34 (declaration -> VAR id_list type ASSIGN expr_list .)
    FUNC            reduce using rule 34 (declaration -> VAR id_list type ASSIGN expr_list .)
    IF              reduce using rule 34 (declaration -> VAR id_list type ASSIGN expr_list .)
    FOR             reduce using rule 34 (declaration -> VAR id_list type ASSIGN expr_list .)
    TYPE            reduce using rule 34 (declaration -> VAR id_list type ASSIGN expr_list .)
    SWITCH          reduce using rule 34 (declaration -> VAR id_list type ASSIGN expr_list .)
    LBRACKET        reduce using rule 34 (declaration -> VAR id_list type ASSIGN expr_list .)
    BREAK           reduce using rule 34 (declaration -> VAR id_list type ASSIGN expr_list .)
    RETURN          reduce using rule 34 (declaration -> VAR id_list type ASSIGN expr_list .)
    $end            reduce using rule 34 (declaration -> VAR id_list type ASSIGN expr_list .)
    RBRACE          reduce using rule 34 (declaration -> VAR id_list type ASSIGN expr_list .)
    CASE            reduce using rule 34 (declaration -> VAR id_list type ASSIGN expr_list .)
    DEFAULT         reduce using rule 34 (declaration -> VAR id_list type ASSIGN expr_list .)


state 213

    (35) declaration -> VAR id_list type ASIG expr_list .

    VAR             reduce using rule 35 (declaration -> VAR id_list type ASIG expr_list .)
    VARIABLE        reduce using rule 35 (declaration -> VAR id_list type ASIG expr_list .)
    FMT             reduce using rule 35 (declaration -> VAR id_list type ASIG expr_list .)
    CONTINUE        reduce using rule 35 (declaration -> VAR id_list type ASIG expr_list .)
    FUNC            reduce using rule 35 (declaration -> VAR id_list type ASIG expr_list .)
    IF              reduce using rule 35 (declaration -> VAR id_list type ASIG expr_list .)
    FOR             reduce using rule 35 (declaration -> VAR id_list type ASIG expr_list .)
    TYPE            reduce using rule 35 (declaration -> VAR id_list type ASIG expr_list .)
    SWITCH          reduce using rule 35 (declaration -> VAR id_list type ASIG expr_list .)
    LBRACKET        reduce using rule 35 (declaration -> VAR id_list type ASIG expr_list .)
    BREAK           reduce using rule 35 (declaration -> VAR id_list type ASIG expr_list .)
    RETURN          reduce using rule 35 (declaration -> VAR id_list type ASIG expr_list .)
    $end            reduce using rule 35 (declaration -> VAR id_list type ASIG expr_list .)
    RBRACE          reduce using rule 35 (declaration -> VAR id_list type ASIG expr_list .)
    CASE            reduce using rule 35 (declaration -> VAR id_list type ASIG expr_list .)
    DEFAULT         reduce using rule 35 (declaration -> VAR id_list type ASIG expr_list .)


state 214

    (41) expr_list -> expression COMMA . expr_list
    (40) expr_list -> . expression
    (41) expr_list -> . expression COMMA expr_list
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 160
    expr_list                      shift and go to state 249
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 215

    (44) print_stmt -> FMT DOT PRINTF LPAREN STRING . COMMA expression RPAREN

    COMMA           shift and go to state 250


state 216

    (45) print_stmt -> FMT DOT PRINTLN LPAREN expression . RPAREN
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

    RPAREN          shift and go to state 251
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126


state 217

    (46) print_stmt -> FMT DOT PRINTLN LPAREN STRING . COMMA VARIABLE RPAREN
    (80) factor -> STRING .

    COMMA           shift and go to state 252
    TIMES           reduce using rule 80 (factor -> STRING .)
    DIVIDE          reduce using rule 80 (factor -> STRING .)
    RPAREN          reduce using rule 80 (factor -> STRING .)
    PLUS            reduce using rule 80 (factor -> STRING .)
    MINUS           reduce using rule 80 (factor -> STRING .)
    AND             reduce using rule 80 (factor -> STRING .)
    OR              reduce using rule 80 (factor -> STRING .)
    EQ              reduce using rule 80 (factor -> STRING .)
    NE              reduce using rule 80 (factor -> STRING .)
    LT              reduce using rule 80 (factor -> STRING .)
    GT              reduce using rule 80 (factor -> STRING .)
    LE              reduce using rule 80 (factor -> STRING .)
    GE              reduce using rule 80 (factor -> STRING .)


state 218

    (47) input_stmt -> FMT DOT SCANLN LPAREN AMPER . VARIABLE RPAREN

    VARIABLE        shift and go to state 253


state 219

    (103) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN . VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (104) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN . VARIABLE LPAREN RPAREN type LBRACE program RBRACE

    VARIABLE        shift and go to state 254


state 220

    (60) param -> VARIABLE type .

    COMMA           reduce using rule 60 (param -> VARIABLE type .)
    RPAREN          reduce using rule 60 (param -> VARIABLE type .)


state 221

    (55) func_no_params_void -> FUNC VARIABLE LPAREN RPAREN LBRACE . program RBRACE
    (4) program -> . statement
    (5) program -> . statement program
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . print_stmt
    (9) statement -> . input_stmt
    (10) statement -> . continue_stmt
    (11) statement -> . struct_method
    (12) statement -> . func_def
    (13) statement -> . func_no_params
    (14) statement -> . func_no_params_void
    (15) statement -> . func_with_map
    (16) statement -> . func_call
    (17) statement -> . if_stmt
    (18) statement -> . for_stmt
    (19) statement -> . struct_def
    (20) statement -> . switch_stmt
    (21) statement -> . map_declaration
    (22) statement -> . map_declaration_values
    (23) statement -> . array_declaration
    (24) statement -> . array_literal
    (25) statement -> . slice_declaration
    (26) statement -> . make_stmt
    (27) statement -> . new_stmt
    (28) statement -> . break_stmt
    (29) statement -> . increment_stmt
    (30) statement -> . return_stmt
    (31) declaration -> . VAR VARIABLE type
    (32) declaration -> . VAR VARIABLE type ASIG expression
    (33) declaration -> . VAR VARIABLE type ASSIGN expression
    (34) declaration -> . VAR id_list type ASSIGN expr_list
    (35) declaration -> . VAR id_list type ASIG expr_list
    (36) declaration -> . VAR id_list ASSIGN expr_list
    (37) declaration -> . VAR id_list ASIG expr_list
    (42) assignment -> . VARIABLE ASSIGN expression
    (43) assignment -> . VARIABLE ASIG expression
    (44) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (45) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (46) print_stmt -> . FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN
    (47) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (99) continue_stmt -> . CONTINUE
    (103) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (104) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (48) func_def -> . func_header func_body
    (53) func_no_params -> . func_header_no_params block
    (55) func_no_params_void -> . FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE
    (52) func_with_map -> . FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN
    (92) if_stmt -> . IF expression block
    (93) if_stmt -> . IF expression block ELSE block
    (94) for_stmt -> . FOR expression for_block
    (95) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update for_block
    (105) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (114) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (115) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (120) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (121) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (122) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE
    (130) map_declaration_values -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
    (134) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (135) array_declaration -> . VAR VARIABLE ASSIGN array_literal
    (136) array_literal -> . LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (139) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (140) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (126) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (127) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (143) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (144) break_stmt -> . BREAK
    (145) increment_stmt -> . VARIABLE INCREMENT
    (146) increment_stmt -> . VARIABLE DECREMENT
    (51) return_stmt -> . RETURN expression
    (49) func_header -> . FUNC VARIABLE LPAREN param_list RPAREN type
    (54) func_header_no_params -> . FUNC VARIABLE LPAREN RPAREN type

    VAR             shift and go to state 34
    VARIABLE        shift and go to state 6
    FMT             shift and go to state 35
    CONTINUE        shift and go to state 36
    FUNC            shift and go to state 37
    IF              shift and go to state 41
    FOR             shift and go to state 42
    TYPE            shift and go to state 43
    SWITCH          shift and go to state 44
    LBRACKET        shift and go to state 40
    BREAK           shift and go to state 45
    RETURN          shift and go to state 46

    program                        shift and go to state 255
    statement                      shift and go to state 8
    declaration                    shift and go to state 9
    assignment                     shift and go to state 10
    print_stmt                     shift and go to state 11
    input_stmt                     shift and go to state 12
    continue_stmt                  shift and go to state 13
    struct_method                  shift and go to state 14
    func_def                       shift and go to state 15
    func_no_params                 shift and go to state 16
    func_no_params_void            shift and go to state 17
    func_with_map                  shift and go to state 18
    func_call                      shift and go to state 19
    if_stmt                        shift and go to state 20
    for_stmt                       shift and go to state 21
    struct_def                     shift and go to state 22
    switch_stmt                    shift and go to state 23
    map_declaration                shift and go to state 24
    map_declaration_values         shift and go to state 25
    array_declaration              shift and go to state 26
    array_literal                  shift and go to state 27
    slice_declaration              shift and go to state 28
    make_stmt                      shift and go to state 29
    new_stmt                       shift and go to state 30
    break_stmt                     shift and go to state 31
    increment_stmt                 shift and go to state 32
    return_stmt                    shift and go to state 33
    func_header                    shift and go to state 38
    func_header_no_params          shift and go to state 39

state 222

    (52) func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP . LBRACKET type RBRACKET type func_body

    LBRACKET        shift and go to state 256


state 223

    (54) func_header_no_params -> FUNC VARIABLE LPAREN RPAREN type .

    LBRACE          reduce using rule 54 (func_header_no_params -> FUNC VARIABLE LPAREN RPAREN type .)


state 224

    (49) func_header -> FUNC VARIABLE LPAREN param_list RPAREN . type
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 257

state 225

    (59) param_list -> param COMMA . param_list
    (58) param_list -> . param
    (59) param_list -> . param COMMA param_list
    (60) param -> . VARIABLE type

    VARIABLE        shift and go to state 166

    param                          shift and go to state 169
    param_list                     shift and go to state 258

state 226

    (136) array_literal -> LBRACKET NUMBER RBRACKET type LBRACE . array_values RBRACE
    (137) array_values -> . expression
    (138) array_values -> . expression COMMA array_values
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    array_values                   shift and go to state 259
    expression                     shift and go to state 260
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 227

    (93) if_stmt -> IF expression block ELSE block .

    VAR             reduce using rule 93 (if_stmt -> IF expression block ELSE block .)
    VARIABLE        reduce using rule 93 (if_stmt -> IF expression block ELSE block .)
    FMT             reduce using rule 93 (if_stmt -> IF expression block ELSE block .)
    CONTINUE        reduce using rule 93 (if_stmt -> IF expression block ELSE block .)
    FUNC            reduce using rule 93 (if_stmt -> IF expression block ELSE block .)
    IF              reduce using rule 93 (if_stmt -> IF expression block ELSE block .)
    FOR             reduce using rule 93 (if_stmt -> IF expression block ELSE block .)
    TYPE            reduce using rule 93 (if_stmt -> IF expression block ELSE block .)
    SWITCH          reduce using rule 93 (if_stmt -> IF expression block ELSE block .)
    LBRACKET        reduce using rule 93 (if_stmt -> IF expression block ELSE block .)
    BREAK           reduce using rule 93 (if_stmt -> IF expression block ELSE block .)
    RETURN          reduce using rule 93 (if_stmt -> IF expression block ELSE block .)
    $end            reduce using rule 93 (if_stmt -> IF expression block ELSE block .)
    RBRACE          reduce using rule 93 (if_stmt -> IF expression block ELSE block .)
    CASE            reduce using rule 93 (if_stmt -> IF expression block ELSE block .)
    DEFAULT         reduce using rule 93 (if_stmt -> IF expression block ELSE block .)


state 228

    (113) field_value -> VARIABLE COLON . expression
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 261
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 229

    (110) struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .

    TIMES           reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    DIVIDE          reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    PLUS            reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    MINUS           reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    AND             reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    OR              reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    EQ              reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    NE              reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    LT              reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    GT              reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    LE              reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    GE              reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    LBRACE          reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    VAR             reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    VARIABLE        reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    FMT             reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    CONTINUE        reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    FUNC            reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    IF              reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    FOR             reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    TYPE            reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    SWITCH          reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    LBRACKET        reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    BREAK           reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    RETURN          reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    $end            reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    RBRACE          reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    CASE            reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    DEFAULT         reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    SEMICOLON       reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    COMMA           reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    RPAREN          reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    COLON           reduce using rule 110 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)


state 230

    (112) struct_fields_values -> field_value COMMA . struct_fields_values
    (111) struct_fields_values -> . field_value
    (112) struct_fields_values -> . field_value COMMA struct_fields_values
    (113) field_value -> . VARIABLE COLON expression

    VARIABLE        shift and go to state 187

    field_value                    shift and go to state 189
    struct_fields_values           shift and go to state 262

state 231

    (128) make_expr -> MAKE LPAREN MAP LBRACKET . type RBRACKET type RPAREN
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 263

state 232

    (129) make_expr -> MAKE LPAREN LBRACKET RBRACKET . type RPAREN
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 264

state 233

    (96) for_block -> begin_loop block end_loop .

    VAR             reduce using rule 96 (for_block -> begin_loop block end_loop .)
    VARIABLE        reduce using rule 96 (for_block -> begin_loop block end_loop .)
    FMT             reduce using rule 96 (for_block -> begin_loop block end_loop .)
    CONTINUE        reduce using rule 96 (for_block -> begin_loop block end_loop .)
    FUNC            reduce using rule 96 (for_block -> begin_loop block end_loop .)
    IF              reduce using rule 96 (for_block -> begin_loop block end_loop .)
    FOR             reduce using rule 96 (for_block -> begin_loop block end_loop .)
    TYPE            reduce using rule 96 (for_block -> begin_loop block end_loop .)
    SWITCH          reduce using rule 96 (for_block -> begin_loop block end_loop .)
    LBRACKET        reduce using rule 96 (for_block -> begin_loop block end_loop .)
    BREAK           reduce using rule 96 (for_block -> begin_loop block end_loop .)
    RETURN          reduce using rule 96 (for_block -> begin_loop block end_loop .)
    $end            reduce using rule 96 (for_block -> begin_loop block end_loop .)
    RBRACE          reduce using rule 96 (for_block -> begin_loop block end_loop .)
    CASE            reduce using rule 96 (for_block -> begin_loop block end_loop .)
    DEFAULT         reduce using rule 96 (for_block -> begin_loop block end_loop .)


state 234

    (95) for_stmt -> FOR assignment SEMICOLON expression SEMICOLON . for_update for_block
    (100) for_update -> . assignment
    (101) for_update -> . increment_stmt
    (42) assignment -> . VARIABLE ASSIGN expression
    (43) assignment -> . VARIABLE ASIG expression
    (145) increment_stmt -> . VARIABLE INCREMENT
    (146) increment_stmt -> . VARIABLE DECREMENT

    VARIABLE        shift and go to state 268

    assignment                     shift and go to state 265
    for_update                     shift and go to state 266
    increment_stmt                 shift and go to state 267

state 235

    (108) struct_field -> VARIABLE . type
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 269

state 236

    (105) struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields . RBRACE

    RBRACE          shift and go to state 270


state 237

    (106) struct_fields -> struct_field .
    (107) struct_fields -> struct_field . struct_fields
    (106) struct_fields -> . struct_field
    (107) struct_fields -> . struct_field struct_fields
    (108) struct_field -> . VARIABLE type
    (109) struct_field -> . type
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    RBRACE          reduce using rule 106 (struct_fields -> struct_field .)
    VARIABLE        shift and go to state 235
    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    struct_field                   shift and go to state 237
    struct_fields                  shift and go to state 271
    type                           shift and go to state 238

state 238

    (109) struct_field -> type .

    VARIABLE        reduce using rule 109 (struct_field -> type .)
    INT_TYPE        reduce using rule 109 (struct_field -> type .)
    FLOAT64_TYPE    reduce using rule 109 (struct_field -> type .)
    STRING_TYPE     reduce using rule 109 (struct_field -> type .)
    BOOL_TYPE       reduce using rule 109 (struct_field -> type .)
    RBRACE          reduce using rule 109 (struct_field -> type .)


state 239

    (114) switch_stmt -> SWITCH expression LBRACE case_list RBRACE .

    VAR             reduce using rule 114 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    VARIABLE        reduce using rule 114 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    FMT             reduce using rule 114 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    CONTINUE        reduce using rule 114 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    FUNC            reduce using rule 114 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    IF              reduce using rule 114 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    FOR             reduce using rule 114 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    TYPE            reduce using rule 114 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    SWITCH          reduce using rule 114 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    LBRACKET        reduce using rule 114 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    BREAK           reduce using rule 114 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    RETURN          reduce using rule 114 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    $end            reduce using rule 114 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    RBRACE          reduce using rule 114 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    CASE            reduce using rule 114 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    DEFAULT         reduce using rule 114 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)


state 240

    (118) case_clause -> CASE expression COLON . program
    (4) program -> . statement
    (5) program -> . statement program
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . print_stmt
    (9) statement -> . input_stmt
    (10) statement -> . continue_stmt
    (11) statement -> . struct_method
    (12) statement -> . func_def
    (13) statement -> . func_no_params
    (14) statement -> . func_no_params_void
    (15) statement -> . func_with_map
    (16) statement -> . func_call
    (17) statement -> . if_stmt
    (18) statement -> . for_stmt
    (19) statement -> . struct_def
    (20) statement -> . switch_stmt
    (21) statement -> . map_declaration
    (22) statement -> . map_declaration_values
    (23) statement -> . array_declaration
    (24) statement -> . array_literal
    (25) statement -> . slice_declaration
    (26) statement -> . make_stmt
    (27) statement -> . new_stmt
    (28) statement -> . break_stmt
    (29) statement -> . increment_stmt
    (30) statement -> . return_stmt
    (31) declaration -> . VAR VARIABLE type
    (32) declaration -> . VAR VARIABLE type ASIG expression
    (33) declaration -> . VAR VARIABLE type ASSIGN expression
    (34) declaration -> . VAR id_list type ASSIGN expr_list
    (35) declaration -> . VAR id_list type ASIG expr_list
    (36) declaration -> . VAR id_list ASSIGN expr_list
    (37) declaration -> . VAR id_list ASIG expr_list
    (42) assignment -> . VARIABLE ASSIGN expression
    (43) assignment -> . VARIABLE ASIG expression
    (44) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (45) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (46) print_stmt -> . FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN
    (47) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (99) continue_stmt -> . CONTINUE
    (103) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (104) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (48) func_def -> . func_header func_body
    (53) func_no_params -> . func_header_no_params block
    (55) func_no_params_void -> . FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE
    (52) func_with_map -> . FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN
    (92) if_stmt -> . IF expression block
    (93) if_stmt -> . IF expression block ELSE block
    (94) for_stmt -> . FOR expression for_block
    (95) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update for_block
    (105) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (114) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (115) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (120) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (121) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (122) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE
    (130) map_declaration_values -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
    (134) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (135) array_declaration -> . VAR VARIABLE ASSIGN array_literal
    (136) array_literal -> . LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (139) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (140) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (126) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (127) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (143) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (144) break_stmt -> . BREAK
    (145) increment_stmt -> . VARIABLE INCREMENT
    (146) increment_stmt -> . VARIABLE DECREMENT
    (51) return_stmt -> . RETURN expression
    (49) func_header -> . FUNC VARIABLE LPAREN param_list RPAREN type
    (54) func_header_no_params -> . FUNC VARIABLE LPAREN RPAREN type

    VAR             shift and go to state 34
    VARIABLE        shift and go to state 6
    FMT             shift and go to state 35
    CONTINUE        shift and go to state 36
    FUNC            shift and go to state 37
    IF              shift and go to state 41
    FOR             shift and go to state 42
    TYPE            shift and go to state 43
    SWITCH          shift and go to state 44
    LBRACKET        shift and go to state 40
    BREAK           shift and go to state 45
    RETURN          shift and go to state 46

    program                        shift and go to state 272
    statement                      shift and go to state 8
    declaration                    shift and go to state 9
    assignment                     shift and go to state 10
    print_stmt                     shift and go to state 11
    input_stmt                     shift and go to state 12
    continue_stmt                  shift and go to state 13
    struct_method                  shift and go to state 14
    func_def                       shift and go to state 15
    func_no_params                 shift and go to state 16
    func_no_params_void            shift and go to state 17
    func_with_map                  shift and go to state 18
    func_call                      shift and go to state 19
    if_stmt                        shift and go to state 20
    for_stmt                       shift and go to state 21
    struct_def                     shift and go to state 22
    switch_stmt                    shift and go to state 23
    map_declaration                shift and go to state 24
    map_declaration_values         shift and go to state 25
    array_declaration              shift and go to state 26
    array_literal                  shift and go to state 27
    slice_declaration              shift and go to state 28
    make_stmt                      shift and go to state 29
    new_stmt                       shift and go to state 30
    break_stmt                     shift and go to state 31
    increment_stmt                 shift and go to state 32
    return_stmt                    shift and go to state 33
    func_header                    shift and go to state 38
    func_header_no_params          shift and go to state 39

state 241

    (119) case_clause -> DEFAULT COLON program .

    CASE            reduce using rule 119 (case_clause -> DEFAULT COLON program .)
    DEFAULT         reduce using rule 119 (case_clause -> DEFAULT COLON program .)
    RBRACE          reduce using rule 119 (case_clause -> DEFAULT COLON program .)


state 242

    (121) map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET . type
    (122) map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET . type LBRACE map_params RBRACE
    (130) map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET . type LBRACE map_kv_pairs RBRACE
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 273

state 243

    (140) slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE . slice_values RBRACE
    (141) slice_values -> . expression
    (142) slice_values -> . expression COMMA slice_values
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    slice_values                   shift and go to state 274
    expression                     shift and go to state 275
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 244

    (126) make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET . type RBRACKET type RPAREN
    (128) make_expr -> MAKE LPAREN MAP LBRACKET . type RBRACKET type RPAREN
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 276

state 245

    (127) make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET . type RPAREN
    (129) make_expr -> MAKE LPAREN LBRACKET RBRACKET . type RPAREN
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 277

state 246

    (143) new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .

    VAR             reduce using rule 143 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    VARIABLE        reduce using rule 143 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    FMT             reduce using rule 143 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    CONTINUE        reduce using rule 143 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    FUNC            reduce using rule 143 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    IF              reduce using rule 143 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    FOR             reduce using rule 143 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    TYPE            reduce using rule 143 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    SWITCH          reduce using rule 143 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    LBRACKET        reduce using rule 143 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    BREAK           reduce using rule 143 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    RETURN          reduce using rule 143 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    $end            reduce using rule 143 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    RBRACE          reduce using rule 143 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    CASE            reduce using rule 143 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    DEFAULT         reduce using rule 143 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)


state 247

    (120) map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET . type
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 278

state 248

    (134) array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .

    VAR             reduce using rule 134 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    VARIABLE        reduce using rule 134 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    FMT             reduce using rule 134 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    CONTINUE        reduce using rule 134 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    FUNC            reduce using rule 134 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    IF              reduce using rule 134 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    FOR             reduce using rule 134 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    TYPE            reduce using rule 134 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    SWITCH          reduce using rule 134 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    LBRACKET        reduce using rule 134 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    BREAK           reduce using rule 134 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    RETURN          reduce using rule 134 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    $end            reduce using rule 134 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    RBRACE          reduce using rule 134 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    CASE            reduce using rule 134 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    DEFAULT         reduce using rule 134 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)


state 249

    (41) expr_list -> expression COMMA expr_list .

    VAR             reduce using rule 41 (expr_list -> expression COMMA expr_list .)
    VARIABLE        reduce using rule 41 (expr_list -> expression COMMA expr_list .)
    FMT             reduce using rule 41 (expr_list -> expression COMMA expr_list .)
    CONTINUE        reduce using rule 41 (expr_list -> expression COMMA expr_list .)
    FUNC            reduce using rule 41 (expr_list -> expression COMMA expr_list .)
    IF              reduce using rule 41 (expr_list -> expression COMMA expr_list .)
    FOR             reduce using rule 41 (expr_list -> expression COMMA expr_list .)
    TYPE            reduce using rule 41 (expr_list -> expression COMMA expr_list .)
    SWITCH          reduce using rule 41 (expr_list -> expression COMMA expr_list .)
    LBRACKET        reduce using rule 41 (expr_list -> expression COMMA expr_list .)
    BREAK           reduce using rule 41 (expr_list -> expression COMMA expr_list .)
    RETURN          reduce using rule 41 (expr_list -> expression COMMA expr_list .)
    $end            reduce using rule 41 (expr_list -> expression COMMA expr_list .)
    RBRACE          reduce using rule 41 (expr_list -> expression COMMA expr_list .)
    CASE            reduce using rule 41 (expr_list -> expression COMMA expr_list .)
    DEFAULT         reduce using rule 41 (expr_list -> expression COMMA expr_list .)


state 250

    (44) print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA . expression RPAREN
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 279
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 251

    (45) print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .

    VAR             reduce using rule 45 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    VARIABLE        reduce using rule 45 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    FMT             reduce using rule 45 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    CONTINUE        reduce using rule 45 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    FUNC            reduce using rule 45 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    IF              reduce using rule 45 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    FOR             reduce using rule 45 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    TYPE            reduce using rule 45 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    SWITCH          reduce using rule 45 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 45 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    BREAK           reduce using rule 45 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    RETURN          reduce using rule 45 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    $end            reduce using rule 45 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    RBRACE          reduce using rule 45 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    CASE            reduce using rule 45 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    DEFAULT         reduce using rule 45 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)


state 252

    (46) print_stmt -> FMT DOT PRINTLN LPAREN STRING COMMA . VARIABLE RPAREN

    VARIABLE        shift and go to state 280


state 253

    (47) input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE . RPAREN

    RPAREN          shift and go to state 281


state 254

    (103) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE . LPAREN param_list RPAREN type LBRACE program RBRACE
    (104) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE . LPAREN RPAREN type LBRACE program RBRACE

    LPAREN          shift and go to state 282


state 255

    (55) func_no_params_void -> FUNC VARIABLE LPAREN RPAREN LBRACE program . RBRACE

    RBRACE          shift and go to state 283


state 256

    (52) func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP LBRACKET . type RBRACKET type func_body
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 284

state 257

    (49) func_header -> FUNC VARIABLE LPAREN param_list RPAREN type .

    LBRACE          reduce using rule 49 (func_header -> FUNC VARIABLE LPAREN param_list RPAREN type .)


state 258

    (59) param_list -> param COMMA param_list .

    RPAREN          reduce using rule 59 (param_list -> param COMMA param_list .)


state 259

    (136) array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values . RBRACE

    RBRACE          shift and go to state 285


state 260

    (137) array_values -> expression .
    (138) array_values -> expression . COMMA array_values
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

    RBRACE          reduce using rule 137 (array_values -> expression .)
    COMMA           shift and go to state 286
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126


state 261

    (113) field_value -> VARIABLE COLON expression .
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

    COMMA           reduce using rule 113 (field_value -> VARIABLE COLON expression .)
    RBRACE          reduce using rule 113 (field_value -> VARIABLE COLON expression .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126


state 262

    (112) struct_fields_values -> field_value COMMA struct_fields_values .

    RBRACE          reduce using rule 112 (struct_fields_values -> field_value COMMA struct_fields_values .)


state 263

    (128) make_expr -> MAKE LPAREN MAP LBRACKET type . RBRACKET type RPAREN

    RBRACKET        shift and go to state 287


state 264

    (129) make_expr -> MAKE LPAREN LBRACKET RBRACKET type . RPAREN

    RPAREN          shift and go to state 288


state 265

    (100) for_update -> assignment .

    LBRACE          reduce using rule 100 (for_update -> assignment .)


state 266

    (95) for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update . for_block
    (96) for_block -> . begin_loop block end_loop
    (97) begin_loop -> .

    LBRACE          reduce using rule 97 (begin_loop -> .)

    for_block                      shift and go to state 289
    begin_loop                     shift and go to state 133

state 267

    (101) for_update -> increment_stmt .

    LBRACE          reduce using rule 101 (for_update -> increment_stmt .)


state 268

    (42) assignment -> VARIABLE . ASSIGN expression
    (43) assignment -> VARIABLE . ASIG expression
    (145) increment_stmt -> VARIABLE . INCREMENT
    (146) increment_stmt -> VARIABLE . DECREMENT

    ASSIGN          shift and go to state 49
    ASIG            shift and go to state 135
    INCREMENT       shift and go to state 52
    DECREMENT       shift and go to state 53


state 269

    (108) struct_field -> VARIABLE type .

    VARIABLE        reduce using rule 108 (struct_field -> VARIABLE type .)
    INT_TYPE        reduce using rule 108 (struct_field -> VARIABLE type .)
    FLOAT64_TYPE    reduce using rule 108 (struct_field -> VARIABLE type .)
    STRING_TYPE     reduce using rule 108 (struct_field -> VARIABLE type .)
    BOOL_TYPE       reduce using rule 108 (struct_field -> VARIABLE type .)
    RBRACE          reduce using rule 108 (struct_field -> VARIABLE type .)


state 270

    (105) struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .

    VAR             reduce using rule 105 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    VARIABLE        reduce using rule 105 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    FMT             reduce using rule 105 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    CONTINUE        reduce using rule 105 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    FUNC            reduce using rule 105 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    IF              reduce using rule 105 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    FOR             reduce using rule 105 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    TYPE            reduce using rule 105 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    SWITCH          reduce using rule 105 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    LBRACKET        reduce using rule 105 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    BREAK           reduce using rule 105 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    RETURN          reduce using rule 105 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    $end            reduce using rule 105 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    RBRACE          reduce using rule 105 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    CASE            reduce using rule 105 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    DEFAULT         reduce using rule 105 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)


state 271

    (107) struct_fields -> struct_field struct_fields .

    RBRACE          reduce using rule 107 (struct_fields -> struct_field struct_fields .)


state 272

    (118) case_clause -> CASE expression COLON program .

    CASE            reduce using rule 118 (case_clause -> CASE expression COLON program .)
    DEFAULT         reduce using rule 118 (case_clause -> CASE expression COLON program .)
    RBRACE          reduce using rule 118 (case_clause -> CASE expression COLON program .)


state 273

    (121) map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .
    (122) map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type . LBRACE map_params RBRACE
    (130) map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type . LBRACE map_kv_pairs RBRACE

    VAR             reduce using rule 121 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    VARIABLE        reduce using rule 121 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    FMT             reduce using rule 121 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    CONTINUE        reduce using rule 121 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    FUNC            reduce using rule 121 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    IF              reduce using rule 121 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    FOR             reduce using rule 121 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    TYPE            reduce using rule 121 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    SWITCH          reduce using rule 121 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    LBRACKET        reduce using rule 121 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    BREAK           reduce using rule 121 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    RETURN          reduce using rule 121 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    $end            reduce using rule 121 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    RBRACE          reduce using rule 121 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    CASE            reduce using rule 121 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    DEFAULT         reduce using rule 121 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    LBRACE          shift and go to state 290


state 274

    (140) slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values . RBRACE

    RBRACE          shift and go to state 291


state 275

    (141) slice_values -> expression .
    (142) slice_values -> expression . COMMA slice_values
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

    RBRACE          reduce using rule 141 (slice_values -> expression .)
    COMMA           shift and go to state 292
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126


state 276

    (126) make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type . RBRACKET type RPAREN
    (128) make_expr -> MAKE LPAREN MAP LBRACKET type . RBRACKET type RPAREN

    RBRACKET        shift and go to state 293


state 277

    (127) make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type . RPAREN
    (129) make_expr -> MAKE LPAREN LBRACKET RBRACKET type . RPAREN

    RPAREN          shift and go to state 294


state 278

    (120) map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .

    VAR             reduce using rule 120 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    VARIABLE        reduce using rule 120 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    FMT             reduce using rule 120 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    CONTINUE        reduce using rule 120 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    FUNC            reduce using rule 120 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    IF              reduce using rule 120 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    FOR             reduce using rule 120 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    TYPE            reduce using rule 120 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    SWITCH          reduce using rule 120 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    LBRACKET        reduce using rule 120 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    BREAK           reduce using rule 120 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    RETURN          reduce using rule 120 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    $end            reduce using rule 120 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    RBRACE          reduce using rule 120 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    CASE            reduce using rule 120 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    DEFAULT         reduce using rule 120 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)


state 279

    (44) print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression . RPAREN
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

    RPAREN          shift and go to state 295
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126


state 280

    (46) print_stmt -> FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE . RPAREN

    RPAREN          shift and go to state 296


state 281

    (47) input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .

    VAR             reduce using rule 47 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    VARIABLE        reduce using rule 47 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    FMT             reduce using rule 47 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    CONTINUE        reduce using rule 47 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    FUNC            reduce using rule 47 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    IF              reduce using rule 47 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    FOR             reduce using rule 47 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    TYPE            reduce using rule 47 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    SWITCH          reduce using rule 47 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    LBRACKET        reduce using rule 47 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    BREAK           reduce using rule 47 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    RETURN          reduce using rule 47 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    $end            reduce using rule 47 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    RBRACE          reduce using rule 47 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    CASE            reduce using rule 47 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    DEFAULT         reduce using rule 47 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)


state 282

    (103) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN . param_list RPAREN type LBRACE program RBRACE
    (104) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN . RPAREN type LBRACE program RBRACE
    (58) param_list -> . param
    (59) param_list -> . param COMMA param_list
    (60) param -> . VARIABLE type

    RPAREN          shift and go to state 297
    VARIABLE        shift and go to state 166

    param_list                     shift and go to state 298
    param                          shift and go to state 169

state 283

    (55) func_no_params_void -> FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE .

    VAR             reduce using rule 55 (func_no_params_void -> FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE .)
    VARIABLE        reduce using rule 55 (func_no_params_void -> FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE .)
    FMT             reduce using rule 55 (func_no_params_void -> FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE .)
    CONTINUE        reduce using rule 55 (func_no_params_void -> FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE .)
    FUNC            reduce using rule 55 (func_no_params_void -> FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE .)
    IF              reduce using rule 55 (func_no_params_void -> FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE .)
    FOR             reduce using rule 55 (func_no_params_void -> FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE .)
    TYPE            reduce using rule 55 (func_no_params_void -> FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE .)
    SWITCH          reduce using rule 55 (func_no_params_void -> FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE .)
    LBRACKET        reduce using rule 55 (func_no_params_void -> FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE .)
    BREAK           reduce using rule 55 (func_no_params_void -> FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE .)
    RETURN          reduce using rule 55 (func_no_params_void -> FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE .)
    $end            reduce using rule 55 (func_no_params_void -> FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE .)
    RBRACE          reduce using rule 55 (func_no_params_void -> FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE .)
    CASE            reduce using rule 55 (func_no_params_void -> FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE .)
    DEFAULT         reduce using rule 55 (func_no_params_void -> FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE .)


state 284

    (52) func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type . RBRACKET type func_body

    RBRACKET        shift and go to state 299


state 285

    (136) array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .

    VAR             reduce using rule 136 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    VARIABLE        reduce using rule 136 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    FMT             reduce using rule 136 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    CONTINUE        reduce using rule 136 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    FUNC            reduce using rule 136 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    IF              reduce using rule 136 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    FOR             reduce using rule 136 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    TYPE            reduce using rule 136 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    SWITCH          reduce using rule 136 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    LBRACKET        reduce using rule 136 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    BREAK           reduce using rule 136 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    RETURN          reduce using rule 136 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    $end            reduce using rule 136 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    RBRACE          reduce using rule 136 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    CASE            reduce using rule 136 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    DEFAULT         reduce using rule 136 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)


state 286

    (138) array_values -> expression COMMA . array_values
    (137) array_values -> . expression
    (138) array_values -> . expression COMMA array_values
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 260
    array_values                   shift and go to state 300
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 287

    (128) make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET . type RPAREN
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 301

state 288

    (129) make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .

    TIMES           reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    DIVIDE          reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    PLUS            reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    MINUS           reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    AND             reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    OR              reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    EQ              reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    NE              reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    LT              reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    GT              reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    LE              reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    GE              reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    LBRACE          reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    VAR             reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    VARIABLE        reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    FMT             reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    CONTINUE        reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    FUNC            reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    IF              reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    FOR             reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    TYPE            reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    SWITCH          reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    LBRACKET        reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    BREAK           reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    RETURN          reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    $end            reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    RBRACE          reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    CASE            reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    DEFAULT         reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    SEMICOLON       reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    COMMA           reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    RPAREN          reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    COLON           reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)


state 289

    (95) for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update for_block .

    VAR             reduce using rule 95 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update for_block .)
    VARIABLE        reduce using rule 95 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update for_block .)
    FMT             reduce using rule 95 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update for_block .)
    CONTINUE        reduce using rule 95 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update for_block .)
    FUNC            reduce using rule 95 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update for_block .)
    IF              reduce using rule 95 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update for_block .)
    FOR             reduce using rule 95 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update for_block .)
    TYPE            reduce using rule 95 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update for_block .)
    SWITCH          reduce using rule 95 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update for_block .)
    LBRACKET        reduce using rule 95 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update for_block .)
    BREAK           reduce using rule 95 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update for_block .)
    RETURN          reduce using rule 95 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update for_block .)
    $end            reduce using rule 95 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update for_block .)
    RBRACE          reduce using rule 95 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update for_block .)
    CASE            reduce using rule 95 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update for_block .)
    DEFAULT         reduce using rule 95 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update for_block .)


state 290

    (122) map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE . map_params RBRACE
    (130) map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE . map_kv_pairs RBRACE
    (123) map_params -> . map_param
    (124) map_params -> . map_param COMMA map_params
    (131) map_kv_pairs -> . map_kv_pair
    (132) map_kv_pairs -> . map_kv_pair COMMA map_kv_pairs
    (125) map_param -> . STRING COLON factor
    (133) map_kv_pair -> . STRING COLON expression

    STRING          shift and go to state 306

    map_params                     shift and go to state 302
    map_kv_pairs                   shift and go to state 303
    map_param                      shift and go to state 304
    map_kv_pair                    shift and go to state 305

state 291

    (140) slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .

    VAR             reduce using rule 140 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    VARIABLE        reduce using rule 140 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    FMT             reduce using rule 140 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    CONTINUE        reduce using rule 140 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    FUNC            reduce using rule 140 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    IF              reduce using rule 140 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    FOR             reduce using rule 140 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    TYPE            reduce using rule 140 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    SWITCH          reduce using rule 140 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    LBRACKET        reduce using rule 140 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    BREAK           reduce using rule 140 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    RETURN          reduce using rule 140 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    $end            reduce using rule 140 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    RBRACE          reduce using rule 140 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    CASE            reduce using rule 140 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    DEFAULT         reduce using rule 140 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)


state 292

    (142) slice_values -> expression COMMA . slice_values
    (141) slice_values -> . expression
    (142) slice_values -> . expression COMMA slice_values
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 275
    slice_values                   shift and go to state 307
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 293

    (126) make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET . type RPAREN
    (128) make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET . type RPAREN
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 308

state 294

    (127) make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .
    (129) make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .

  ! reduce/reduce conflict for VAR resolved using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for FMT resolved using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for FUNC resolved using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for IF resolved using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for FOR resolved using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for TYPE resolved using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for SWITCH resolved using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for BREAK resolved using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for RETURN resolved using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for $end resolved using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for RBRACE resolved using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for CASE resolved using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    VAR             reduce using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    VARIABLE        reduce using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    FMT             reduce using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    CONTINUE        reduce using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    FUNC            reduce using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    IF              reduce using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    FOR             reduce using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    TYPE            reduce using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    SWITCH          reduce using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    LBRACKET        reduce using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    BREAK           reduce using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    RETURN          reduce using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    $end            reduce using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    RBRACE          reduce using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    CASE            reduce using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    DEFAULT         reduce using rule 127 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    TIMES           reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    DIVIDE          reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    PLUS            reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    MINUS           reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    AND             reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    OR              reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    EQ              reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    NE              reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    LT              reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    GT              reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    LE              reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    GE              reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)

  ! VAR             [ reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! VARIABLE        [ reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! FMT             [ reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! CONTINUE        [ reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! FUNC            [ reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! IF              [ reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! FOR             [ reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! TYPE            [ reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! SWITCH          [ reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! LBRACKET        [ reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! BREAK           [ reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! RETURN          [ reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! $end            [ reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! RBRACE          [ reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! CASE            [ reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! DEFAULT         [ reduce using rule 129 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]


state 295

    (44) print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .

    VAR             reduce using rule 44 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    VARIABLE        reduce using rule 44 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    FMT             reduce using rule 44 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    CONTINUE        reduce using rule 44 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    FUNC            reduce using rule 44 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    IF              reduce using rule 44 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    FOR             reduce using rule 44 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    TYPE            reduce using rule 44 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    SWITCH          reduce using rule 44 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    LBRACKET        reduce using rule 44 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    BREAK           reduce using rule 44 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    RETURN          reduce using rule 44 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    $end            reduce using rule 44 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    RBRACE          reduce using rule 44 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    CASE            reduce using rule 44 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    DEFAULT         reduce using rule 44 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)


state 296

    (46) print_stmt -> FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN .

    VAR             reduce using rule 46 (print_stmt -> FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN .)
    VARIABLE        reduce using rule 46 (print_stmt -> FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN .)
    FMT             reduce using rule 46 (print_stmt -> FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN .)
    CONTINUE        reduce using rule 46 (print_stmt -> FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN .)
    FUNC            reduce using rule 46 (print_stmt -> FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN .)
    IF              reduce using rule 46 (print_stmt -> FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN .)
    FOR             reduce using rule 46 (print_stmt -> FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN .)
    TYPE            reduce using rule 46 (print_stmt -> FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN .)
    SWITCH          reduce using rule 46 (print_stmt -> FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN .)
    LBRACKET        reduce using rule 46 (print_stmt -> FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN .)
    BREAK           reduce using rule 46 (print_stmt -> FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN .)
    RETURN          reduce using rule 46 (print_stmt -> FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN .)
    $end            reduce using rule 46 (print_stmt -> FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN .)
    RBRACE          reduce using rule 46 (print_stmt -> FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN .)
    CASE            reduce using rule 46 (print_stmt -> FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN .)
    DEFAULT         reduce using rule 46 (print_stmt -> FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN .)


state 297

    (104) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN . type LBRACE program RBRACE
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 309

state 298

    (103) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list . RPAREN type LBRACE program RBRACE

    RPAREN          shift and go to state 310


state 299

    (52) func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET . type func_body
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 311

state 300

    (138) array_values -> expression COMMA array_values .

    RBRACE          reduce using rule 138 (array_values -> expression COMMA array_values .)


state 301

    (128) make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type . RPAREN

    RPAREN          shift and go to state 312


state 302

    (122) map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params . RBRACE

    RBRACE          shift and go to state 313


state 303

    (130) map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs . RBRACE

    RBRACE          shift and go to state 314


state 304

    (123) map_params -> map_param .
    (124) map_params -> map_param . COMMA map_params

    RBRACE          reduce using rule 123 (map_params -> map_param .)
    COMMA           shift and go to state 315


state 305

    (131) map_kv_pairs -> map_kv_pair .
    (132) map_kv_pairs -> map_kv_pair . COMMA map_kv_pairs

    RBRACE          reduce using rule 131 (map_kv_pairs -> map_kv_pair .)
    COMMA           shift and go to state 316


state 306

    (125) map_param -> STRING . COLON factor
    (133) map_kv_pair -> STRING . COLON expression

    COLON           shift and go to state 317


state 307

    (142) slice_values -> expression COMMA slice_values .

    RBRACE          reduce using rule 142 (slice_values -> expression COMMA slice_values .)


state 308

    (126) make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type . RPAREN
    (128) make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type . RPAREN

    RPAREN          shift and go to state 318


state 309

    (104) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type . LBRACE program RBRACE

    LBRACE          shift and go to state 319


state 310

    (103) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN . type LBRACE program RBRACE
    (88) type -> . INT_TYPE
    (89) type -> . FLOAT64_TYPE
    (90) type -> . STRING_TYPE
    (91) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 101
    FLOAT64_TYPE    shift and go to state 102
    STRING_TYPE     shift and go to state 103
    BOOL_TYPE       shift and go to state 104

    type                           shift and go to state 320

state 311

    (52) func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type . func_body
    (50) func_body -> . LBRACE program RBRACE

    LBRACE          shift and go to state 61

    func_body                      shift and go to state 321

state 312

    (128) make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .

    TIMES           reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    DIVIDE          reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    PLUS            reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    MINUS           reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    AND             reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    OR              reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    EQ              reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    NE              reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LT              reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    GT              reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LE              reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    GE              reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LBRACE          reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VAR             reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VARIABLE        reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FMT             reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CONTINUE        reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FUNC            reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    IF              reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FOR             reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    TYPE            reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    SWITCH          reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LBRACKET        reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    BREAK           reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RETURN          reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    $end            reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RBRACE          reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CASE            reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    DEFAULT         reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    SEMICOLON       reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    COMMA           reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RPAREN          reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    COLON           reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)


state 313

    (122) map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE .

    VAR             reduce using rule 122 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE .)
    VARIABLE        reduce using rule 122 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE .)
    FMT             reduce using rule 122 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE .)
    CONTINUE        reduce using rule 122 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE .)
    FUNC            reduce using rule 122 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE .)
    IF              reduce using rule 122 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE .)
    FOR             reduce using rule 122 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE .)
    TYPE            reduce using rule 122 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE .)
    SWITCH          reduce using rule 122 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE .)
    LBRACKET        reduce using rule 122 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE .)
    BREAK           reduce using rule 122 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE .)
    RETURN          reduce using rule 122 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE .)
    $end            reduce using rule 122 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE .)
    RBRACE          reduce using rule 122 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE .)
    CASE            reduce using rule 122 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE .)
    DEFAULT         reduce using rule 122 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE .)


state 314

    (130) map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .

    VAR             reduce using rule 130 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    VARIABLE        reduce using rule 130 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    FMT             reduce using rule 130 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    CONTINUE        reduce using rule 130 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    FUNC            reduce using rule 130 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    IF              reduce using rule 130 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    FOR             reduce using rule 130 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    TYPE            reduce using rule 130 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    SWITCH          reduce using rule 130 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    LBRACKET        reduce using rule 130 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    BREAK           reduce using rule 130 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    RETURN          reduce using rule 130 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    $end            reduce using rule 130 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    RBRACE          reduce using rule 130 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    CASE            reduce using rule 130 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    DEFAULT         reduce using rule 130 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)


state 315

    (124) map_params -> map_param COMMA . map_params
    (123) map_params -> . map_param
    (124) map_params -> . map_param COMMA map_params
    (125) map_param -> . STRING COLON factor

    STRING          shift and go to state 323

    map_param                      shift and go to state 304
    map_params                     shift and go to state 322

state 316

    (132) map_kv_pairs -> map_kv_pair COMMA . map_kv_pairs
    (131) map_kv_pairs -> . map_kv_pair
    (132) map_kv_pairs -> . map_kv_pair COMMA map_kv_pairs
    (133) map_kv_pair -> . STRING COLON expression

    STRING          shift and go to state 325

    map_kv_pair                    shift and go to state 305
    map_kv_pairs                   shift and go to state 324

state 317

    (125) map_param -> STRING COLON . factor
    (133) map_kv_pair -> STRING COLON . expression
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE

    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    VARIABLE        shift and go to state 328
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    factor                         shift and go to state 326
    expression                     shift and go to state 327
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77
    term                           shift and go to state 66

state 318

    (126) make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .
    (128) make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .

  ! reduce/reduce conflict for VAR resolved using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for FMT resolved using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for FUNC resolved using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for IF resolved using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for FOR resolved using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for TYPE resolved using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for SWITCH resolved using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for BREAK resolved using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for RETURN resolved using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for $end resolved using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for RBRACE resolved using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for CASE resolved using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VAR             reduce using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VARIABLE        reduce using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FMT             reduce using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CONTINUE        reduce using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FUNC            reduce using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    IF              reduce using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FOR             reduce using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    TYPE            reduce using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    SWITCH          reduce using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LBRACKET        reduce using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    BREAK           reduce using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RETURN          reduce using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    $end            reduce using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RBRACE          reduce using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CASE            reduce using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    DEFAULT         reduce using rule 126 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    TIMES           reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    DIVIDE          reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    PLUS            reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    MINUS           reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    AND             reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    OR              reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    EQ              reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    NE              reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LT              reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    GT              reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LE              reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    GE              reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)

  ! VAR             [ reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! VARIABLE        [ reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! FMT             [ reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! CONTINUE        [ reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! FUNC            [ reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! IF              [ reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! FOR             [ reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! TYPE            [ reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! SWITCH          [ reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! LBRACKET        [ reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! BREAK           [ reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! RETURN          [ reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! $end            [ reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! RBRACE          [ reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! CASE            [ reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! DEFAULT         [ reduce using rule 128 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]


state 319

    (104) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE . program RBRACE
    (4) program -> . statement
    (5) program -> . statement program
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . print_stmt
    (9) statement -> . input_stmt
    (10) statement -> . continue_stmt
    (11) statement -> . struct_method
    (12) statement -> . func_def
    (13) statement -> . func_no_params
    (14) statement -> . func_no_params_void
    (15) statement -> . func_with_map
    (16) statement -> . func_call
    (17) statement -> . if_stmt
    (18) statement -> . for_stmt
    (19) statement -> . struct_def
    (20) statement -> . switch_stmt
    (21) statement -> . map_declaration
    (22) statement -> . map_declaration_values
    (23) statement -> . array_declaration
    (24) statement -> . array_literal
    (25) statement -> . slice_declaration
    (26) statement -> . make_stmt
    (27) statement -> . new_stmt
    (28) statement -> . break_stmt
    (29) statement -> . increment_stmt
    (30) statement -> . return_stmt
    (31) declaration -> . VAR VARIABLE type
    (32) declaration -> . VAR VARIABLE type ASIG expression
    (33) declaration -> . VAR VARIABLE type ASSIGN expression
    (34) declaration -> . VAR id_list type ASSIGN expr_list
    (35) declaration -> . VAR id_list type ASIG expr_list
    (36) declaration -> . VAR id_list ASSIGN expr_list
    (37) declaration -> . VAR id_list ASIG expr_list
    (42) assignment -> . VARIABLE ASSIGN expression
    (43) assignment -> . VARIABLE ASIG expression
    (44) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (45) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (46) print_stmt -> . FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN
    (47) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (99) continue_stmt -> . CONTINUE
    (103) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (104) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (48) func_def -> . func_header func_body
    (53) func_no_params -> . func_header_no_params block
    (55) func_no_params_void -> . FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE
    (52) func_with_map -> . FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN
    (92) if_stmt -> . IF expression block
    (93) if_stmt -> . IF expression block ELSE block
    (94) for_stmt -> . FOR expression for_block
    (95) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update for_block
    (105) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (114) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (115) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (120) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (121) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (122) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE
    (130) map_declaration_values -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
    (134) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (135) array_declaration -> . VAR VARIABLE ASSIGN array_literal
    (136) array_literal -> . LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (139) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (140) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (126) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (127) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (143) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (144) break_stmt -> . BREAK
    (145) increment_stmt -> . VARIABLE INCREMENT
    (146) increment_stmt -> . VARIABLE DECREMENT
    (51) return_stmt -> . RETURN expression
    (49) func_header -> . FUNC VARIABLE LPAREN param_list RPAREN type
    (54) func_header_no_params -> . FUNC VARIABLE LPAREN RPAREN type

    VAR             shift and go to state 34
    VARIABLE        shift and go to state 6
    FMT             shift and go to state 35
    CONTINUE        shift and go to state 36
    FUNC            shift and go to state 37
    IF              shift and go to state 41
    FOR             shift and go to state 42
    TYPE            shift and go to state 43
    SWITCH          shift and go to state 44
    LBRACKET        shift and go to state 40
    BREAK           shift and go to state 45
    RETURN          shift and go to state 46

    program                        shift and go to state 329
    statement                      shift and go to state 8
    declaration                    shift and go to state 9
    assignment                     shift and go to state 10
    print_stmt                     shift and go to state 11
    input_stmt                     shift and go to state 12
    continue_stmt                  shift and go to state 13
    struct_method                  shift and go to state 14
    func_def                       shift and go to state 15
    func_no_params                 shift and go to state 16
    func_no_params_void            shift and go to state 17
    func_with_map                  shift and go to state 18
    func_call                      shift and go to state 19
    if_stmt                        shift and go to state 20
    for_stmt                       shift and go to state 21
    struct_def                     shift and go to state 22
    switch_stmt                    shift and go to state 23
    map_declaration                shift and go to state 24
    map_declaration_values         shift and go to state 25
    array_declaration              shift and go to state 26
    array_literal                  shift and go to state 27
    slice_declaration              shift and go to state 28
    make_stmt                      shift and go to state 29
    new_stmt                       shift and go to state 30
    break_stmt                     shift and go to state 31
    increment_stmt                 shift and go to state 32
    return_stmt                    shift and go to state 33
    func_header                    shift and go to state 38
    func_header_no_params          shift and go to state 39

state 320

    (103) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type . LBRACE program RBRACE

    LBRACE          shift and go to state 330


state 321

    (52) func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body .

    VAR             reduce using rule 52 (func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body .)
    VARIABLE        reduce using rule 52 (func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body .)
    FMT             reduce using rule 52 (func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body .)
    CONTINUE        reduce using rule 52 (func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body .)
    FUNC            reduce using rule 52 (func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body .)
    IF              reduce using rule 52 (func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body .)
    FOR             reduce using rule 52 (func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body .)
    TYPE            reduce using rule 52 (func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body .)
    SWITCH          reduce using rule 52 (func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body .)
    LBRACKET        reduce using rule 52 (func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body .)
    BREAK           reduce using rule 52 (func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body .)
    RETURN          reduce using rule 52 (func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body .)
    $end            reduce using rule 52 (func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body .)
    RBRACE          reduce using rule 52 (func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body .)
    CASE            reduce using rule 52 (func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body .)
    DEFAULT         reduce using rule 52 (func_with_map -> FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body .)


state 322

    (124) map_params -> map_param COMMA map_params .

    RBRACE          reduce using rule 124 (map_params -> map_param COMMA map_params .)


state 323

    (125) map_param -> STRING . COLON factor

    COLON           shift and go to state 331


state 324

    (132) map_kv_pairs -> map_kv_pair COMMA map_kv_pairs .

    RBRACE          reduce using rule 132 (map_kv_pairs -> map_kv_pair COMMA map_kv_pairs .)


state 325

    (133) map_kv_pair -> STRING . COLON expression

    COLON           shift and go to state 332


state 326

    (125) map_param -> STRING COLON factor .
    (74) term -> factor .

  ! reduce/reduce conflict for COMMA resolved using rule 74 (term -> factor .)
  ! reduce/reduce conflict for RBRACE resolved using rule 74 (term -> factor .)
    TIMES           reduce using rule 74 (term -> factor .)
    DIVIDE          reduce using rule 74 (term -> factor .)
    PLUS            reduce using rule 74 (term -> factor .)
    MINUS           reduce using rule 74 (term -> factor .)
    AND             reduce using rule 74 (term -> factor .)
    OR              reduce using rule 74 (term -> factor .)
    EQ              reduce using rule 74 (term -> factor .)
    NE              reduce using rule 74 (term -> factor .)
    LT              reduce using rule 74 (term -> factor .)
    GT              reduce using rule 74 (term -> factor .)
    LE              reduce using rule 74 (term -> factor .)
    GE              reduce using rule 74 (term -> factor .)
    COMMA           reduce using rule 74 (term -> factor .)
    RBRACE          reduce using rule 74 (term -> factor .)

  ! COMMA           [ reduce using rule 125 (map_param -> STRING COLON factor .) ]
  ! RBRACE          [ reduce using rule 125 (map_param -> STRING COLON factor .) ]


state 327

    (133) map_kv_pair -> STRING COLON expression .
    (64) expression -> expression . PLUS term
    (65) expression -> expression . MINUS term
    (66) expression -> expression . AND expression
    (67) expression -> expression . OR expression
    (68) expression -> expression . EQ expression
    (69) expression -> expression . NE expression
    (70) expression -> expression . LT expression
    (71) expression -> expression . GT expression
    (72) expression -> expression . LE expression
    (73) expression -> expression . GE expression

    COMMA           reduce using rule 133 (map_kv_pair -> STRING COLON expression .)
    RBRACE          reduce using rule 133 (map_kv_pair -> STRING COLON expression .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    AND             shift and go to state 119
    OR              shift and go to state 120
    EQ              shift and go to state 121
    NE              shift and go to state 122
    LT              shift and go to state 123
    GT              shift and go to state 124
    LE              shift and go to state 125
    GE              shift and go to state 126


state 328

    (81) factor -> VARIABLE .
    (110) struct_instance -> VARIABLE . LBRACE struct_fields_values RBRACE
    (56) func_call -> VARIABLE . LPAREN arg_list RPAREN
    (57) func_call -> VARIABLE . LPAREN RPAREN
    (77) term -> VARIABLE .

  ! reduce/reduce conflict for TIMES resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for PLUS resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for MINUS resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for AND resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for OR resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for EQ resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for NE resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for LT resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for GT resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for LE resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for GE resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for COMMA resolved using rule 77 (term -> VARIABLE .)
  ! reduce/reduce conflict for RBRACE resolved using rule 77 (term -> VARIABLE .)
    LBRACE          shift and go to state 129
    LPAREN          shift and go to state 51
    TIMES           reduce using rule 77 (term -> VARIABLE .)
    DIVIDE          reduce using rule 77 (term -> VARIABLE .)
    PLUS            reduce using rule 77 (term -> VARIABLE .)
    MINUS           reduce using rule 77 (term -> VARIABLE .)
    AND             reduce using rule 77 (term -> VARIABLE .)
    OR              reduce using rule 77 (term -> VARIABLE .)
    EQ              reduce using rule 77 (term -> VARIABLE .)
    NE              reduce using rule 77 (term -> VARIABLE .)
    LT              reduce using rule 77 (term -> VARIABLE .)
    GT              reduce using rule 77 (term -> VARIABLE .)
    LE              reduce using rule 77 (term -> VARIABLE .)
    GE              reduce using rule 77 (term -> VARIABLE .)
    COMMA           reduce using rule 77 (term -> VARIABLE .)
    RBRACE          reduce using rule 77 (term -> VARIABLE .)

  ! COMMA           [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! RBRACE          [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! TIMES           [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! DIVIDE          [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! PLUS            [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! MINUS           [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! AND             [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! OR              [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! EQ              [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! NE              [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! LT              [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! GT              [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! LE              [ reduce using rule 81 (factor -> VARIABLE .) ]
  ! GE              [ reduce using rule 81 (factor -> VARIABLE .) ]


state 329

    (104) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program . RBRACE

    RBRACE          shift and go to state 333


state 330

    (103) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE . program RBRACE
    (4) program -> . statement
    (5) program -> . statement program
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . print_stmt
    (9) statement -> . input_stmt
    (10) statement -> . continue_stmt
    (11) statement -> . struct_method
    (12) statement -> . func_def
    (13) statement -> . func_no_params
    (14) statement -> . func_no_params_void
    (15) statement -> . func_with_map
    (16) statement -> . func_call
    (17) statement -> . if_stmt
    (18) statement -> . for_stmt
    (19) statement -> . struct_def
    (20) statement -> . switch_stmt
    (21) statement -> . map_declaration
    (22) statement -> . map_declaration_values
    (23) statement -> . array_declaration
    (24) statement -> . array_literal
    (25) statement -> . slice_declaration
    (26) statement -> . make_stmt
    (27) statement -> . new_stmt
    (28) statement -> . break_stmt
    (29) statement -> . increment_stmt
    (30) statement -> . return_stmt
    (31) declaration -> . VAR VARIABLE type
    (32) declaration -> . VAR VARIABLE type ASIG expression
    (33) declaration -> . VAR VARIABLE type ASSIGN expression
    (34) declaration -> . VAR id_list type ASSIGN expr_list
    (35) declaration -> . VAR id_list type ASIG expr_list
    (36) declaration -> . VAR id_list ASSIGN expr_list
    (37) declaration -> . VAR id_list ASIG expr_list
    (42) assignment -> . VARIABLE ASSIGN expression
    (43) assignment -> . VARIABLE ASIG expression
    (44) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (45) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (46) print_stmt -> . FMT DOT PRINTLN LPAREN STRING COMMA VARIABLE RPAREN
    (47) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (99) continue_stmt -> . CONTINUE
    (103) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (104) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (48) func_def -> . func_header func_body
    (53) func_no_params -> . func_header_no_params block
    (55) func_no_params_void -> . FUNC VARIABLE LPAREN RPAREN LBRACE program RBRACE
    (52) func_with_map -> . FUNC VARIABLE LPAREN RPAREN MAP LBRACKET type RBRACKET type func_body
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN
    (92) if_stmt -> . IF expression block
    (93) if_stmt -> . IF expression block ELSE block
    (94) for_stmt -> . FOR expression for_block
    (95) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update for_block
    (105) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (114) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (115) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (120) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (121) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (122) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_params RBRACE
    (130) map_declaration_values -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
    (134) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (135) array_declaration -> . VAR VARIABLE ASSIGN array_literal
    (136) array_literal -> . LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (139) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (140) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (126) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (127) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (143) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (144) break_stmt -> . BREAK
    (145) increment_stmt -> . VARIABLE INCREMENT
    (146) increment_stmt -> . VARIABLE DECREMENT
    (51) return_stmt -> . RETURN expression
    (49) func_header -> . FUNC VARIABLE LPAREN param_list RPAREN type
    (54) func_header_no_params -> . FUNC VARIABLE LPAREN RPAREN type

    VAR             shift and go to state 34
    VARIABLE        shift and go to state 6
    FMT             shift and go to state 35
    CONTINUE        shift and go to state 36
    FUNC            shift and go to state 37
    IF              shift and go to state 41
    FOR             shift and go to state 42
    TYPE            shift and go to state 43
    SWITCH          shift and go to state 44
    LBRACKET        shift and go to state 40
    BREAK           shift and go to state 45
    RETURN          shift and go to state 46

    program                        shift and go to state 334
    statement                      shift and go to state 8
    declaration                    shift and go to state 9
    assignment                     shift and go to state 10
    print_stmt                     shift and go to state 11
    input_stmt                     shift and go to state 12
    continue_stmt                  shift and go to state 13
    struct_method                  shift and go to state 14
    func_def                       shift and go to state 15
    func_no_params                 shift and go to state 16
    func_no_params_void            shift and go to state 17
    func_with_map                  shift and go to state 18
    func_call                      shift and go to state 19
    if_stmt                        shift and go to state 20
    for_stmt                       shift and go to state 21
    struct_def                     shift and go to state 22
    switch_stmt                    shift and go to state 23
    map_declaration                shift and go to state 24
    map_declaration_values         shift and go to state 25
    array_declaration              shift and go to state 26
    array_literal                  shift and go to state 27
    slice_declaration              shift and go to state 28
    make_stmt                      shift and go to state 29
    new_stmt                       shift and go to state 30
    break_stmt                     shift and go to state 31
    increment_stmt                 shift and go to state 32
    return_stmt                    shift and go to state 33
    func_header                    shift and go to state 38
    func_header_no_params          shift and go to state 39

state 331

    (125) map_param -> STRING COLON . factor
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    VARIABLE        shift and go to state 185
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    factor                         shift and go to state 335
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 332

    (133) map_kv_pair -> STRING COLON . expression
    (63) expression -> . term
    (64) expression -> . expression PLUS term
    (65) expression -> . expression MINUS term
    (66) expression -> . expression AND expression
    (67) expression -> . expression OR expression
    (68) expression -> . expression EQ expression
    (69) expression -> . expression NE expression
    (70) expression -> . expression LT expression
    (71) expression -> . expression GT expression
    (72) expression -> . expression LE expression
    (73) expression -> . expression GE expression
    (74) term -> . factor
    (75) term -> . term TIMES factor
    (76) term -> . term DIVIDE factor
    (77) term -> . VARIABLE
    (78) factor -> . NUMBER
    (79) factor -> . FLOAT
    (80) factor -> . STRING
    (81) factor -> . VARIABLE
    (82) factor -> . TRUE
    (83) factor -> . FALSE
    (84) factor -> . LPAREN expression RPAREN
    (85) factor -> . make_expr
    (86) factor -> . struct_instance
    (87) factor -> . func_call
    (128) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (129) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (110) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE
    (56) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (57) func_call -> . VARIABLE LPAREN RPAREN

    VARIABLE        shift and go to state 68
    NUMBER          shift and go to state 69
    FLOAT           shift and go to state 70
    STRING          shift and go to state 71
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    LPAREN          shift and go to state 74
    MAKE            shift and go to state 78

    expression                     shift and go to state 327
    term                           shift and go to state 66
    factor                         shift and go to state 67
    make_expr                      shift and go to state 75
    struct_instance                shift and go to state 76
    func_call                      shift and go to state 77

state 333

    (104) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .

    VAR             reduce using rule 104 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    VARIABLE        reduce using rule 104 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    FMT             reduce using rule 104 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    CONTINUE        reduce using rule 104 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    FUNC            reduce using rule 104 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    IF              reduce using rule 104 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    FOR             reduce using rule 104 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    TYPE            reduce using rule 104 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    SWITCH          reduce using rule 104 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    LBRACKET        reduce using rule 104 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    BREAK           reduce using rule 104 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    RETURN          reduce using rule 104 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    $end            reduce using rule 104 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    RBRACE          reduce using rule 104 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    CASE            reduce using rule 104 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    DEFAULT         reduce using rule 104 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)


state 334

    (103) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program . RBRACE

    RBRACE          shift and go to state 336


state 335

    (125) map_param -> STRING COLON factor .

    COMMA           reduce using rule 125 (map_param -> STRING COLON factor .)
    RBRACE          reduce using rule 125 (map_param -> STRING COLON factor .)


state 336

    (103) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .

    VAR             reduce using rule 103 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    VARIABLE        reduce using rule 103 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    FMT             reduce using rule 103 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    CONTINUE        reduce using rule 103 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    FUNC            reduce using rule 103 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    IF              reduce using rule 103 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    FOR             reduce using rule 103 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    TYPE            reduce using rule 103 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    SWITCH          reduce using rule 103 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    LBRACKET        reduce using rule 103 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    BREAK           reduce using rule 103 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    RETURN          reduce using rule 103 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    $end            reduce using rule 103 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    RBRACE          reduce using rule 103 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    CASE            reduce using rule 103 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    DEFAULT         reduce using rule 103 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ASSIGN in state 55 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 55 resolved as shift
WARNING: shift/reduce conflict for FLOAT64_TYPE in state 55 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 55 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 55 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 68 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 81 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 176 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 176 resolved as shift
WARNING: shift/reduce conflict for AND in state 176 resolved as shift
WARNING: shift/reduce conflict for OR in state 176 resolved as shift
WARNING: shift/reduce conflict for EQ in state 176 resolved as shift
WARNING: shift/reduce conflict for NE in state 176 resolved as shift
WARNING: shift/reduce conflict for LT in state 176 resolved as shift
WARNING: shift/reduce conflict for GT in state 176 resolved as shift
WARNING: shift/reduce conflict for LE in state 176 resolved as shift
WARNING: shift/reduce conflict for GE in state 176 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 177 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 177 resolved as shift
WARNING: shift/reduce conflict for AND in state 177 resolved as shift
WARNING: shift/reduce conflict for OR in state 177 resolved as shift
WARNING: shift/reduce conflict for EQ in state 177 resolved as shift
WARNING: shift/reduce conflict for NE in state 177 resolved as shift
WARNING: shift/reduce conflict for LT in state 177 resolved as shift
WARNING: shift/reduce conflict for GT in state 177 resolved as shift
WARNING: shift/reduce conflict for LE in state 177 resolved as shift
WARNING: shift/reduce conflict for GE in state 177 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 178 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 178 resolved as shift
WARNING: shift/reduce conflict for AND in state 178 resolved as shift
WARNING: shift/reduce conflict for OR in state 178 resolved as shift
WARNING: shift/reduce conflict for EQ in state 178 resolved as shift
WARNING: shift/reduce conflict for NE in state 178 resolved as shift
WARNING: shift/reduce conflict for LT in state 178 resolved as shift
WARNING: shift/reduce conflict for GT in state 178 resolved as shift
WARNING: shift/reduce conflict for LE in state 178 resolved as shift
WARNING: shift/reduce conflict for GE in state 178 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 179 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 179 resolved as shift
WARNING: shift/reduce conflict for AND in state 179 resolved as shift
WARNING: shift/reduce conflict for OR in state 179 resolved as shift
WARNING: shift/reduce conflict for EQ in state 179 resolved as shift
WARNING: shift/reduce conflict for NE in state 179 resolved as shift
WARNING: shift/reduce conflict for LT in state 179 resolved as shift
WARNING: shift/reduce conflict for GT in state 179 resolved as shift
WARNING: shift/reduce conflict for LE in state 179 resolved as shift
WARNING: shift/reduce conflict for GE in state 179 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 180 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 180 resolved as shift
WARNING: shift/reduce conflict for AND in state 180 resolved as shift
WARNING: shift/reduce conflict for OR in state 180 resolved as shift
WARNING: shift/reduce conflict for EQ in state 180 resolved as shift
WARNING: shift/reduce conflict for NE in state 180 resolved as shift
WARNING: shift/reduce conflict for LT in state 180 resolved as shift
WARNING: shift/reduce conflict for GT in state 180 resolved as shift
WARNING: shift/reduce conflict for LE in state 180 resolved as shift
WARNING: shift/reduce conflict for GE in state 180 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 181 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 181 resolved as shift
WARNING: shift/reduce conflict for AND in state 181 resolved as shift
WARNING: shift/reduce conflict for OR in state 181 resolved as shift
WARNING: shift/reduce conflict for EQ in state 181 resolved as shift
WARNING: shift/reduce conflict for NE in state 181 resolved as shift
WARNING: shift/reduce conflict for LT in state 181 resolved as shift
WARNING: shift/reduce conflict for GT in state 181 resolved as shift
WARNING: shift/reduce conflict for LE in state 181 resolved as shift
WARNING: shift/reduce conflict for GE in state 181 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 182 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 182 resolved as shift
WARNING: shift/reduce conflict for AND in state 182 resolved as shift
WARNING: shift/reduce conflict for OR in state 182 resolved as shift
WARNING: shift/reduce conflict for EQ in state 182 resolved as shift
WARNING: shift/reduce conflict for NE in state 182 resolved as shift
WARNING: shift/reduce conflict for LT in state 182 resolved as shift
WARNING: shift/reduce conflict for GT in state 182 resolved as shift
WARNING: shift/reduce conflict for LE in state 182 resolved as shift
WARNING: shift/reduce conflict for GE in state 182 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 183 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 183 resolved as shift
WARNING: shift/reduce conflict for AND in state 183 resolved as shift
WARNING: shift/reduce conflict for OR in state 183 resolved as shift
WARNING: shift/reduce conflict for EQ in state 183 resolved as shift
WARNING: shift/reduce conflict for NE in state 183 resolved as shift
WARNING: shift/reduce conflict for LT in state 183 resolved as shift
WARNING: shift/reduce conflict for GT in state 183 resolved as shift
WARNING: shift/reduce conflict for LE in state 183 resolved as shift
WARNING: shift/reduce conflict for GE in state 183 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 185 resolved as shift
WARNING: reduce/reduce conflict in state 68 resolved using rule (term -> VARIABLE)
WARNING: rejected rule (factor -> VARIABLE) in state 68
WARNING: reduce/reduce conflict in state 81 resolved using rule (term -> VARIABLE)
WARNING: rejected rule (factor -> VARIABLE) in state 81
WARNING: reduce/reduce conflict in state 294 resolved using rule (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN)
WARNING: rejected rule (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN) in state 294
WARNING: reduce/reduce conflict in state 318 resolved using rule (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN)
WARNING: rejected rule (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN) in state 318
WARNING: reduce/reduce conflict in state 326 resolved using rule (term -> factor)
WARNING: rejected rule (map_param -> STRING COLON factor) in state 326
WARNING: reduce/reduce conflict in state 328 resolved using rule (term -> VARIABLE)
WARNING: rejected rule (factor -> VARIABLE) in state 328
