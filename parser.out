Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    FALSE
    FUNCNAME
    IMPORT
    MOD
    PACKAGE
    PRINT
    RANGE
    RETURN
    TRUE
    UINT

Grammar

Rule 0     S' -> program
Rule 1     program -> statement
Rule 2     program -> statement program
Rule 3     statement -> declaration
Rule 4     statement -> assignment
Rule 5     statement -> print_stmt
Rule 6     statement -> input_stmt
Rule 7     statement -> struct_method
Rule 8     statement -> func_def
Rule 9     statement -> func_no_params
Rule 10    statement -> func_call
Rule 11    statement -> if_stmt
Rule 12    statement -> for_stmt
Rule 13    statement -> struct_def
Rule 14    statement -> switch_stmt
Rule 15    statement -> map_declaration
Rule 16    statement -> array_declaration
Rule 17    statement -> slice_declaration
Rule 18    statement -> make_stmt
Rule 19    statement -> new_stmt
Rule 20    statement -> break_stmt
Rule 21    statement -> increment_stmt
Rule 22    declaration -> VAR VARIABLE type
Rule 23    declaration -> VAR VARIABLE type ASIG expression
Rule 24    expression -> NUMBER
Rule 25    expression -> FLOAT
Rule 26    expression -> VARIABLE
Rule 27    assignment -> VARIABLE ASSIGN expression
Rule 28    assignment -> VARIABLE ASIG expression
Rule 29    print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
Rule 30    print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN
Rule 31    input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
Rule 32    func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
Rule 33    func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE
Rule 34    func_no_params -> FUNC VARIABLE LPAREN RPAREN block
Rule 35    func_call -> VARIABLE LPAREN arg_list RPAREN
Rule 36    func_call -> VARIABLE LPAREN RPAREN
Rule 37    param_list -> param
Rule 38    param_list -> param COMMA param_list
Rule 39    param -> VARIABLE type
Rule 40    arg_list -> expression
Rule 41    arg_list -> expression COMMA arg_list
Rule 42    expression -> term
Rule 43    expression -> expression PLUS term
Rule 44    expression -> expression MINUS term
Rule 45    expression -> expression AND expression
Rule 46    expression -> expression OR expression
Rule 47    expression -> expression EQ expression
Rule 48    expression -> expression NE expression
Rule 49    expression -> expression LT expression
Rule 50    expression -> expression GT expression
Rule 51    expression -> expression LE expression
Rule 52    expression -> expression GE expression
Rule 53    term -> factor
Rule 54    term -> term TIMES factor
Rule 55    term -> term DIVIDE factor
Rule 56    factor -> NUMBER
Rule 57    factor -> FLOAT
Rule 58    factor -> STRING
Rule 59    factor -> VARIABLE
Rule 60    factor -> LPAREN expression RPAREN
Rule 61    factor -> make_expr
Rule 62    factor -> struct_instance
Rule 63    type -> INT_TYPE
Rule 64    type -> FLOAT64_TYPE
Rule 65    type -> STRING_TYPE
Rule 66    type -> BOOL_TYPE
Rule 67    if_stmt -> IF expression block
Rule 68    if_stmt -> IF expression block ELSE block
Rule 69    for_stmt -> FOR expression block
Rule 70    for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block
Rule 71    for_update -> assignment
Rule 72    for_update -> increment_stmt
Rule 73    block -> LBRACE program RBRACE
Rule 74    struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
Rule 75    struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
Rule 76    struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
Rule 77    struct_fields -> struct_field
Rule 78    struct_fields -> struct_field struct_fields
Rule 79    struct_field -> VARIABLE type
Rule 80    struct_field -> type
Rule 81    struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE
Rule 82    struct_fields_values -> field_value
Rule 83    struct_fields_values -> field_value COMMA struct_fields_values
Rule 84    field_value -> VARIABLE COLON expression
Rule 85    switch_stmt -> SWITCH expression LBRACE case_list RBRACE
Rule 86    switch_stmt -> SWITCH LBRACE case_list RBRACE
Rule 87    case_list -> case_clause
Rule 88    case_list -> case_clause case_list
Rule 89    case_clause -> CASE expression COLON program
Rule 90    case_clause -> DEFAULT COLON program
Rule 91    map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type
Rule 92    map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type
Rule 93    make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
Rule 94    make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
Rule 95    make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
Rule 96    make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN
Rule 97    array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type
Rule 98    array_declaration -> VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
Rule 99    array_values -> expression
Rule 100   array_values -> expression COMMA array_values
Rule 101   slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type
Rule 102   slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
Rule 103   slice_values -> expression
Rule 104   slice_values -> expression COMMA slice_values
Rule 105   new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
Rule 106   break_stmt -> BREAK
Rule 107   increment_stmt -> VARIABLE INCREMENT
Rule 108   increment_stmt -> VARIABLE DECREMENT

Terminals, with rules where they appear

AMPER                : 31
AND                  : 45
ASIG                 : 23 28 92 93 94 98 102 105
ASSIGN               : 27
BOOL_TYPE            : 66
BREAK                : 106
CASE                 : 89
COLON                : 84 89 90
COMMA                : 29 38 41 83 100 104
DECREMENT            : 108
DEFAULT              : 90
DIVIDE               : 55
DOT                  : 29 30 31
ELSE                 : 68
EQ                   : 47
FALSE                : 
FLOAT                : 25 57
FLOAT64_TYPE         : 64
FMT                  : 29 30 31
FOR                  : 69 70
FUNC                 : 32 33 34 74 75
FUNCNAME             : 
GE                   : 52
GT                   : 50
IF                   : 67 68
IMPORT               : 
INCREMENT            : 107
INT_TYPE             : 63
LBRACE               : 32 33 73 74 75 76 81 85 86 98 102
LBRACKET             : 91 92 93 94 95 96 97 98 101 102
LE                   : 51
LPAREN               : 29 30 31 32 33 34 35 36 60 74 74 75 75 93 94 95 96 105
LT                   : 49
MAKE                 : 93 94 95 96
MAP                  : 91 92 93 95
MINUS                : 44
MOD                  : 
NE                   : 48
NEW                  : 105
NUMBER               : 24 56 97 98
OR                   : 46
PACKAGE              : 
PLUS                 : 43
PRINT                : 
PRINTF               : 29
PRINTLN              : 30
RANGE                : 
RBRACE               : 32 33 73 74 75 76 81 85 86 98 102
RBRACKET             : 91 92 93 94 95 96 97 98 101 102
RETURN               : 
RPAREN               : 29 30 31 32 33 34 35 36 60 74 74 75 75 93 94 95 96 105
SCANLN               : 31
SEMICOLON            : 70 70
STRING               : 29 58
STRING_TYPE          : 65
STRUCT               : 76
SWITCH               : 85 86
TIMES                : 54
TRUE                 : 
TYPE                 : 76
UINT                 : 
VAR                  : 22 23 91 97 101
VARIABLE             : 22 23 26 27 28 31 32 33 34 35 36 39 59 74 74 74 75 75 75 76 79 81 84 91 92 93 94 97 98 101 102 105 105 107 108
error                : 

Nonterminals, with rules where they appear

arg_list             : 35 41
array_declaration    : 16
array_values         : 98 100
assignment           : 4 70 71
block                : 34 67 68 68 69 70
break_stmt           : 20
case_clause          : 87 88
case_list            : 85 86 88
declaration          : 3
expression           : 23 27 28 29 30 40 41 43 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 60 67 68 69 70 84 85 89 99 100 103 104
factor               : 53 54 55
field_value          : 82 83
for_stmt             : 12
for_update           : 70
func_call            : 10
func_def             : 8
func_no_params       : 9
if_stmt              : 11
increment_stmt       : 21 72
input_stmt           : 6
make_expr            : 61
make_stmt            : 18
map_declaration      : 15
new_stmt             : 19
param                : 37 38
param_list           : 32 38 74
print_stmt           : 5
program              : 2 32 33 73 74 75 89 90 0
slice_declaration    : 17
slice_values         : 102 104
statement            : 1 2
struct_def           : 13
struct_field         : 77 78
struct_fields        : 76 78
struct_fields_values : 81 83
struct_instance      : 62
struct_method        : 7
switch_stmt          : 14
term                 : 42 43 44 54 55
type                 : 22 23 32 33 39 74 75 79 80 91 91 92 92 93 93 94 95 95 96 97 98 101 102

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement
    (2) program -> . statement program
    (3) statement -> . declaration
    (4) statement -> . assignment
    (5) statement -> . print_stmt
    (6) statement -> . input_stmt
    (7) statement -> . struct_method
    (8) statement -> . func_def
    (9) statement -> . func_no_params
    (10) statement -> . func_call
    (11) statement -> . if_stmt
    (12) statement -> . for_stmt
    (13) statement -> . struct_def
    (14) statement -> . switch_stmt
    (15) statement -> . map_declaration
    (16) statement -> . array_declaration
    (17) statement -> . slice_declaration
    (18) statement -> . make_stmt
    (19) statement -> . new_stmt
    (20) statement -> . break_stmt
    (21) statement -> . increment_stmt
    (22) declaration -> . VAR VARIABLE type
    (23) declaration -> . VAR VARIABLE type ASIG expression
    (27) assignment -> . VARIABLE ASSIGN expression
    (28) assignment -> . VARIABLE ASIG expression
    (29) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (30) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (31) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (74) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (75) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (32) func_def -> . FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (33) func_def -> . FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (34) func_no_params -> . FUNC VARIABLE LPAREN RPAREN block
    (35) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (36) func_call -> . VARIABLE LPAREN RPAREN
    (67) if_stmt -> . IF expression block
    (68) if_stmt -> . IF expression block ELSE block
    (69) for_stmt -> . FOR expression block
    (70) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update block
    (76) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (85) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (86) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (91) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (92) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (97) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (98) array_declaration -> . VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (101) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (102) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (93) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (105) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (106) break_stmt -> . BREAK
    (107) increment_stmt -> . VARIABLE INCREMENT
    (108) increment_stmt -> . VARIABLE DECREMENT

    VAR             shift and go to state 22
    VARIABLE        shift and go to state 23
    FMT             shift and go to state 24
    FUNC            shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    TYPE            shift and go to state 28
    SWITCH          shift and go to state 29
    BREAK           shift and go to state 30

    program                        shift and go to state 1
    statement                      shift and go to state 2
    declaration                    shift and go to state 3
    assignment                     shift and go to state 4
    print_stmt                     shift and go to state 5
    input_stmt                     shift and go to state 6
    struct_method                  shift and go to state 7
    func_def                       shift and go to state 8
    func_no_params                 shift and go to state 9
    func_call                      shift and go to state 10
    if_stmt                        shift and go to state 11
    for_stmt                       shift and go to state 12
    struct_def                     shift and go to state 13
    switch_stmt                    shift and go to state 14
    map_declaration                shift and go to state 15
    array_declaration              shift and go to state 16
    slice_declaration              shift and go to state 17
    make_stmt                      shift and go to state 18
    new_stmt                       shift and go to state 19
    break_stmt                     shift and go to state 20
    increment_stmt                 shift and go to state 21

state 1

    (0) S' -> program .



state 2

    (1) program -> statement .
    (2) program -> statement . program
    (1) program -> . statement
    (2) program -> . statement program
    (3) statement -> . declaration
    (4) statement -> . assignment
    (5) statement -> . print_stmt
    (6) statement -> . input_stmt
    (7) statement -> . struct_method
    (8) statement -> . func_def
    (9) statement -> . func_no_params
    (10) statement -> . func_call
    (11) statement -> . if_stmt
    (12) statement -> . for_stmt
    (13) statement -> . struct_def
    (14) statement -> . switch_stmt
    (15) statement -> . map_declaration
    (16) statement -> . array_declaration
    (17) statement -> . slice_declaration
    (18) statement -> . make_stmt
    (19) statement -> . new_stmt
    (20) statement -> . break_stmt
    (21) statement -> . increment_stmt
    (22) declaration -> . VAR VARIABLE type
    (23) declaration -> . VAR VARIABLE type ASIG expression
    (27) assignment -> . VARIABLE ASSIGN expression
    (28) assignment -> . VARIABLE ASIG expression
    (29) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (30) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (31) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (74) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (75) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (32) func_def -> . FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (33) func_def -> . FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (34) func_no_params -> . FUNC VARIABLE LPAREN RPAREN block
    (35) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (36) func_call -> . VARIABLE LPAREN RPAREN
    (67) if_stmt -> . IF expression block
    (68) if_stmt -> . IF expression block ELSE block
    (69) for_stmt -> . FOR expression block
    (70) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update block
    (76) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (85) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (86) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (91) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (92) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (97) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (98) array_declaration -> . VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (101) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (102) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (93) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (105) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (106) break_stmt -> . BREAK
    (107) increment_stmt -> . VARIABLE INCREMENT
    (108) increment_stmt -> . VARIABLE DECREMENT

    $end            reduce using rule 1 (program -> statement .)
    RBRACE          reduce using rule 1 (program -> statement .)
    CASE            reduce using rule 1 (program -> statement .)
    DEFAULT         reduce using rule 1 (program -> statement .)
    VAR             shift and go to state 22
    VARIABLE        shift and go to state 23
    FMT             shift and go to state 24
    FUNC            shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    TYPE            shift and go to state 28
    SWITCH          shift and go to state 29
    BREAK           shift and go to state 30

    statement                      shift and go to state 2
    program                        shift and go to state 31
    declaration                    shift and go to state 3
    assignment                     shift and go to state 4
    print_stmt                     shift and go to state 5
    input_stmt                     shift and go to state 6
    struct_method                  shift and go to state 7
    func_def                       shift and go to state 8
    func_no_params                 shift and go to state 9
    func_call                      shift and go to state 10
    if_stmt                        shift and go to state 11
    for_stmt                       shift and go to state 12
    struct_def                     shift and go to state 13
    switch_stmt                    shift and go to state 14
    map_declaration                shift and go to state 15
    array_declaration              shift and go to state 16
    slice_declaration              shift and go to state 17
    make_stmt                      shift and go to state 18
    new_stmt                       shift and go to state 19
    break_stmt                     shift and go to state 20
    increment_stmt                 shift and go to state 21

state 3

    (3) statement -> declaration .

    VAR             reduce using rule 3 (statement -> declaration .)
    VARIABLE        reduce using rule 3 (statement -> declaration .)
    FMT             reduce using rule 3 (statement -> declaration .)
    FUNC            reduce using rule 3 (statement -> declaration .)
    IF              reduce using rule 3 (statement -> declaration .)
    FOR             reduce using rule 3 (statement -> declaration .)
    TYPE            reduce using rule 3 (statement -> declaration .)
    SWITCH          reduce using rule 3 (statement -> declaration .)
    BREAK           reduce using rule 3 (statement -> declaration .)
    $end            reduce using rule 3 (statement -> declaration .)
    RBRACE          reduce using rule 3 (statement -> declaration .)
    CASE            reduce using rule 3 (statement -> declaration .)
    DEFAULT         reduce using rule 3 (statement -> declaration .)


state 4

    (4) statement -> assignment .

    VAR             reduce using rule 4 (statement -> assignment .)
    VARIABLE        reduce using rule 4 (statement -> assignment .)
    FMT             reduce using rule 4 (statement -> assignment .)
    FUNC            reduce using rule 4 (statement -> assignment .)
    IF              reduce using rule 4 (statement -> assignment .)
    FOR             reduce using rule 4 (statement -> assignment .)
    TYPE            reduce using rule 4 (statement -> assignment .)
    SWITCH          reduce using rule 4 (statement -> assignment .)
    BREAK           reduce using rule 4 (statement -> assignment .)
    $end            reduce using rule 4 (statement -> assignment .)
    RBRACE          reduce using rule 4 (statement -> assignment .)
    CASE            reduce using rule 4 (statement -> assignment .)
    DEFAULT         reduce using rule 4 (statement -> assignment .)


state 5

    (5) statement -> print_stmt .

    VAR             reduce using rule 5 (statement -> print_stmt .)
    VARIABLE        reduce using rule 5 (statement -> print_stmt .)
    FMT             reduce using rule 5 (statement -> print_stmt .)
    FUNC            reduce using rule 5 (statement -> print_stmt .)
    IF              reduce using rule 5 (statement -> print_stmt .)
    FOR             reduce using rule 5 (statement -> print_stmt .)
    TYPE            reduce using rule 5 (statement -> print_stmt .)
    SWITCH          reduce using rule 5 (statement -> print_stmt .)
    BREAK           reduce using rule 5 (statement -> print_stmt .)
    $end            reduce using rule 5 (statement -> print_stmt .)
    RBRACE          reduce using rule 5 (statement -> print_stmt .)
    CASE            reduce using rule 5 (statement -> print_stmt .)
    DEFAULT         reduce using rule 5 (statement -> print_stmt .)


state 6

    (6) statement -> input_stmt .

    VAR             reduce using rule 6 (statement -> input_stmt .)
    VARIABLE        reduce using rule 6 (statement -> input_stmt .)
    FMT             reduce using rule 6 (statement -> input_stmt .)
    FUNC            reduce using rule 6 (statement -> input_stmt .)
    IF              reduce using rule 6 (statement -> input_stmt .)
    FOR             reduce using rule 6 (statement -> input_stmt .)
    TYPE            reduce using rule 6 (statement -> input_stmt .)
    SWITCH          reduce using rule 6 (statement -> input_stmt .)
    BREAK           reduce using rule 6 (statement -> input_stmt .)
    $end            reduce using rule 6 (statement -> input_stmt .)
    RBRACE          reduce using rule 6 (statement -> input_stmt .)
    CASE            reduce using rule 6 (statement -> input_stmt .)
    DEFAULT         reduce using rule 6 (statement -> input_stmt .)


state 7

    (7) statement -> struct_method .

    VAR             reduce using rule 7 (statement -> struct_method .)
    VARIABLE        reduce using rule 7 (statement -> struct_method .)
    FMT             reduce using rule 7 (statement -> struct_method .)
    FUNC            reduce using rule 7 (statement -> struct_method .)
    IF              reduce using rule 7 (statement -> struct_method .)
    FOR             reduce using rule 7 (statement -> struct_method .)
    TYPE            reduce using rule 7 (statement -> struct_method .)
    SWITCH          reduce using rule 7 (statement -> struct_method .)
    BREAK           reduce using rule 7 (statement -> struct_method .)
    $end            reduce using rule 7 (statement -> struct_method .)
    RBRACE          reduce using rule 7 (statement -> struct_method .)
    CASE            reduce using rule 7 (statement -> struct_method .)
    DEFAULT         reduce using rule 7 (statement -> struct_method .)


state 8

    (8) statement -> func_def .

    VAR             reduce using rule 8 (statement -> func_def .)
    VARIABLE        reduce using rule 8 (statement -> func_def .)
    FMT             reduce using rule 8 (statement -> func_def .)
    FUNC            reduce using rule 8 (statement -> func_def .)
    IF              reduce using rule 8 (statement -> func_def .)
    FOR             reduce using rule 8 (statement -> func_def .)
    TYPE            reduce using rule 8 (statement -> func_def .)
    SWITCH          reduce using rule 8 (statement -> func_def .)
    BREAK           reduce using rule 8 (statement -> func_def .)
    $end            reduce using rule 8 (statement -> func_def .)
    RBRACE          reduce using rule 8 (statement -> func_def .)
    CASE            reduce using rule 8 (statement -> func_def .)
    DEFAULT         reduce using rule 8 (statement -> func_def .)


state 9

    (9) statement -> func_no_params .

    VAR             reduce using rule 9 (statement -> func_no_params .)
    VARIABLE        reduce using rule 9 (statement -> func_no_params .)
    FMT             reduce using rule 9 (statement -> func_no_params .)
    FUNC            reduce using rule 9 (statement -> func_no_params .)
    IF              reduce using rule 9 (statement -> func_no_params .)
    FOR             reduce using rule 9 (statement -> func_no_params .)
    TYPE            reduce using rule 9 (statement -> func_no_params .)
    SWITCH          reduce using rule 9 (statement -> func_no_params .)
    BREAK           reduce using rule 9 (statement -> func_no_params .)
    $end            reduce using rule 9 (statement -> func_no_params .)
    RBRACE          reduce using rule 9 (statement -> func_no_params .)
    CASE            reduce using rule 9 (statement -> func_no_params .)
    DEFAULT         reduce using rule 9 (statement -> func_no_params .)


state 10

    (10) statement -> func_call .

    VAR             reduce using rule 10 (statement -> func_call .)
    VARIABLE        reduce using rule 10 (statement -> func_call .)
    FMT             reduce using rule 10 (statement -> func_call .)
    FUNC            reduce using rule 10 (statement -> func_call .)
    IF              reduce using rule 10 (statement -> func_call .)
    FOR             reduce using rule 10 (statement -> func_call .)
    TYPE            reduce using rule 10 (statement -> func_call .)
    SWITCH          reduce using rule 10 (statement -> func_call .)
    BREAK           reduce using rule 10 (statement -> func_call .)
    $end            reduce using rule 10 (statement -> func_call .)
    RBRACE          reduce using rule 10 (statement -> func_call .)
    CASE            reduce using rule 10 (statement -> func_call .)
    DEFAULT         reduce using rule 10 (statement -> func_call .)


state 11

    (11) statement -> if_stmt .

    VAR             reduce using rule 11 (statement -> if_stmt .)
    VARIABLE        reduce using rule 11 (statement -> if_stmt .)
    FMT             reduce using rule 11 (statement -> if_stmt .)
    FUNC            reduce using rule 11 (statement -> if_stmt .)
    IF              reduce using rule 11 (statement -> if_stmt .)
    FOR             reduce using rule 11 (statement -> if_stmt .)
    TYPE            reduce using rule 11 (statement -> if_stmt .)
    SWITCH          reduce using rule 11 (statement -> if_stmt .)
    BREAK           reduce using rule 11 (statement -> if_stmt .)
    $end            reduce using rule 11 (statement -> if_stmt .)
    RBRACE          reduce using rule 11 (statement -> if_stmt .)
    CASE            reduce using rule 11 (statement -> if_stmt .)
    DEFAULT         reduce using rule 11 (statement -> if_stmt .)


state 12

    (12) statement -> for_stmt .

    VAR             reduce using rule 12 (statement -> for_stmt .)
    VARIABLE        reduce using rule 12 (statement -> for_stmt .)
    FMT             reduce using rule 12 (statement -> for_stmt .)
    FUNC            reduce using rule 12 (statement -> for_stmt .)
    IF              reduce using rule 12 (statement -> for_stmt .)
    FOR             reduce using rule 12 (statement -> for_stmt .)
    TYPE            reduce using rule 12 (statement -> for_stmt .)
    SWITCH          reduce using rule 12 (statement -> for_stmt .)
    BREAK           reduce using rule 12 (statement -> for_stmt .)
    $end            reduce using rule 12 (statement -> for_stmt .)
    RBRACE          reduce using rule 12 (statement -> for_stmt .)
    CASE            reduce using rule 12 (statement -> for_stmt .)
    DEFAULT         reduce using rule 12 (statement -> for_stmt .)


state 13

    (13) statement -> struct_def .

    VAR             reduce using rule 13 (statement -> struct_def .)
    VARIABLE        reduce using rule 13 (statement -> struct_def .)
    FMT             reduce using rule 13 (statement -> struct_def .)
    FUNC            reduce using rule 13 (statement -> struct_def .)
    IF              reduce using rule 13 (statement -> struct_def .)
    FOR             reduce using rule 13 (statement -> struct_def .)
    TYPE            reduce using rule 13 (statement -> struct_def .)
    SWITCH          reduce using rule 13 (statement -> struct_def .)
    BREAK           reduce using rule 13 (statement -> struct_def .)
    $end            reduce using rule 13 (statement -> struct_def .)
    RBRACE          reduce using rule 13 (statement -> struct_def .)
    CASE            reduce using rule 13 (statement -> struct_def .)
    DEFAULT         reduce using rule 13 (statement -> struct_def .)


state 14

    (14) statement -> switch_stmt .

    VAR             reduce using rule 14 (statement -> switch_stmt .)
    VARIABLE        reduce using rule 14 (statement -> switch_stmt .)
    FMT             reduce using rule 14 (statement -> switch_stmt .)
    FUNC            reduce using rule 14 (statement -> switch_stmt .)
    IF              reduce using rule 14 (statement -> switch_stmt .)
    FOR             reduce using rule 14 (statement -> switch_stmt .)
    TYPE            reduce using rule 14 (statement -> switch_stmt .)
    SWITCH          reduce using rule 14 (statement -> switch_stmt .)
    BREAK           reduce using rule 14 (statement -> switch_stmt .)
    $end            reduce using rule 14 (statement -> switch_stmt .)
    RBRACE          reduce using rule 14 (statement -> switch_stmt .)
    CASE            reduce using rule 14 (statement -> switch_stmt .)
    DEFAULT         reduce using rule 14 (statement -> switch_stmt .)


state 15

    (15) statement -> map_declaration .

    VAR             reduce using rule 15 (statement -> map_declaration .)
    VARIABLE        reduce using rule 15 (statement -> map_declaration .)
    FMT             reduce using rule 15 (statement -> map_declaration .)
    FUNC            reduce using rule 15 (statement -> map_declaration .)
    IF              reduce using rule 15 (statement -> map_declaration .)
    FOR             reduce using rule 15 (statement -> map_declaration .)
    TYPE            reduce using rule 15 (statement -> map_declaration .)
    SWITCH          reduce using rule 15 (statement -> map_declaration .)
    BREAK           reduce using rule 15 (statement -> map_declaration .)
    $end            reduce using rule 15 (statement -> map_declaration .)
    RBRACE          reduce using rule 15 (statement -> map_declaration .)
    CASE            reduce using rule 15 (statement -> map_declaration .)
    DEFAULT         reduce using rule 15 (statement -> map_declaration .)


state 16

    (16) statement -> array_declaration .

    VAR             reduce using rule 16 (statement -> array_declaration .)
    VARIABLE        reduce using rule 16 (statement -> array_declaration .)
    FMT             reduce using rule 16 (statement -> array_declaration .)
    FUNC            reduce using rule 16 (statement -> array_declaration .)
    IF              reduce using rule 16 (statement -> array_declaration .)
    FOR             reduce using rule 16 (statement -> array_declaration .)
    TYPE            reduce using rule 16 (statement -> array_declaration .)
    SWITCH          reduce using rule 16 (statement -> array_declaration .)
    BREAK           reduce using rule 16 (statement -> array_declaration .)
    $end            reduce using rule 16 (statement -> array_declaration .)
    RBRACE          reduce using rule 16 (statement -> array_declaration .)
    CASE            reduce using rule 16 (statement -> array_declaration .)
    DEFAULT         reduce using rule 16 (statement -> array_declaration .)


state 17

    (17) statement -> slice_declaration .

    VAR             reduce using rule 17 (statement -> slice_declaration .)
    VARIABLE        reduce using rule 17 (statement -> slice_declaration .)
    FMT             reduce using rule 17 (statement -> slice_declaration .)
    FUNC            reduce using rule 17 (statement -> slice_declaration .)
    IF              reduce using rule 17 (statement -> slice_declaration .)
    FOR             reduce using rule 17 (statement -> slice_declaration .)
    TYPE            reduce using rule 17 (statement -> slice_declaration .)
    SWITCH          reduce using rule 17 (statement -> slice_declaration .)
    BREAK           reduce using rule 17 (statement -> slice_declaration .)
    $end            reduce using rule 17 (statement -> slice_declaration .)
    RBRACE          reduce using rule 17 (statement -> slice_declaration .)
    CASE            reduce using rule 17 (statement -> slice_declaration .)
    DEFAULT         reduce using rule 17 (statement -> slice_declaration .)


state 18

    (18) statement -> make_stmt .

    VAR             reduce using rule 18 (statement -> make_stmt .)
    VARIABLE        reduce using rule 18 (statement -> make_stmt .)
    FMT             reduce using rule 18 (statement -> make_stmt .)
    FUNC            reduce using rule 18 (statement -> make_stmt .)
    IF              reduce using rule 18 (statement -> make_stmt .)
    FOR             reduce using rule 18 (statement -> make_stmt .)
    TYPE            reduce using rule 18 (statement -> make_stmt .)
    SWITCH          reduce using rule 18 (statement -> make_stmt .)
    BREAK           reduce using rule 18 (statement -> make_stmt .)
    $end            reduce using rule 18 (statement -> make_stmt .)
    RBRACE          reduce using rule 18 (statement -> make_stmt .)
    CASE            reduce using rule 18 (statement -> make_stmt .)
    DEFAULT         reduce using rule 18 (statement -> make_stmt .)


state 19

    (19) statement -> new_stmt .

    VAR             reduce using rule 19 (statement -> new_stmt .)
    VARIABLE        reduce using rule 19 (statement -> new_stmt .)
    FMT             reduce using rule 19 (statement -> new_stmt .)
    FUNC            reduce using rule 19 (statement -> new_stmt .)
    IF              reduce using rule 19 (statement -> new_stmt .)
    FOR             reduce using rule 19 (statement -> new_stmt .)
    TYPE            reduce using rule 19 (statement -> new_stmt .)
    SWITCH          reduce using rule 19 (statement -> new_stmt .)
    BREAK           reduce using rule 19 (statement -> new_stmt .)
    $end            reduce using rule 19 (statement -> new_stmt .)
    RBRACE          reduce using rule 19 (statement -> new_stmt .)
    CASE            reduce using rule 19 (statement -> new_stmt .)
    DEFAULT         reduce using rule 19 (statement -> new_stmt .)


state 20

    (20) statement -> break_stmt .

    VAR             reduce using rule 20 (statement -> break_stmt .)
    VARIABLE        reduce using rule 20 (statement -> break_stmt .)
    FMT             reduce using rule 20 (statement -> break_stmt .)
    FUNC            reduce using rule 20 (statement -> break_stmt .)
    IF              reduce using rule 20 (statement -> break_stmt .)
    FOR             reduce using rule 20 (statement -> break_stmt .)
    TYPE            reduce using rule 20 (statement -> break_stmt .)
    SWITCH          reduce using rule 20 (statement -> break_stmt .)
    BREAK           reduce using rule 20 (statement -> break_stmt .)
    $end            reduce using rule 20 (statement -> break_stmt .)
    RBRACE          reduce using rule 20 (statement -> break_stmt .)
    CASE            reduce using rule 20 (statement -> break_stmt .)
    DEFAULT         reduce using rule 20 (statement -> break_stmt .)


state 21

    (21) statement -> increment_stmt .

    VAR             reduce using rule 21 (statement -> increment_stmt .)
    VARIABLE        reduce using rule 21 (statement -> increment_stmt .)
    FMT             reduce using rule 21 (statement -> increment_stmt .)
    FUNC            reduce using rule 21 (statement -> increment_stmt .)
    IF              reduce using rule 21 (statement -> increment_stmt .)
    FOR             reduce using rule 21 (statement -> increment_stmt .)
    TYPE            reduce using rule 21 (statement -> increment_stmt .)
    SWITCH          reduce using rule 21 (statement -> increment_stmt .)
    BREAK           reduce using rule 21 (statement -> increment_stmt .)
    $end            reduce using rule 21 (statement -> increment_stmt .)
    RBRACE          reduce using rule 21 (statement -> increment_stmt .)
    CASE            reduce using rule 21 (statement -> increment_stmt .)
    DEFAULT         reduce using rule 21 (statement -> increment_stmt .)


state 22

    (22) declaration -> VAR . VARIABLE type
    (23) declaration -> VAR . VARIABLE type ASIG expression
    (91) map_declaration -> VAR . VARIABLE MAP LBRACKET type RBRACKET type
    (97) array_declaration -> VAR . VARIABLE LBRACKET NUMBER RBRACKET type
    (101) slice_declaration -> VAR . VARIABLE LBRACKET RBRACKET type

    VARIABLE        shift and go to state 32


state 23

    (27) assignment -> VARIABLE . ASSIGN expression
    (28) assignment -> VARIABLE . ASIG expression
    (35) func_call -> VARIABLE . LPAREN arg_list RPAREN
    (36) func_call -> VARIABLE . LPAREN RPAREN
    (92) map_declaration -> VARIABLE . ASIG MAP LBRACKET type RBRACKET type
    (98) array_declaration -> VARIABLE . ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (102) slice_declaration -> VARIABLE . ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (93) make_stmt -> VARIABLE . ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) make_stmt -> VARIABLE . ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (105) new_stmt -> VARIABLE . ASIG NEW LPAREN VARIABLE RPAREN
    (107) increment_stmt -> VARIABLE . INCREMENT
    (108) increment_stmt -> VARIABLE . DECREMENT

    ASSIGN          shift and go to state 33
    ASIG            shift and go to state 34
    LPAREN          shift and go to state 35
    INCREMENT       shift and go to state 36
    DECREMENT       shift and go to state 37


state 24

    (29) print_stmt -> FMT . DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (30) print_stmt -> FMT . DOT PRINTLN LPAREN expression RPAREN
    (31) input_stmt -> FMT . DOT SCANLN LPAREN AMPER VARIABLE RPAREN

    DOT             shift and go to state 38


state 25

    (74) struct_method -> FUNC . LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (75) struct_method -> FUNC . LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (32) func_def -> FUNC . VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (33) func_def -> FUNC . VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (34) func_no_params -> FUNC . VARIABLE LPAREN RPAREN block

    LPAREN          shift and go to state 39
    VARIABLE        shift and go to state 40


state 26

    (67) if_stmt -> IF . expression block
    (68) if_stmt -> IF . expression block ELSE block
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 41
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 27

    (69) for_stmt -> FOR . expression block
    (70) for_stmt -> FOR . assignment SEMICOLON expression SEMICOLON for_update block
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (27) assignment -> . VARIABLE ASSIGN expression
    (28) assignment -> . VARIABLE ASIG expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 54
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 52
    assignment                     shift and go to state 53
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 28

    (76) struct_def -> TYPE . VARIABLE STRUCT LBRACE struct_fields RBRACE

    VARIABLE        shift and go to state 55


state 29

    (85) switch_stmt -> SWITCH . expression LBRACE case_list RBRACE
    (86) switch_stmt -> SWITCH . LBRACE case_list RBRACE
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    LBRACE          shift and go to state 57
    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 56
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 30

    (106) break_stmt -> BREAK .

    VAR             reduce using rule 106 (break_stmt -> BREAK .)
    VARIABLE        reduce using rule 106 (break_stmt -> BREAK .)
    FMT             reduce using rule 106 (break_stmt -> BREAK .)
    FUNC            reduce using rule 106 (break_stmt -> BREAK .)
    IF              reduce using rule 106 (break_stmt -> BREAK .)
    FOR             reduce using rule 106 (break_stmt -> BREAK .)
    TYPE            reduce using rule 106 (break_stmt -> BREAK .)
    SWITCH          reduce using rule 106 (break_stmt -> BREAK .)
    BREAK           reduce using rule 106 (break_stmt -> BREAK .)
    $end            reduce using rule 106 (break_stmt -> BREAK .)
    RBRACE          reduce using rule 106 (break_stmt -> BREAK .)
    CASE            reduce using rule 106 (break_stmt -> BREAK .)
    DEFAULT         reduce using rule 106 (break_stmt -> BREAK .)


state 31

    (2) program -> statement program .

    $end            reduce using rule 2 (program -> statement program .)
    RBRACE          reduce using rule 2 (program -> statement program .)
    CASE            reduce using rule 2 (program -> statement program .)
    DEFAULT         reduce using rule 2 (program -> statement program .)


state 32

    (22) declaration -> VAR VARIABLE . type
    (23) declaration -> VAR VARIABLE . type ASIG expression
    (91) map_declaration -> VAR VARIABLE . MAP LBRACKET type RBRACKET type
    (97) array_declaration -> VAR VARIABLE . LBRACKET NUMBER RBRACKET type
    (101) slice_declaration -> VAR VARIABLE . LBRACKET RBRACKET type
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE

    MAP             shift and go to state 59
    LBRACKET        shift and go to state 60
    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64

    type                           shift and go to state 58

state 33

    (27) assignment -> VARIABLE ASSIGN . expression
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 65
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 34

    (28) assignment -> VARIABLE ASIG . expression
    (92) map_declaration -> VARIABLE ASIG . MAP LBRACKET type RBRACKET type
    (98) array_declaration -> VARIABLE ASIG . LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (102) slice_declaration -> VARIABLE ASIG . LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (93) make_stmt -> VARIABLE ASIG . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) make_stmt -> VARIABLE ASIG . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (105) new_stmt -> VARIABLE ASIG . NEW LPAREN VARIABLE RPAREN
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    MAP             shift and go to state 67
    LBRACKET        shift and go to state 68
    MAKE            shift and go to state 69
    NEW             shift and go to state 70
    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48

    expression                     shift and go to state 66
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 35

    (35) func_call -> VARIABLE LPAREN . arg_list RPAREN
    (36) func_call -> VARIABLE LPAREN . RPAREN
    (40) arg_list -> . expression
    (41) arg_list -> . expression COMMA arg_list
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    RPAREN          shift and go to state 72
    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    arg_list                       shift and go to state 71
    expression                     shift and go to state 73
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 36

    (107) increment_stmt -> VARIABLE INCREMENT .

    VAR             reduce using rule 107 (increment_stmt -> VARIABLE INCREMENT .)
    VARIABLE        reduce using rule 107 (increment_stmt -> VARIABLE INCREMENT .)
    FMT             reduce using rule 107 (increment_stmt -> VARIABLE INCREMENT .)
    FUNC            reduce using rule 107 (increment_stmt -> VARIABLE INCREMENT .)
    IF              reduce using rule 107 (increment_stmt -> VARIABLE INCREMENT .)
    FOR             reduce using rule 107 (increment_stmt -> VARIABLE INCREMENT .)
    TYPE            reduce using rule 107 (increment_stmt -> VARIABLE INCREMENT .)
    SWITCH          reduce using rule 107 (increment_stmt -> VARIABLE INCREMENT .)
    BREAK           reduce using rule 107 (increment_stmt -> VARIABLE INCREMENT .)
    $end            reduce using rule 107 (increment_stmt -> VARIABLE INCREMENT .)
    RBRACE          reduce using rule 107 (increment_stmt -> VARIABLE INCREMENT .)
    CASE            reduce using rule 107 (increment_stmt -> VARIABLE INCREMENT .)
    DEFAULT         reduce using rule 107 (increment_stmt -> VARIABLE INCREMENT .)
    LBRACE          reduce using rule 107 (increment_stmt -> VARIABLE INCREMENT .)


state 37

    (108) increment_stmt -> VARIABLE DECREMENT .

    VAR             reduce using rule 108 (increment_stmt -> VARIABLE DECREMENT .)
    VARIABLE        reduce using rule 108 (increment_stmt -> VARIABLE DECREMENT .)
    FMT             reduce using rule 108 (increment_stmt -> VARIABLE DECREMENT .)
    FUNC            reduce using rule 108 (increment_stmt -> VARIABLE DECREMENT .)
    IF              reduce using rule 108 (increment_stmt -> VARIABLE DECREMENT .)
    FOR             reduce using rule 108 (increment_stmt -> VARIABLE DECREMENT .)
    TYPE            reduce using rule 108 (increment_stmt -> VARIABLE DECREMENT .)
    SWITCH          reduce using rule 108 (increment_stmt -> VARIABLE DECREMENT .)
    BREAK           reduce using rule 108 (increment_stmt -> VARIABLE DECREMENT .)
    $end            reduce using rule 108 (increment_stmt -> VARIABLE DECREMENT .)
    RBRACE          reduce using rule 108 (increment_stmt -> VARIABLE DECREMENT .)
    CASE            reduce using rule 108 (increment_stmt -> VARIABLE DECREMENT .)
    DEFAULT         reduce using rule 108 (increment_stmt -> VARIABLE DECREMENT .)
    LBRACE          reduce using rule 108 (increment_stmt -> VARIABLE DECREMENT .)


state 38

    (29) print_stmt -> FMT DOT . PRINTF LPAREN STRING COMMA expression RPAREN
    (30) print_stmt -> FMT DOT . PRINTLN LPAREN expression RPAREN
    (31) input_stmt -> FMT DOT . SCANLN LPAREN AMPER VARIABLE RPAREN

    PRINTF          shift and go to state 74
    PRINTLN         shift and go to state 75
    SCANLN          shift and go to state 76


state 39

    (74) struct_method -> FUNC LPAREN . VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (75) struct_method -> FUNC LPAREN . VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE

    VARIABLE        shift and go to state 77


state 40

    (32) func_def -> FUNC VARIABLE . LPAREN param_list RPAREN type LBRACE program RBRACE
    (33) func_def -> FUNC VARIABLE . LPAREN RPAREN type LBRACE program RBRACE
    (34) func_no_params -> FUNC VARIABLE . LPAREN RPAREN block

    LPAREN          shift and go to state 78


state 41

    (67) if_stmt -> IF expression . block
    (68) if_stmt -> IF expression . block ELSE block
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (73) block -> . LBRACE program RBRACE

    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89
    LBRACE          shift and go to state 90

    block                          shift and go to state 79

state 42

    (24) expression -> NUMBER .
    (56) factor -> NUMBER .

  ! reduce/reduce conflict for PLUS resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for MINUS resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for AND resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for OR resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for EQ resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for NE resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for LT resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for GT resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for LE resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for GE resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for LBRACE resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for VAR resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for FMT resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for FUNC resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for IF resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for FOR resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for TYPE resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for SWITCH resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for BREAK resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for $end resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for RBRACE resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for CASE resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for COMMA resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 24 (expression -> NUMBER .)
  ! reduce/reduce conflict for COLON resolved using rule 24 (expression -> NUMBER .)
    PLUS            reduce using rule 24 (expression -> NUMBER .)
    MINUS           reduce using rule 24 (expression -> NUMBER .)
    AND             reduce using rule 24 (expression -> NUMBER .)
    OR              reduce using rule 24 (expression -> NUMBER .)
    EQ              reduce using rule 24 (expression -> NUMBER .)
    NE              reduce using rule 24 (expression -> NUMBER .)
    LT              reduce using rule 24 (expression -> NUMBER .)
    GT              reduce using rule 24 (expression -> NUMBER .)
    LE              reduce using rule 24 (expression -> NUMBER .)
    GE              reduce using rule 24 (expression -> NUMBER .)
    LBRACE          reduce using rule 24 (expression -> NUMBER .)
    VAR             reduce using rule 24 (expression -> NUMBER .)
    VARIABLE        reduce using rule 24 (expression -> NUMBER .)
    FMT             reduce using rule 24 (expression -> NUMBER .)
    FUNC            reduce using rule 24 (expression -> NUMBER .)
    IF              reduce using rule 24 (expression -> NUMBER .)
    FOR             reduce using rule 24 (expression -> NUMBER .)
    TYPE            reduce using rule 24 (expression -> NUMBER .)
    SWITCH          reduce using rule 24 (expression -> NUMBER .)
    BREAK           reduce using rule 24 (expression -> NUMBER .)
    $end            reduce using rule 24 (expression -> NUMBER .)
    RBRACE          reduce using rule 24 (expression -> NUMBER .)
    CASE            reduce using rule 24 (expression -> NUMBER .)
    DEFAULT         reduce using rule 24 (expression -> NUMBER .)
    SEMICOLON       reduce using rule 24 (expression -> NUMBER .)
    COMMA           reduce using rule 24 (expression -> NUMBER .)
    RPAREN          reduce using rule 24 (expression -> NUMBER .)
    COLON           reduce using rule 24 (expression -> NUMBER .)
    TIMES           reduce using rule 56 (factor -> NUMBER .)
    DIVIDE          reduce using rule 56 (factor -> NUMBER .)

  ! PLUS            [ reduce using rule 56 (factor -> NUMBER .) ]
  ! MINUS           [ reduce using rule 56 (factor -> NUMBER .) ]
  ! AND             [ reduce using rule 56 (factor -> NUMBER .) ]
  ! OR              [ reduce using rule 56 (factor -> NUMBER .) ]
  ! EQ              [ reduce using rule 56 (factor -> NUMBER .) ]
  ! NE              [ reduce using rule 56 (factor -> NUMBER .) ]
  ! LT              [ reduce using rule 56 (factor -> NUMBER .) ]
  ! GT              [ reduce using rule 56 (factor -> NUMBER .) ]
  ! LE              [ reduce using rule 56 (factor -> NUMBER .) ]
  ! GE              [ reduce using rule 56 (factor -> NUMBER .) ]
  ! LBRACE          [ reduce using rule 56 (factor -> NUMBER .) ]
  ! VAR             [ reduce using rule 56 (factor -> NUMBER .) ]
  ! VARIABLE        [ reduce using rule 56 (factor -> NUMBER .) ]
  ! FMT             [ reduce using rule 56 (factor -> NUMBER .) ]
  ! FUNC            [ reduce using rule 56 (factor -> NUMBER .) ]
  ! IF              [ reduce using rule 56 (factor -> NUMBER .) ]
  ! FOR             [ reduce using rule 56 (factor -> NUMBER .) ]
  ! TYPE            [ reduce using rule 56 (factor -> NUMBER .) ]
  ! SWITCH          [ reduce using rule 56 (factor -> NUMBER .) ]
  ! BREAK           [ reduce using rule 56 (factor -> NUMBER .) ]
  ! $end            [ reduce using rule 56 (factor -> NUMBER .) ]
  ! RBRACE          [ reduce using rule 56 (factor -> NUMBER .) ]
  ! CASE            [ reduce using rule 56 (factor -> NUMBER .) ]
  ! DEFAULT         [ reduce using rule 56 (factor -> NUMBER .) ]
  ! SEMICOLON       [ reduce using rule 56 (factor -> NUMBER .) ]
  ! COMMA           [ reduce using rule 56 (factor -> NUMBER .) ]
  ! RPAREN          [ reduce using rule 56 (factor -> NUMBER .) ]
  ! COLON           [ reduce using rule 56 (factor -> NUMBER .) ]


state 43

    (25) expression -> FLOAT .
    (57) factor -> FLOAT .

  ! reduce/reduce conflict for PLUS resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for MINUS resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for AND resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for OR resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for EQ resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for NE resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for LT resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for GT resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for LE resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for GE resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for LBRACE resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for VAR resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for FMT resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for FUNC resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for IF resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for FOR resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for TYPE resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for SWITCH resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for BREAK resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for $end resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for RBRACE resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for CASE resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for COMMA resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for RPAREN resolved using rule 25 (expression -> FLOAT .)
  ! reduce/reduce conflict for COLON resolved using rule 25 (expression -> FLOAT .)
    PLUS            reduce using rule 25 (expression -> FLOAT .)
    MINUS           reduce using rule 25 (expression -> FLOAT .)
    AND             reduce using rule 25 (expression -> FLOAT .)
    OR              reduce using rule 25 (expression -> FLOAT .)
    EQ              reduce using rule 25 (expression -> FLOAT .)
    NE              reduce using rule 25 (expression -> FLOAT .)
    LT              reduce using rule 25 (expression -> FLOAT .)
    GT              reduce using rule 25 (expression -> FLOAT .)
    LE              reduce using rule 25 (expression -> FLOAT .)
    GE              reduce using rule 25 (expression -> FLOAT .)
    LBRACE          reduce using rule 25 (expression -> FLOAT .)
    VAR             reduce using rule 25 (expression -> FLOAT .)
    VARIABLE        reduce using rule 25 (expression -> FLOAT .)
    FMT             reduce using rule 25 (expression -> FLOAT .)
    FUNC            reduce using rule 25 (expression -> FLOAT .)
    IF              reduce using rule 25 (expression -> FLOAT .)
    FOR             reduce using rule 25 (expression -> FLOAT .)
    TYPE            reduce using rule 25 (expression -> FLOAT .)
    SWITCH          reduce using rule 25 (expression -> FLOAT .)
    BREAK           reduce using rule 25 (expression -> FLOAT .)
    $end            reduce using rule 25 (expression -> FLOAT .)
    RBRACE          reduce using rule 25 (expression -> FLOAT .)
    CASE            reduce using rule 25 (expression -> FLOAT .)
    DEFAULT         reduce using rule 25 (expression -> FLOAT .)
    SEMICOLON       reduce using rule 25 (expression -> FLOAT .)
    COMMA           reduce using rule 25 (expression -> FLOAT .)
    RPAREN          reduce using rule 25 (expression -> FLOAT .)
    COLON           reduce using rule 25 (expression -> FLOAT .)
    TIMES           reduce using rule 57 (factor -> FLOAT .)
    DIVIDE          reduce using rule 57 (factor -> FLOAT .)

  ! PLUS            [ reduce using rule 57 (factor -> FLOAT .) ]
  ! MINUS           [ reduce using rule 57 (factor -> FLOAT .) ]
  ! AND             [ reduce using rule 57 (factor -> FLOAT .) ]
  ! OR              [ reduce using rule 57 (factor -> FLOAT .) ]
  ! EQ              [ reduce using rule 57 (factor -> FLOAT .) ]
  ! NE              [ reduce using rule 57 (factor -> FLOAT .) ]
  ! LT              [ reduce using rule 57 (factor -> FLOAT .) ]
  ! GT              [ reduce using rule 57 (factor -> FLOAT .) ]
  ! LE              [ reduce using rule 57 (factor -> FLOAT .) ]
  ! GE              [ reduce using rule 57 (factor -> FLOAT .) ]
  ! LBRACE          [ reduce using rule 57 (factor -> FLOAT .) ]
  ! VAR             [ reduce using rule 57 (factor -> FLOAT .) ]
  ! VARIABLE        [ reduce using rule 57 (factor -> FLOAT .) ]
  ! FMT             [ reduce using rule 57 (factor -> FLOAT .) ]
  ! FUNC            [ reduce using rule 57 (factor -> FLOAT .) ]
  ! IF              [ reduce using rule 57 (factor -> FLOAT .) ]
  ! FOR             [ reduce using rule 57 (factor -> FLOAT .) ]
  ! TYPE            [ reduce using rule 57 (factor -> FLOAT .) ]
  ! SWITCH          [ reduce using rule 57 (factor -> FLOAT .) ]
  ! BREAK           [ reduce using rule 57 (factor -> FLOAT .) ]
  ! $end            [ reduce using rule 57 (factor -> FLOAT .) ]
  ! RBRACE          [ reduce using rule 57 (factor -> FLOAT .) ]
  ! CASE            [ reduce using rule 57 (factor -> FLOAT .) ]
  ! DEFAULT         [ reduce using rule 57 (factor -> FLOAT .) ]
  ! SEMICOLON       [ reduce using rule 57 (factor -> FLOAT .) ]
  ! COMMA           [ reduce using rule 57 (factor -> FLOAT .) ]
  ! RPAREN          [ reduce using rule 57 (factor -> FLOAT .) ]
  ! COLON           [ reduce using rule 57 (factor -> FLOAT .) ]


state 44

    (26) expression -> VARIABLE .
    (59) factor -> VARIABLE .
    (81) struct_instance -> VARIABLE . LBRACE struct_fields_values RBRACE

  ! reduce/reduce conflict for PLUS resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for MINUS resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for AND resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for OR resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for EQ resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for NE resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for LT resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for GT resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for LE resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for GE resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for LBRACE resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for VAR resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for FMT resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for FUNC resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for IF resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for FOR resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for TYPE resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for SWITCH resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for BREAK resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for $end resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for RBRACE resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for CASE resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for COMMA resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for RPAREN resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for COLON resolved using rule 26 (expression -> VARIABLE .)
  ! shift/reduce conflict for LBRACE resolved as shift
    PLUS            reduce using rule 26 (expression -> VARIABLE .)
    MINUS           reduce using rule 26 (expression -> VARIABLE .)
    AND             reduce using rule 26 (expression -> VARIABLE .)
    OR              reduce using rule 26 (expression -> VARIABLE .)
    EQ              reduce using rule 26 (expression -> VARIABLE .)
    NE              reduce using rule 26 (expression -> VARIABLE .)
    LT              reduce using rule 26 (expression -> VARIABLE .)
    GT              reduce using rule 26 (expression -> VARIABLE .)
    LE              reduce using rule 26 (expression -> VARIABLE .)
    GE              reduce using rule 26 (expression -> VARIABLE .)
    VAR             reduce using rule 26 (expression -> VARIABLE .)
    VARIABLE        reduce using rule 26 (expression -> VARIABLE .)
    FMT             reduce using rule 26 (expression -> VARIABLE .)
    FUNC            reduce using rule 26 (expression -> VARIABLE .)
    IF              reduce using rule 26 (expression -> VARIABLE .)
    FOR             reduce using rule 26 (expression -> VARIABLE .)
    TYPE            reduce using rule 26 (expression -> VARIABLE .)
    SWITCH          reduce using rule 26 (expression -> VARIABLE .)
    BREAK           reduce using rule 26 (expression -> VARIABLE .)
    $end            reduce using rule 26 (expression -> VARIABLE .)
    RBRACE          reduce using rule 26 (expression -> VARIABLE .)
    CASE            reduce using rule 26 (expression -> VARIABLE .)
    DEFAULT         reduce using rule 26 (expression -> VARIABLE .)
    SEMICOLON       reduce using rule 26 (expression -> VARIABLE .)
    COMMA           reduce using rule 26 (expression -> VARIABLE .)
    RPAREN          reduce using rule 26 (expression -> VARIABLE .)
    COLON           reduce using rule 26 (expression -> VARIABLE .)
    TIMES           reduce using rule 59 (factor -> VARIABLE .)
    DIVIDE          reduce using rule 59 (factor -> VARIABLE .)
    LBRACE          shift and go to state 91

  ! LBRACE          [ reduce using rule 26 (expression -> VARIABLE .) ]
  ! PLUS            [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! MINUS           [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! AND             [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! OR              [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! EQ              [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! NE              [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! LT              [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! GT              [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! LE              [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! GE              [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! LBRACE          [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! VAR             [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! VARIABLE        [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! FMT             [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! FUNC            [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! IF              [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! FOR             [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! TYPE            [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! SWITCH          [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! BREAK           [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! $end            [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! RBRACE          [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! CASE            [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! DEFAULT         [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! SEMICOLON       [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! COMMA           [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! RPAREN          [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! COLON           [ reduce using rule 59 (factor -> VARIABLE .) ]


state 45

    (42) expression -> term .
    (54) term -> term . TIMES factor
    (55) term -> term . DIVIDE factor

    PLUS            reduce using rule 42 (expression -> term .)
    MINUS           reduce using rule 42 (expression -> term .)
    AND             reduce using rule 42 (expression -> term .)
    OR              reduce using rule 42 (expression -> term .)
    EQ              reduce using rule 42 (expression -> term .)
    NE              reduce using rule 42 (expression -> term .)
    LT              reduce using rule 42 (expression -> term .)
    GT              reduce using rule 42 (expression -> term .)
    LE              reduce using rule 42 (expression -> term .)
    GE              reduce using rule 42 (expression -> term .)
    LBRACE          reduce using rule 42 (expression -> term .)
    VAR             reduce using rule 42 (expression -> term .)
    VARIABLE        reduce using rule 42 (expression -> term .)
    FMT             reduce using rule 42 (expression -> term .)
    FUNC            reduce using rule 42 (expression -> term .)
    IF              reduce using rule 42 (expression -> term .)
    FOR             reduce using rule 42 (expression -> term .)
    TYPE            reduce using rule 42 (expression -> term .)
    SWITCH          reduce using rule 42 (expression -> term .)
    BREAK           reduce using rule 42 (expression -> term .)
    $end            reduce using rule 42 (expression -> term .)
    RBRACE          reduce using rule 42 (expression -> term .)
    CASE            reduce using rule 42 (expression -> term .)
    DEFAULT         reduce using rule 42 (expression -> term .)
    SEMICOLON       reduce using rule 42 (expression -> term .)
    COMMA           reduce using rule 42 (expression -> term .)
    RPAREN          reduce using rule 42 (expression -> term .)
    COLON           reduce using rule 42 (expression -> term .)
    TIMES           shift and go to state 92
    DIVIDE          shift and go to state 93


state 46

    (53) term -> factor .

    TIMES           reduce using rule 53 (term -> factor .)
    DIVIDE          reduce using rule 53 (term -> factor .)
    PLUS            reduce using rule 53 (term -> factor .)
    MINUS           reduce using rule 53 (term -> factor .)
    AND             reduce using rule 53 (term -> factor .)
    OR              reduce using rule 53 (term -> factor .)
    EQ              reduce using rule 53 (term -> factor .)
    NE              reduce using rule 53 (term -> factor .)
    LT              reduce using rule 53 (term -> factor .)
    GT              reduce using rule 53 (term -> factor .)
    LE              reduce using rule 53 (term -> factor .)
    GE              reduce using rule 53 (term -> factor .)
    LBRACE          reduce using rule 53 (term -> factor .)
    VAR             reduce using rule 53 (term -> factor .)
    VARIABLE        reduce using rule 53 (term -> factor .)
    FMT             reduce using rule 53 (term -> factor .)
    FUNC            reduce using rule 53 (term -> factor .)
    IF              reduce using rule 53 (term -> factor .)
    FOR             reduce using rule 53 (term -> factor .)
    TYPE            reduce using rule 53 (term -> factor .)
    SWITCH          reduce using rule 53 (term -> factor .)
    BREAK           reduce using rule 53 (term -> factor .)
    $end            reduce using rule 53 (term -> factor .)
    RBRACE          reduce using rule 53 (term -> factor .)
    CASE            reduce using rule 53 (term -> factor .)
    DEFAULT         reduce using rule 53 (term -> factor .)
    SEMICOLON       reduce using rule 53 (term -> factor .)
    COMMA           reduce using rule 53 (term -> factor .)
    RPAREN          reduce using rule 53 (term -> factor .)
    COLON           reduce using rule 53 (term -> factor .)


state 47

    (58) factor -> STRING .

    TIMES           reduce using rule 58 (factor -> STRING .)
    DIVIDE          reduce using rule 58 (factor -> STRING .)
    PLUS            reduce using rule 58 (factor -> STRING .)
    MINUS           reduce using rule 58 (factor -> STRING .)
    AND             reduce using rule 58 (factor -> STRING .)
    OR              reduce using rule 58 (factor -> STRING .)
    EQ              reduce using rule 58 (factor -> STRING .)
    NE              reduce using rule 58 (factor -> STRING .)
    LT              reduce using rule 58 (factor -> STRING .)
    GT              reduce using rule 58 (factor -> STRING .)
    LE              reduce using rule 58 (factor -> STRING .)
    GE              reduce using rule 58 (factor -> STRING .)
    LBRACE          reduce using rule 58 (factor -> STRING .)
    VAR             reduce using rule 58 (factor -> STRING .)
    VARIABLE        reduce using rule 58 (factor -> STRING .)
    FMT             reduce using rule 58 (factor -> STRING .)
    FUNC            reduce using rule 58 (factor -> STRING .)
    IF              reduce using rule 58 (factor -> STRING .)
    FOR             reduce using rule 58 (factor -> STRING .)
    TYPE            reduce using rule 58 (factor -> STRING .)
    SWITCH          reduce using rule 58 (factor -> STRING .)
    BREAK           reduce using rule 58 (factor -> STRING .)
    $end            reduce using rule 58 (factor -> STRING .)
    RBRACE          reduce using rule 58 (factor -> STRING .)
    CASE            reduce using rule 58 (factor -> STRING .)
    DEFAULT         reduce using rule 58 (factor -> STRING .)
    SEMICOLON       reduce using rule 58 (factor -> STRING .)
    COMMA           reduce using rule 58 (factor -> STRING .)
    RPAREN          reduce using rule 58 (factor -> STRING .)
    COLON           reduce using rule 58 (factor -> STRING .)


state 48

    (60) factor -> LPAREN . expression RPAREN
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 94
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 49

    (61) factor -> make_expr .

    TIMES           reduce using rule 61 (factor -> make_expr .)
    DIVIDE          reduce using rule 61 (factor -> make_expr .)
    PLUS            reduce using rule 61 (factor -> make_expr .)
    MINUS           reduce using rule 61 (factor -> make_expr .)
    AND             reduce using rule 61 (factor -> make_expr .)
    OR              reduce using rule 61 (factor -> make_expr .)
    EQ              reduce using rule 61 (factor -> make_expr .)
    NE              reduce using rule 61 (factor -> make_expr .)
    LT              reduce using rule 61 (factor -> make_expr .)
    GT              reduce using rule 61 (factor -> make_expr .)
    LE              reduce using rule 61 (factor -> make_expr .)
    GE              reduce using rule 61 (factor -> make_expr .)
    LBRACE          reduce using rule 61 (factor -> make_expr .)
    VAR             reduce using rule 61 (factor -> make_expr .)
    VARIABLE        reduce using rule 61 (factor -> make_expr .)
    FMT             reduce using rule 61 (factor -> make_expr .)
    FUNC            reduce using rule 61 (factor -> make_expr .)
    IF              reduce using rule 61 (factor -> make_expr .)
    FOR             reduce using rule 61 (factor -> make_expr .)
    TYPE            reduce using rule 61 (factor -> make_expr .)
    SWITCH          reduce using rule 61 (factor -> make_expr .)
    BREAK           reduce using rule 61 (factor -> make_expr .)
    $end            reduce using rule 61 (factor -> make_expr .)
    RBRACE          reduce using rule 61 (factor -> make_expr .)
    CASE            reduce using rule 61 (factor -> make_expr .)
    DEFAULT         reduce using rule 61 (factor -> make_expr .)
    SEMICOLON       reduce using rule 61 (factor -> make_expr .)
    COMMA           reduce using rule 61 (factor -> make_expr .)
    RPAREN          reduce using rule 61 (factor -> make_expr .)
    COLON           reduce using rule 61 (factor -> make_expr .)


state 50

    (62) factor -> struct_instance .

    TIMES           reduce using rule 62 (factor -> struct_instance .)
    DIVIDE          reduce using rule 62 (factor -> struct_instance .)
    PLUS            reduce using rule 62 (factor -> struct_instance .)
    MINUS           reduce using rule 62 (factor -> struct_instance .)
    AND             reduce using rule 62 (factor -> struct_instance .)
    OR              reduce using rule 62 (factor -> struct_instance .)
    EQ              reduce using rule 62 (factor -> struct_instance .)
    NE              reduce using rule 62 (factor -> struct_instance .)
    LT              reduce using rule 62 (factor -> struct_instance .)
    GT              reduce using rule 62 (factor -> struct_instance .)
    LE              reduce using rule 62 (factor -> struct_instance .)
    GE              reduce using rule 62 (factor -> struct_instance .)
    LBRACE          reduce using rule 62 (factor -> struct_instance .)
    VAR             reduce using rule 62 (factor -> struct_instance .)
    VARIABLE        reduce using rule 62 (factor -> struct_instance .)
    FMT             reduce using rule 62 (factor -> struct_instance .)
    FUNC            reduce using rule 62 (factor -> struct_instance .)
    IF              reduce using rule 62 (factor -> struct_instance .)
    FOR             reduce using rule 62 (factor -> struct_instance .)
    TYPE            reduce using rule 62 (factor -> struct_instance .)
    SWITCH          reduce using rule 62 (factor -> struct_instance .)
    BREAK           reduce using rule 62 (factor -> struct_instance .)
    $end            reduce using rule 62 (factor -> struct_instance .)
    RBRACE          reduce using rule 62 (factor -> struct_instance .)
    CASE            reduce using rule 62 (factor -> struct_instance .)
    DEFAULT         reduce using rule 62 (factor -> struct_instance .)
    SEMICOLON       reduce using rule 62 (factor -> struct_instance .)
    COMMA           reduce using rule 62 (factor -> struct_instance .)
    RPAREN          reduce using rule 62 (factor -> struct_instance .)
    COLON           reduce using rule 62 (factor -> struct_instance .)


state 51

    (95) make_expr -> MAKE . LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> MAKE . LPAREN LBRACKET RBRACKET type RPAREN

    LPAREN          shift and go to state 95


state 52

    (69) for_stmt -> FOR expression . block
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression
    (73) block -> . LBRACE program RBRACE

    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89
    LBRACE          shift and go to state 90

    block                          shift and go to state 96

state 53

    (70) for_stmt -> FOR assignment . SEMICOLON expression SEMICOLON for_update block

    SEMICOLON       shift and go to state 97


state 54

    (26) expression -> VARIABLE .
    (27) assignment -> VARIABLE . ASSIGN expression
    (28) assignment -> VARIABLE . ASIG expression
    (59) factor -> VARIABLE .
    (81) struct_instance -> VARIABLE . LBRACE struct_fields_values RBRACE

  ! reduce/reduce conflict for PLUS resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for MINUS resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for AND resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for OR resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for EQ resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for NE resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for LT resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for GT resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for LE resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for GE resolved using rule 26 (expression -> VARIABLE .)
  ! reduce/reduce conflict for LBRACE resolved using rule 26 (expression -> VARIABLE .)
  ! shift/reduce conflict for LBRACE resolved as shift
    PLUS            reduce using rule 26 (expression -> VARIABLE .)
    MINUS           reduce using rule 26 (expression -> VARIABLE .)
    AND             reduce using rule 26 (expression -> VARIABLE .)
    OR              reduce using rule 26 (expression -> VARIABLE .)
    EQ              reduce using rule 26 (expression -> VARIABLE .)
    NE              reduce using rule 26 (expression -> VARIABLE .)
    LT              reduce using rule 26 (expression -> VARIABLE .)
    GT              reduce using rule 26 (expression -> VARIABLE .)
    LE              reduce using rule 26 (expression -> VARIABLE .)
    GE              reduce using rule 26 (expression -> VARIABLE .)
    ASSIGN          shift and go to state 33
    ASIG            shift and go to state 98
    TIMES           reduce using rule 59 (factor -> VARIABLE .)
    DIVIDE          reduce using rule 59 (factor -> VARIABLE .)
    LBRACE          shift and go to state 91

  ! LBRACE          [ reduce using rule 26 (expression -> VARIABLE .) ]
  ! PLUS            [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! MINUS           [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! AND             [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! OR              [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! EQ              [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! NE              [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! LT              [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! GT              [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! LE              [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! GE              [ reduce using rule 59 (factor -> VARIABLE .) ]
  ! LBRACE          [ reduce using rule 59 (factor -> VARIABLE .) ]


state 55

    (76) struct_def -> TYPE VARIABLE . STRUCT LBRACE struct_fields RBRACE

    STRUCT          shift and go to state 99


state 56

    (85) switch_stmt -> SWITCH expression . LBRACE case_list RBRACE
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression

    LBRACE          shift and go to state 100
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89


state 57

    (86) switch_stmt -> SWITCH LBRACE . case_list RBRACE
    (87) case_list -> . case_clause
    (88) case_list -> . case_clause case_list
    (89) case_clause -> . CASE expression COLON program
    (90) case_clause -> . DEFAULT COLON program

    CASE            shift and go to state 103
    DEFAULT         shift and go to state 104

    case_list                      shift and go to state 101
    case_clause                    shift and go to state 102

state 58

    (22) declaration -> VAR VARIABLE type .
    (23) declaration -> VAR VARIABLE type . ASIG expression

    VAR             reduce using rule 22 (declaration -> VAR VARIABLE type .)
    VARIABLE        reduce using rule 22 (declaration -> VAR VARIABLE type .)
    FMT             reduce using rule 22 (declaration -> VAR VARIABLE type .)
    FUNC            reduce using rule 22 (declaration -> VAR VARIABLE type .)
    IF              reduce using rule 22 (declaration -> VAR VARIABLE type .)
    FOR             reduce using rule 22 (declaration -> VAR VARIABLE type .)
    TYPE            reduce using rule 22 (declaration -> VAR VARIABLE type .)
    SWITCH          reduce using rule 22 (declaration -> VAR VARIABLE type .)
    BREAK           reduce using rule 22 (declaration -> VAR VARIABLE type .)
    $end            reduce using rule 22 (declaration -> VAR VARIABLE type .)
    RBRACE          reduce using rule 22 (declaration -> VAR VARIABLE type .)
    CASE            reduce using rule 22 (declaration -> VAR VARIABLE type .)
    DEFAULT         reduce using rule 22 (declaration -> VAR VARIABLE type .)
    ASIG            shift and go to state 105


state 59

    (91) map_declaration -> VAR VARIABLE MAP . LBRACKET type RBRACKET type

    LBRACKET        shift and go to state 106


state 60

    (97) array_declaration -> VAR VARIABLE LBRACKET . NUMBER RBRACKET type
    (101) slice_declaration -> VAR VARIABLE LBRACKET . RBRACKET type

    NUMBER          shift and go to state 107
    RBRACKET        shift and go to state 108


state 61

    (63) type -> INT_TYPE .

    ASIG            reduce using rule 63 (type -> INT_TYPE .)
    VAR             reduce using rule 63 (type -> INT_TYPE .)
    VARIABLE        reduce using rule 63 (type -> INT_TYPE .)
    FMT             reduce using rule 63 (type -> INT_TYPE .)
    FUNC            reduce using rule 63 (type -> INT_TYPE .)
    IF              reduce using rule 63 (type -> INT_TYPE .)
    FOR             reduce using rule 63 (type -> INT_TYPE .)
    TYPE            reduce using rule 63 (type -> INT_TYPE .)
    SWITCH          reduce using rule 63 (type -> INT_TYPE .)
    BREAK           reduce using rule 63 (type -> INT_TYPE .)
    $end            reduce using rule 63 (type -> INT_TYPE .)
    RBRACE          reduce using rule 63 (type -> INT_TYPE .)
    CASE            reduce using rule 63 (type -> INT_TYPE .)
    DEFAULT         reduce using rule 63 (type -> INT_TYPE .)
    RBRACKET        reduce using rule 63 (type -> INT_TYPE .)
    LBRACE          reduce using rule 63 (type -> INT_TYPE .)
    COMMA           reduce using rule 63 (type -> INT_TYPE .)
    RPAREN          reduce using rule 63 (type -> INT_TYPE .)
    INT_TYPE        reduce using rule 63 (type -> INT_TYPE .)
    FLOAT64_TYPE    reduce using rule 63 (type -> INT_TYPE .)
    STRING_TYPE     reduce using rule 63 (type -> INT_TYPE .)
    BOOL_TYPE       reduce using rule 63 (type -> INT_TYPE .)


state 62

    (64) type -> FLOAT64_TYPE .

    ASIG            reduce using rule 64 (type -> FLOAT64_TYPE .)
    VAR             reduce using rule 64 (type -> FLOAT64_TYPE .)
    VARIABLE        reduce using rule 64 (type -> FLOAT64_TYPE .)
    FMT             reduce using rule 64 (type -> FLOAT64_TYPE .)
    FUNC            reduce using rule 64 (type -> FLOAT64_TYPE .)
    IF              reduce using rule 64 (type -> FLOAT64_TYPE .)
    FOR             reduce using rule 64 (type -> FLOAT64_TYPE .)
    TYPE            reduce using rule 64 (type -> FLOAT64_TYPE .)
    SWITCH          reduce using rule 64 (type -> FLOAT64_TYPE .)
    BREAK           reduce using rule 64 (type -> FLOAT64_TYPE .)
    $end            reduce using rule 64 (type -> FLOAT64_TYPE .)
    RBRACE          reduce using rule 64 (type -> FLOAT64_TYPE .)
    CASE            reduce using rule 64 (type -> FLOAT64_TYPE .)
    DEFAULT         reduce using rule 64 (type -> FLOAT64_TYPE .)
    RBRACKET        reduce using rule 64 (type -> FLOAT64_TYPE .)
    LBRACE          reduce using rule 64 (type -> FLOAT64_TYPE .)
    COMMA           reduce using rule 64 (type -> FLOAT64_TYPE .)
    RPAREN          reduce using rule 64 (type -> FLOAT64_TYPE .)
    INT_TYPE        reduce using rule 64 (type -> FLOAT64_TYPE .)
    FLOAT64_TYPE    reduce using rule 64 (type -> FLOAT64_TYPE .)
    STRING_TYPE     reduce using rule 64 (type -> FLOAT64_TYPE .)
    BOOL_TYPE       reduce using rule 64 (type -> FLOAT64_TYPE .)


state 63

    (65) type -> STRING_TYPE .

    ASIG            reduce using rule 65 (type -> STRING_TYPE .)
    VAR             reduce using rule 65 (type -> STRING_TYPE .)
    VARIABLE        reduce using rule 65 (type -> STRING_TYPE .)
    FMT             reduce using rule 65 (type -> STRING_TYPE .)
    FUNC            reduce using rule 65 (type -> STRING_TYPE .)
    IF              reduce using rule 65 (type -> STRING_TYPE .)
    FOR             reduce using rule 65 (type -> STRING_TYPE .)
    TYPE            reduce using rule 65 (type -> STRING_TYPE .)
    SWITCH          reduce using rule 65 (type -> STRING_TYPE .)
    BREAK           reduce using rule 65 (type -> STRING_TYPE .)
    $end            reduce using rule 65 (type -> STRING_TYPE .)
    RBRACE          reduce using rule 65 (type -> STRING_TYPE .)
    CASE            reduce using rule 65 (type -> STRING_TYPE .)
    DEFAULT         reduce using rule 65 (type -> STRING_TYPE .)
    RBRACKET        reduce using rule 65 (type -> STRING_TYPE .)
    LBRACE          reduce using rule 65 (type -> STRING_TYPE .)
    COMMA           reduce using rule 65 (type -> STRING_TYPE .)
    RPAREN          reduce using rule 65 (type -> STRING_TYPE .)
    INT_TYPE        reduce using rule 65 (type -> STRING_TYPE .)
    FLOAT64_TYPE    reduce using rule 65 (type -> STRING_TYPE .)
    STRING_TYPE     reduce using rule 65 (type -> STRING_TYPE .)
    BOOL_TYPE       reduce using rule 65 (type -> STRING_TYPE .)


state 64

    (66) type -> BOOL_TYPE .

    ASIG            reduce using rule 66 (type -> BOOL_TYPE .)
    VAR             reduce using rule 66 (type -> BOOL_TYPE .)
    VARIABLE        reduce using rule 66 (type -> BOOL_TYPE .)
    FMT             reduce using rule 66 (type -> BOOL_TYPE .)
    FUNC            reduce using rule 66 (type -> BOOL_TYPE .)
    IF              reduce using rule 66 (type -> BOOL_TYPE .)
    FOR             reduce using rule 66 (type -> BOOL_TYPE .)
    TYPE            reduce using rule 66 (type -> BOOL_TYPE .)
    SWITCH          reduce using rule 66 (type -> BOOL_TYPE .)
    BREAK           reduce using rule 66 (type -> BOOL_TYPE .)
    $end            reduce using rule 66 (type -> BOOL_TYPE .)
    RBRACE          reduce using rule 66 (type -> BOOL_TYPE .)
    CASE            reduce using rule 66 (type -> BOOL_TYPE .)
    DEFAULT         reduce using rule 66 (type -> BOOL_TYPE .)
    RBRACKET        reduce using rule 66 (type -> BOOL_TYPE .)
    LBRACE          reduce using rule 66 (type -> BOOL_TYPE .)
    COMMA           reduce using rule 66 (type -> BOOL_TYPE .)
    RPAREN          reduce using rule 66 (type -> BOOL_TYPE .)
    INT_TYPE        reduce using rule 66 (type -> BOOL_TYPE .)
    FLOAT64_TYPE    reduce using rule 66 (type -> BOOL_TYPE .)
    STRING_TYPE     reduce using rule 66 (type -> BOOL_TYPE .)
    BOOL_TYPE       reduce using rule 66 (type -> BOOL_TYPE .)


state 65

    (27) assignment -> VARIABLE ASSIGN expression .
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression

    VAR             reduce using rule 27 (assignment -> VARIABLE ASSIGN expression .)
    VARIABLE        reduce using rule 27 (assignment -> VARIABLE ASSIGN expression .)
    FMT             reduce using rule 27 (assignment -> VARIABLE ASSIGN expression .)
    FUNC            reduce using rule 27 (assignment -> VARIABLE ASSIGN expression .)
    IF              reduce using rule 27 (assignment -> VARIABLE ASSIGN expression .)
    FOR             reduce using rule 27 (assignment -> VARIABLE ASSIGN expression .)
    TYPE            reduce using rule 27 (assignment -> VARIABLE ASSIGN expression .)
    SWITCH          reduce using rule 27 (assignment -> VARIABLE ASSIGN expression .)
    BREAK           reduce using rule 27 (assignment -> VARIABLE ASSIGN expression .)
    $end            reduce using rule 27 (assignment -> VARIABLE ASSIGN expression .)
    RBRACE          reduce using rule 27 (assignment -> VARIABLE ASSIGN expression .)
    CASE            reduce using rule 27 (assignment -> VARIABLE ASSIGN expression .)
    DEFAULT         reduce using rule 27 (assignment -> VARIABLE ASSIGN expression .)
    SEMICOLON       reduce using rule 27 (assignment -> VARIABLE ASSIGN expression .)
    LBRACE          reduce using rule 27 (assignment -> VARIABLE ASSIGN expression .)
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89


state 66

    (28) assignment -> VARIABLE ASIG expression .
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression

    VAR             reduce using rule 28 (assignment -> VARIABLE ASIG expression .)
    VARIABLE        reduce using rule 28 (assignment -> VARIABLE ASIG expression .)
    FMT             reduce using rule 28 (assignment -> VARIABLE ASIG expression .)
    FUNC            reduce using rule 28 (assignment -> VARIABLE ASIG expression .)
    IF              reduce using rule 28 (assignment -> VARIABLE ASIG expression .)
    FOR             reduce using rule 28 (assignment -> VARIABLE ASIG expression .)
    TYPE            reduce using rule 28 (assignment -> VARIABLE ASIG expression .)
    SWITCH          reduce using rule 28 (assignment -> VARIABLE ASIG expression .)
    BREAK           reduce using rule 28 (assignment -> VARIABLE ASIG expression .)
    $end            reduce using rule 28 (assignment -> VARIABLE ASIG expression .)
    RBRACE          reduce using rule 28 (assignment -> VARIABLE ASIG expression .)
    CASE            reduce using rule 28 (assignment -> VARIABLE ASIG expression .)
    DEFAULT         reduce using rule 28 (assignment -> VARIABLE ASIG expression .)
    SEMICOLON       reduce using rule 28 (assignment -> VARIABLE ASIG expression .)
    LBRACE          reduce using rule 28 (assignment -> VARIABLE ASIG expression .)
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89


state 67

    (92) map_declaration -> VARIABLE ASIG MAP . LBRACKET type RBRACKET type

    LBRACKET        shift and go to state 109


state 68

    (98) array_declaration -> VARIABLE ASIG LBRACKET . NUMBER RBRACKET type LBRACE array_values RBRACE
    (102) slice_declaration -> VARIABLE ASIG LBRACKET . RBRACKET type LBRACE slice_values RBRACE

    NUMBER          shift and go to state 110
    RBRACKET        shift and go to state 111


state 69

    (93) make_stmt -> VARIABLE ASIG MAKE . LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) make_stmt -> VARIABLE ASIG MAKE . LPAREN LBRACKET RBRACKET type RPAREN
    (95) make_expr -> MAKE . LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> MAKE . LPAREN LBRACKET RBRACKET type RPAREN

    LPAREN          shift and go to state 112


state 70

    (105) new_stmt -> VARIABLE ASIG NEW . LPAREN VARIABLE RPAREN

    LPAREN          shift and go to state 113


state 71

    (35) func_call -> VARIABLE LPAREN arg_list . RPAREN

    RPAREN          shift and go to state 114


state 72

    (36) func_call -> VARIABLE LPAREN RPAREN .

    VAR             reduce using rule 36 (func_call -> VARIABLE LPAREN RPAREN .)
    VARIABLE        reduce using rule 36 (func_call -> VARIABLE LPAREN RPAREN .)
    FMT             reduce using rule 36 (func_call -> VARIABLE LPAREN RPAREN .)
    FUNC            reduce using rule 36 (func_call -> VARIABLE LPAREN RPAREN .)
    IF              reduce using rule 36 (func_call -> VARIABLE LPAREN RPAREN .)
    FOR             reduce using rule 36 (func_call -> VARIABLE LPAREN RPAREN .)
    TYPE            reduce using rule 36 (func_call -> VARIABLE LPAREN RPAREN .)
    SWITCH          reduce using rule 36 (func_call -> VARIABLE LPAREN RPAREN .)
    BREAK           reduce using rule 36 (func_call -> VARIABLE LPAREN RPAREN .)
    $end            reduce using rule 36 (func_call -> VARIABLE LPAREN RPAREN .)
    RBRACE          reduce using rule 36 (func_call -> VARIABLE LPAREN RPAREN .)
    CASE            reduce using rule 36 (func_call -> VARIABLE LPAREN RPAREN .)
    DEFAULT         reduce using rule 36 (func_call -> VARIABLE LPAREN RPAREN .)


state 73

    (40) arg_list -> expression .
    (41) arg_list -> expression . COMMA arg_list
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression

    RPAREN          reduce using rule 40 (arg_list -> expression .)
    COMMA           shift and go to state 115
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89


state 74

    (29) print_stmt -> FMT DOT PRINTF . LPAREN STRING COMMA expression RPAREN

    LPAREN          shift and go to state 116


state 75

    (30) print_stmt -> FMT DOT PRINTLN . LPAREN expression RPAREN

    LPAREN          shift and go to state 117


state 76

    (31) input_stmt -> FMT DOT SCANLN . LPAREN AMPER VARIABLE RPAREN

    LPAREN          shift and go to state 118


state 77

    (74) struct_method -> FUNC LPAREN VARIABLE . VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (75) struct_method -> FUNC LPAREN VARIABLE . VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE

    VARIABLE        shift and go to state 119


state 78

    (32) func_def -> FUNC VARIABLE LPAREN . param_list RPAREN type LBRACE program RBRACE
    (33) func_def -> FUNC VARIABLE LPAREN . RPAREN type LBRACE program RBRACE
    (34) func_no_params -> FUNC VARIABLE LPAREN . RPAREN block
    (37) param_list -> . param
    (38) param_list -> . param COMMA param_list
    (39) param -> . VARIABLE type

    RPAREN          shift and go to state 122
    VARIABLE        shift and go to state 120

    param_list                     shift and go to state 121
    param                          shift and go to state 123

state 79

    (67) if_stmt -> IF expression block .
    (68) if_stmt -> IF expression block . ELSE block

    VAR             reduce using rule 67 (if_stmt -> IF expression block .)
    VARIABLE        reduce using rule 67 (if_stmt -> IF expression block .)
    FMT             reduce using rule 67 (if_stmt -> IF expression block .)
    FUNC            reduce using rule 67 (if_stmt -> IF expression block .)
    IF              reduce using rule 67 (if_stmt -> IF expression block .)
    FOR             reduce using rule 67 (if_stmt -> IF expression block .)
    TYPE            reduce using rule 67 (if_stmt -> IF expression block .)
    SWITCH          reduce using rule 67 (if_stmt -> IF expression block .)
    BREAK           reduce using rule 67 (if_stmt -> IF expression block .)
    $end            reduce using rule 67 (if_stmt -> IF expression block .)
    RBRACE          reduce using rule 67 (if_stmt -> IF expression block .)
    CASE            reduce using rule 67 (if_stmt -> IF expression block .)
    DEFAULT         reduce using rule 67 (if_stmt -> IF expression block .)
    ELSE            shift and go to state 124


state 80

    (43) expression -> expression PLUS . term
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 126
    FLOAT           shift and go to state 127
    STRING          shift and go to state 47
    VARIABLE        shift and go to state 128
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    term                           shift and go to state 125
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 81

    (44) expression -> expression MINUS . term
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 126
    FLOAT           shift and go to state 127
    STRING          shift and go to state 47
    VARIABLE        shift and go to state 128
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    term                           shift and go to state 129
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 82

    (45) expression -> expression AND . expression
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 130
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 83

    (46) expression -> expression OR . expression
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 131
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 84

    (47) expression -> expression EQ . expression
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 132
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 85

    (48) expression -> expression NE . expression
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 133
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 86

    (49) expression -> expression LT . expression
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 134
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 87

    (50) expression -> expression GT . expression
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 135
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 88

    (51) expression -> expression LE . expression
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 136
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 89

    (52) expression -> expression GE . expression
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 137
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 90

    (73) block -> LBRACE . program RBRACE
    (1) program -> . statement
    (2) program -> . statement program
    (3) statement -> . declaration
    (4) statement -> . assignment
    (5) statement -> . print_stmt
    (6) statement -> . input_stmt
    (7) statement -> . struct_method
    (8) statement -> . func_def
    (9) statement -> . func_no_params
    (10) statement -> . func_call
    (11) statement -> . if_stmt
    (12) statement -> . for_stmt
    (13) statement -> . struct_def
    (14) statement -> . switch_stmt
    (15) statement -> . map_declaration
    (16) statement -> . array_declaration
    (17) statement -> . slice_declaration
    (18) statement -> . make_stmt
    (19) statement -> . new_stmt
    (20) statement -> . break_stmt
    (21) statement -> . increment_stmt
    (22) declaration -> . VAR VARIABLE type
    (23) declaration -> . VAR VARIABLE type ASIG expression
    (27) assignment -> . VARIABLE ASSIGN expression
    (28) assignment -> . VARIABLE ASIG expression
    (29) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (30) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (31) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (74) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (75) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (32) func_def -> . FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (33) func_def -> . FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (34) func_no_params -> . FUNC VARIABLE LPAREN RPAREN block
    (35) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (36) func_call -> . VARIABLE LPAREN RPAREN
    (67) if_stmt -> . IF expression block
    (68) if_stmt -> . IF expression block ELSE block
    (69) for_stmt -> . FOR expression block
    (70) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update block
    (76) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (85) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (86) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (91) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (92) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (97) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (98) array_declaration -> . VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (101) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (102) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (93) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (105) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (106) break_stmt -> . BREAK
    (107) increment_stmt -> . VARIABLE INCREMENT
    (108) increment_stmt -> . VARIABLE DECREMENT

    VAR             shift and go to state 22
    VARIABLE        shift and go to state 23
    FMT             shift and go to state 24
    FUNC            shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    TYPE            shift and go to state 28
    SWITCH          shift and go to state 29
    BREAK           shift and go to state 30

    program                        shift and go to state 138
    statement                      shift and go to state 2
    declaration                    shift and go to state 3
    assignment                     shift and go to state 4
    print_stmt                     shift and go to state 5
    input_stmt                     shift and go to state 6
    struct_method                  shift and go to state 7
    func_def                       shift and go to state 8
    func_no_params                 shift and go to state 9
    func_call                      shift and go to state 10
    if_stmt                        shift and go to state 11
    for_stmt                       shift and go to state 12
    struct_def                     shift and go to state 13
    switch_stmt                    shift and go to state 14
    map_declaration                shift and go to state 15
    array_declaration              shift and go to state 16
    slice_declaration              shift and go to state 17
    make_stmt                      shift and go to state 18
    new_stmt                       shift and go to state 19
    break_stmt                     shift and go to state 20
    increment_stmt                 shift and go to state 21

state 91

    (81) struct_instance -> VARIABLE LBRACE . struct_fields_values RBRACE
    (82) struct_fields_values -> . field_value
    (83) struct_fields_values -> . field_value COMMA struct_fields_values
    (84) field_value -> . VARIABLE COLON expression

    VARIABLE        shift and go to state 139

    struct_fields_values           shift and go to state 140
    field_value                    shift and go to state 141

state 92

    (54) term -> term TIMES . factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 126
    FLOAT           shift and go to state 127
    STRING          shift and go to state 47
    VARIABLE        shift and go to state 128
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    factor                         shift and go to state 142
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 93

    (55) term -> term DIVIDE . factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 126
    FLOAT           shift and go to state 127
    STRING          shift and go to state 47
    VARIABLE        shift and go to state 128
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    factor                         shift and go to state 143
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 94

    (60) factor -> LPAREN expression . RPAREN
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression

    RPAREN          shift and go to state 144
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89


state 95

    (95) make_expr -> MAKE LPAREN . MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> MAKE LPAREN . LBRACKET RBRACKET type RPAREN

    MAP             shift and go to state 145
    LBRACKET        shift and go to state 146


state 96

    (69) for_stmt -> FOR expression block .

    VAR             reduce using rule 69 (for_stmt -> FOR expression block .)
    VARIABLE        reduce using rule 69 (for_stmt -> FOR expression block .)
    FMT             reduce using rule 69 (for_stmt -> FOR expression block .)
    FUNC            reduce using rule 69 (for_stmt -> FOR expression block .)
    IF              reduce using rule 69 (for_stmt -> FOR expression block .)
    FOR             reduce using rule 69 (for_stmt -> FOR expression block .)
    TYPE            reduce using rule 69 (for_stmt -> FOR expression block .)
    SWITCH          reduce using rule 69 (for_stmt -> FOR expression block .)
    BREAK           reduce using rule 69 (for_stmt -> FOR expression block .)
    $end            reduce using rule 69 (for_stmt -> FOR expression block .)
    RBRACE          reduce using rule 69 (for_stmt -> FOR expression block .)
    CASE            reduce using rule 69 (for_stmt -> FOR expression block .)
    DEFAULT         reduce using rule 69 (for_stmt -> FOR expression block .)


state 97

    (70) for_stmt -> FOR assignment SEMICOLON . expression SEMICOLON for_update block
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 147
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 98

    (28) assignment -> VARIABLE ASIG . expression
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 66
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 99

    (76) struct_def -> TYPE VARIABLE STRUCT . LBRACE struct_fields RBRACE

    LBRACE          shift and go to state 148


state 100

    (85) switch_stmt -> SWITCH expression LBRACE . case_list RBRACE
    (87) case_list -> . case_clause
    (88) case_list -> . case_clause case_list
    (89) case_clause -> . CASE expression COLON program
    (90) case_clause -> . DEFAULT COLON program

    CASE            shift and go to state 103
    DEFAULT         shift and go to state 104

    case_list                      shift and go to state 149
    case_clause                    shift and go to state 102

state 101

    (86) switch_stmt -> SWITCH LBRACE case_list . RBRACE

    RBRACE          shift and go to state 150


state 102

    (87) case_list -> case_clause .
    (88) case_list -> case_clause . case_list
    (87) case_list -> . case_clause
    (88) case_list -> . case_clause case_list
    (89) case_clause -> . CASE expression COLON program
    (90) case_clause -> . DEFAULT COLON program

    RBRACE          reduce using rule 87 (case_list -> case_clause .)
    CASE            shift and go to state 103
    DEFAULT         shift and go to state 104

    case_clause                    shift and go to state 102
    case_list                      shift and go to state 151

state 103

    (89) case_clause -> CASE . expression COLON program
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 152
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 104

    (90) case_clause -> DEFAULT . COLON program

    COLON           shift and go to state 153


state 105

    (23) declaration -> VAR VARIABLE type ASIG . expression
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 154
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 106

    (91) map_declaration -> VAR VARIABLE MAP LBRACKET . type RBRACKET type
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64

    type                           shift and go to state 155

state 107

    (97) array_declaration -> VAR VARIABLE LBRACKET NUMBER . RBRACKET type

    RBRACKET        shift and go to state 156


state 108

    (101) slice_declaration -> VAR VARIABLE LBRACKET RBRACKET . type
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64

    type                           shift and go to state 157

state 109

    (92) map_declaration -> VARIABLE ASIG MAP LBRACKET . type RBRACKET type
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64

    type                           shift and go to state 158

state 110

    (98) array_declaration -> VARIABLE ASIG LBRACKET NUMBER . RBRACKET type LBRACE array_values RBRACE

    RBRACKET        shift and go to state 159


state 111

    (102) slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET . type LBRACE slice_values RBRACE
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64

    type                           shift and go to state 160

state 112

    (93) make_stmt -> VARIABLE ASIG MAKE LPAREN . MAP LBRACKET type RBRACKET type RPAREN
    (94) make_stmt -> VARIABLE ASIG MAKE LPAREN . LBRACKET RBRACKET type RPAREN
    (95) make_expr -> MAKE LPAREN . MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> MAKE LPAREN . LBRACKET RBRACKET type RPAREN

    MAP             shift and go to state 161
    LBRACKET        shift and go to state 162


state 113

    (105) new_stmt -> VARIABLE ASIG NEW LPAREN . VARIABLE RPAREN

    VARIABLE        shift and go to state 163


state 114

    (35) func_call -> VARIABLE LPAREN arg_list RPAREN .

    VAR             reduce using rule 35 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    VARIABLE        reduce using rule 35 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    FMT             reduce using rule 35 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    FUNC            reduce using rule 35 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    IF              reduce using rule 35 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    FOR             reduce using rule 35 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    TYPE            reduce using rule 35 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    SWITCH          reduce using rule 35 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    BREAK           reduce using rule 35 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    $end            reduce using rule 35 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    RBRACE          reduce using rule 35 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    CASE            reduce using rule 35 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    DEFAULT         reduce using rule 35 (func_call -> VARIABLE LPAREN arg_list RPAREN .)


state 115

    (41) arg_list -> expression COMMA . arg_list
    (40) arg_list -> . expression
    (41) arg_list -> . expression COMMA arg_list
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 73
    arg_list                       shift and go to state 164
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 116

    (29) print_stmt -> FMT DOT PRINTF LPAREN . STRING COMMA expression RPAREN

    STRING          shift and go to state 165


state 117

    (30) print_stmt -> FMT DOT PRINTLN LPAREN . expression RPAREN
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 166
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 118

    (31) input_stmt -> FMT DOT SCANLN LPAREN . AMPER VARIABLE RPAREN

    AMPER           shift and go to state 167


state 119

    (74) struct_method -> FUNC LPAREN VARIABLE VARIABLE . RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (75) struct_method -> FUNC LPAREN VARIABLE VARIABLE . RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE

    RPAREN          shift and go to state 168


state 120

    (39) param -> VARIABLE . type
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64

    type                           shift and go to state 169

state 121

    (32) func_def -> FUNC VARIABLE LPAREN param_list . RPAREN type LBRACE program RBRACE

    RPAREN          shift and go to state 170


state 122

    (33) func_def -> FUNC VARIABLE LPAREN RPAREN . type LBRACE program RBRACE
    (34) func_no_params -> FUNC VARIABLE LPAREN RPAREN . block
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE
    (73) block -> . LBRACE program RBRACE

    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64
    LBRACE          shift and go to state 90

    type                           shift and go to state 171
    block                          shift and go to state 172

state 123

    (37) param_list -> param .
    (38) param_list -> param . COMMA param_list

    RPAREN          reduce using rule 37 (param_list -> param .)
    COMMA           shift and go to state 173


state 124

    (68) if_stmt -> IF expression block ELSE . block
    (73) block -> . LBRACE program RBRACE

    LBRACE          shift and go to state 90

    block                          shift and go to state 174

state 125

    (43) expression -> expression PLUS term .
    (54) term -> term . TIMES factor
    (55) term -> term . DIVIDE factor

    PLUS            reduce using rule 43 (expression -> expression PLUS term .)
    MINUS           reduce using rule 43 (expression -> expression PLUS term .)
    AND             reduce using rule 43 (expression -> expression PLUS term .)
    OR              reduce using rule 43 (expression -> expression PLUS term .)
    EQ              reduce using rule 43 (expression -> expression PLUS term .)
    NE              reduce using rule 43 (expression -> expression PLUS term .)
    LT              reduce using rule 43 (expression -> expression PLUS term .)
    GT              reduce using rule 43 (expression -> expression PLUS term .)
    LE              reduce using rule 43 (expression -> expression PLUS term .)
    GE              reduce using rule 43 (expression -> expression PLUS term .)
    LBRACE          reduce using rule 43 (expression -> expression PLUS term .)
    VAR             reduce using rule 43 (expression -> expression PLUS term .)
    VARIABLE        reduce using rule 43 (expression -> expression PLUS term .)
    FMT             reduce using rule 43 (expression -> expression PLUS term .)
    FUNC            reduce using rule 43 (expression -> expression PLUS term .)
    IF              reduce using rule 43 (expression -> expression PLUS term .)
    FOR             reduce using rule 43 (expression -> expression PLUS term .)
    TYPE            reduce using rule 43 (expression -> expression PLUS term .)
    SWITCH          reduce using rule 43 (expression -> expression PLUS term .)
    BREAK           reduce using rule 43 (expression -> expression PLUS term .)
    $end            reduce using rule 43 (expression -> expression PLUS term .)
    RBRACE          reduce using rule 43 (expression -> expression PLUS term .)
    CASE            reduce using rule 43 (expression -> expression PLUS term .)
    DEFAULT         reduce using rule 43 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 43 (expression -> expression PLUS term .)
    COMMA           reduce using rule 43 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 43 (expression -> expression PLUS term .)
    COLON           reduce using rule 43 (expression -> expression PLUS term .)
    TIMES           shift and go to state 92
    DIVIDE          shift and go to state 93


state 126

    (56) factor -> NUMBER .

    TIMES           reduce using rule 56 (factor -> NUMBER .)
    DIVIDE          reduce using rule 56 (factor -> NUMBER .)
    PLUS            reduce using rule 56 (factor -> NUMBER .)
    MINUS           reduce using rule 56 (factor -> NUMBER .)
    AND             reduce using rule 56 (factor -> NUMBER .)
    OR              reduce using rule 56 (factor -> NUMBER .)
    EQ              reduce using rule 56 (factor -> NUMBER .)
    NE              reduce using rule 56 (factor -> NUMBER .)
    LT              reduce using rule 56 (factor -> NUMBER .)
    GT              reduce using rule 56 (factor -> NUMBER .)
    LE              reduce using rule 56 (factor -> NUMBER .)
    GE              reduce using rule 56 (factor -> NUMBER .)
    LBRACE          reduce using rule 56 (factor -> NUMBER .)
    VAR             reduce using rule 56 (factor -> NUMBER .)
    VARIABLE        reduce using rule 56 (factor -> NUMBER .)
    FMT             reduce using rule 56 (factor -> NUMBER .)
    FUNC            reduce using rule 56 (factor -> NUMBER .)
    IF              reduce using rule 56 (factor -> NUMBER .)
    FOR             reduce using rule 56 (factor -> NUMBER .)
    TYPE            reduce using rule 56 (factor -> NUMBER .)
    SWITCH          reduce using rule 56 (factor -> NUMBER .)
    BREAK           reduce using rule 56 (factor -> NUMBER .)
    $end            reduce using rule 56 (factor -> NUMBER .)
    RBRACE          reduce using rule 56 (factor -> NUMBER .)
    CASE            reduce using rule 56 (factor -> NUMBER .)
    DEFAULT         reduce using rule 56 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 56 (factor -> NUMBER .)
    COMMA           reduce using rule 56 (factor -> NUMBER .)
    RPAREN          reduce using rule 56 (factor -> NUMBER .)
    COLON           reduce using rule 56 (factor -> NUMBER .)


state 127

    (57) factor -> FLOAT .

    TIMES           reduce using rule 57 (factor -> FLOAT .)
    DIVIDE          reduce using rule 57 (factor -> FLOAT .)
    PLUS            reduce using rule 57 (factor -> FLOAT .)
    MINUS           reduce using rule 57 (factor -> FLOAT .)
    AND             reduce using rule 57 (factor -> FLOAT .)
    OR              reduce using rule 57 (factor -> FLOAT .)
    EQ              reduce using rule 57 (factor -> FLOAT .)
    NE              reduce using rule 57 (factor -> FLOAT .)
    LT              reduce using rule 57 (factor -> FLOAT .)
    GT              reduce using rule 57 (factor -> FLOAT .)
    LE              reduce using rule 57 (factor -> FLOAT .)
    GE              reduce using rule 57 (factor -> FLOAT .)
    LBRACE          reduce using rule 57 (factor -> FLOAT .)
    VAR             reduce using rule 57 (factor -> FLOAT .)
    VARIABLE        reduce using rule 57 (factor -> FLOAT .)
    FMT             reduce using rule 57 (factor -> FLOAT .)
    FUNC            reduce using rule 57 (factor -> FLOAT .)
    IF              reduce using rule 57 (factor -> FLOAT .)
    FOR             reduce using rule 57 (factor -> FLOAT .)
    TYPE            reduce using rule 57 (factor -> FLOAT .)
    SWITCH          reduce using rule 57 (factor -> FLOAT .)
    BREAK           reduce using rule 57 (factor -> FLOAT .)
    $end            reduce using rule 57 (factor -> FLOAT .)
    RBRACE          reduce using rule 57 (factor -> FLOAT .)
    CASE            reduce using rule 57 (factor -> FLOAT .)
    DEFAULT         reduce using rule 57 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 57 (factor -> FLOAT .)
    COMMA           reduce using rule 57 (factor -> FLOAT .)
    RPAREN          reduce using rule 57 (factor -> FLOAT .)
    COLON           reduce using rule 57 (factor -> FLOAT .)


state 128

    (59) factor -> VARIABLE .
    (81) struct_instance -> VARIABLE . LBRACE struct_fields_values RBRACE

  ! shift/reduce conflict for LBRACE resolved as shift
    TIMES           reduce using rule 59 (factor -> VARIABLE .)
    DIVIDE          reduce using rule 59 (factor -> VARIABLE .)
    PLUS            reduce using rule 59 (factor -> VARIABLE .)
    MINUS           reduce using rule 59 (factor -> VARIABLE .)
    AND             reduce using rule 59 (factor -> VARIABLE .)
    OR              reduce using rule 59 (factor -> VARIABLE .)
    EQ              reduce using rule 59 (factor -> VARIABLE .)
    NE              reduce using rule 59 (factor -> VARIABLE .)
    LT              reduce using rule 59 (factor -> VARIABLE .)
    GT              reduce using rule 59 (factor -> VARIABLE .)
    LE              reduce using rule 59 (factor -> VARIABLE .)
    GE              reduce using rule 59 (factor -> VARIABLE .)
    VAR             reduce using rule 59 (factor -> VARIABLE .)
    VARIABLE        reduce using rule 59 (factor -> VARIABLE .)
    FMT             reduce using rule 59 (factor -> VARIABLE .)
    FUNC            reduce using rule 59 (factor -> VARIABLE .)
    IF              reduce using rule 59 (factor -> VARIABLE .)
    FOR             reduce using rule 59 (factor -> VARIABLE .)
    TYPE            reduce using rule 59 (factor -> VARIABLE .)
    SWITCH          reduce using rule 59 (factor -> VARIABLE .)
    BREAK           reduce using rule 59 (factor -> VARIABLE .)
    $end            reduce using rule 59 (factor -> VARIABLE .)
    RBRACE          reduce using rule 59 (factor -> VARIABLE .)
    CASE            reduce using rule 59 (factor -> VARIABLE .)
    DEFAULT         reduce using rule 59 (factor -> VARIABLE .)
    SEMICOLON       reduce using rule 59 (factor -> VARIABLE .)
    COMMA           reduce using rule 59 (factor -> VARIABLE .)
    RPAREN          reduce using rule 59 (factor -> VARIABLE .)
    COLON           reduce using rule 59 (factor -> VARIABLE .)
    LBRACE          shift and go to state 91

  ! LBRACE          [ reduce using rule 59 (factor -> VARIABLE .) ]


state 129

    (44) expression -> expression MINUS term .
    (54) term -> term . TIMES factor
    (55) term -> term . DIVIDE factor

    PLUS            reduce using rule 44 (expression -> expression MINUS term .)
    MINUS           reduce using rule 44 (expression -> expression MINUS term .)
    AND             reduce using rule 44 (expression -> expression MINUS term .)
    OR              reduce using rule 44 (expression -> expression MINUS term .)
    EQ              reduce using rule 44 (expression -> expression MINUS term .)
    NE              reduce using rule 44 (expression -> expression MINUS term .)
    LT              reduce using rule 44 (expression -> expression MINUS term .)
    GT              reduce using rule 44 (expression -> expression MINUS term .)
    LE              reduce using rule 44 (expression -> expression MINUS term .)
    GE              reduce using rule 44 (expression -> expression MINUS term .)
    LBRACE          reduce using rule 44 (expression -> expression MINUS term .)
    VAR             reduce using rule 44 (expression -> expression MINUS term .)
    VARIABLE        reduce using rule 44 (expression -> expression MINUS term .)
    FMT             reduce using rule 44 (expression -> expression MINUS term .)
    FUNC            reduce using rule 44 (expression -> expression MINUS term .)
    IF              reduce using rule 44 (expression -> expression MINUS term .)
    FOR             reduce using rule 44 (expression -> expression MINUS term .)
    TYPE            reduce using rule 44 (expression -> expression MINUS term .)
    SWITCH          reduce using rule 44 (expression -> expression MINUS term .)
    BREAK           reduce using rule 44 (expression -> expression MINUS term .)
    $end            reduce using rule 44 (expression -> expression MINUS term .)
    RBRACE          reduce using rule 44 (expression -> expression MINUS term .)
    CASE            reduce using rule 44 (expression -> expression MINUS term .)
    DEFAULT         reduce using rule 44 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 44 (expression -> expression MINUS term .)
    COMMA           reduce using rule 44 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 44 (expression -> expression MINUS term .)
    COLON           reduce using rule 44 (expression -> expression MINUS term .)
    TIMES           shift and go to state 92
    DIVIDE          shift and go to state 93


state 130

    (45) expression -> expression AND expression .
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 45 (expression -> expression AND expression .)
    VAR             reduce using rule 45 (expression -> expression AND expression .)
    VARIABLE        reduce using rule 45 (expression -> expression AND expression .)
    FMT             reduce using rule 45 (expression -> expression AND expression .)
    FUNC            reduce using rule 45 (expression -> expression AND expression .)
    IF              reduce using rule 45 (expression -> expression AND expression .)
    FOR             reduce using rule 45 (expression -> expression AND expression .)
    TYPE            reduce using rule 45 (expression -> expression AND expression .)
    SWITCH          reduce using rule 45 (expression -> expression AND expression .)
    BREAK           reduce using rule 45 (expression -> expression AND expression .)
    $end            reduce using rule 45 (expression -> expression AND expression .)
    RBRACE          reduce using rule 45 (expression -> expression AND expression .)
    CASE            reduce using rule 45 (expression -> expression AND expression .)
    DEFAULT         reduce using rule 45 (expression -> expression AND expression .)
    SEMICOLON       reduce using rule 45 (expression -> expression AND expression .)
    COMMA           reduce using rule 45 (expression -> expression AND expression .)
    RPAREN          reduce using rule 45 (expression -> expression AND expression .)
    COLON           reduce using rule 45 (expression -> expression AND expression .)
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89

  ! PLUS            [ reduce using rule 45 (expression -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 45 (expression -> expression AND expression .) ]
  ! AND             [ reduce using rule 45 (expression -> expression AND expression .) ]
  ! OR              [ reduce using rule 45 (expression -> expression AND expression .) ]
  ! EQ              [ reduce using rule 45 (expression -> expression AND expression .) ]
  ! NE              [ reduce using rule 45 (expression -> expression AND expression .) ]
  ! LT              [ reduce using rule 45 (expression -> expression AND expression .) ]
  ! GT              [ reduce using rule 45 (expression -> expression AND expression .) ]
  ! LE              [ reduce using rule 45 (expression -> expression AND expression .) ]
  ! GE              [ reduce using rule 45 (expression -> expression AND expression .) ]


state 131

    (46) expression -> expression OR expression .
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 46 (expression -> expression OR expression .)
    VAR             reduce using rule 46 (expression -> expression OR expression .)
    VARIABLE        reduce using rule 46 (expression -> expression OR expression .)
    FMT             reduce using rule 46 (expression -> expression OR expression .)
    FUNC            reduce using rule 46 (expression -> expression OR expression .)
    IF              reduce using rule 46 (expression -> expression OR expression .)
    FOR             reduce using rule 46 (expression -> expression OR expression .)
    TYPE            reduce using rule 46 (expression -> expression OR expression .)
    SWITCH          reduce using rule 46 (expression -> expression OR expression .)
    BREAK           reduce using rule 46 (expression -> expression OR expression .)
    $end            reduce using rule 46 (expression -> expression OR expression .)
    RBRACE          reduce using rule 46 (expression -> expression OR expression .)
    CASE            reduce using rule 46 (expression -> expression OR expression .)
    DEFAULT         reduce using rule 46 (expression -> expression OR expression .)
    SEMICOLON       reduce using rule 46 (expression -> expression OR expression .)
    COMMA           reduce using rule 46 (expression -> expression OR expression .)
    RPAREN          reduce using rule 46 (expression -> expression OR expression .)
    COLON           reduce using rule 46 (expression -> expression OR expression .)
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89

  ! PLUS            [ reduce using rule 46 (expression -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 46 (expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 46 (expression -> expression OR expression .) ]
  ! OR              [ reduce using rule 46 (expression -> expression OR expression .) ]
  ! EQ              [ reduce using rule 46 (expression -> expression OR expression .) ]
  ! NE              [ reduce using rule 46 (expression -> expression OR expression .) ]
  ! LT              [ reduce using rule 46 (expression -> expression OR expression .) ]
  ! GT              [ reduce using rule 46 (expression -> expression OR expression .) ]
  ! LE              [ reduce using rule 46 (expression -> expression OR expression .) ]
  ! GE              [ reduce using rule 46 (expression -> expression OR expression .) ]


state 132

    (47) expression -> expression EQ expression .
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 47 (expression -> expression EQ expression .)
    VAR             reduce using rule 47 (expression -> expression EQ expression .)
    VARIABLE        reduce using rule 47 (expression -> expression EQ expression .)
    FMT             reduce using rule 47 (expression -> expression EQ expression .)
    FUNC            reduce using rule 47 (expression -> expression EQ expression .)
    IF              reduce using rule 47 (expression -> expression EQ expression .)
    FOR             reduce using rule 47 (expression -> expression EQ expression .)
    TYPE            reduce using rule 47 (expression -> expression EQ expression .)
    SWITCH          reduce using rule 47 (expression -> expression EQ expression .)
    BREAK           reduce using rule 47 (expression -> expression EQ expression .)
    $end            reduce using rule 47 (expression -> expression EQ expression .)
    RBRACE          reduce using rule 47 (expression -> expression EQ expression .)
    CASE            reduce using rule 47 (expression -> expression EQ expression .)
    DEFAULT         reduce using rule 47 (expression -> expression EQ expression .)
    SEMICOLON       reduce using rule 47 (expression -> expression EQ expression .)
    COMMA           reduce using rule 47 (expression -> expression EQ expression .)
    RPAREN          reduce using rule 47 (expression -> expression EQ expression .)
    COLON           reduce using rule 47 (expression -> expression EQ expression .)
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89

  ! PLUS            [ reduce using rule 47 (expression -> expression EQ expression .) ]
  ! MINUS           [ reduce using rule 47 (expression -> expression EQ expression .) ]
  ! AND             [ reduce using rule 47 (expression -> expression EQ expression .) ]
  ! OR              [ reduce using rule 47 (expression -> expression EQ expression .) ]
  ! EQ              [ reduce using rule 47 (expression -> expression EQ expression .) ]
  ! NE              [ reduce using rule 47 (expression -> expression EQ expression .) ]
  ! LT              [ reduce using rule 47 (expression -> expression EQ expression .) ]
  ! GT              [ reduce using rule 47 (expression -> expression EQ expression .) ]
  ! LE              [ reduce using rule 47 (expression -> expression EQ expression .) ]
  ! GE              [ reduce using rule 47 (expression -> expression EQ expression .) ]


state 133

    (48) expression -> expression NE expression .
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 48 (expression -> expression NE expression .)
    VAR             reduce using rule 48 (expression -> expression NE expression .)
    VARIABLE        reduce using rule 48 (expression -> expression NE expression .)
    FMT             reduce using rule 48 (expression -> expression NE expression .)
    FUNC            reduce using rule 48 (expression -> expression NE expression .)
    IF              reduce using rule 48 (expression -> expression NE expression .)
    FOR             reduce using rule 48 (expression -> expression NE expression .)
    TYPE            reduce using rule 48 (expression -> expression NE expression .)
    SWITCH          reduce using rule 48 (expression -> expression NE expression .)
    BREAK           reduce using rule 48 (expression -> expression NE expression .)
    $end            reduce using rule 48 (expression -> expression NE expression .)
    RBRACE          reduce using rule 48 (expression -> expression NE expression .)
    CASE            reduce using rule 48 (expression -> expression NE expression .)
    DEFAULT         reduce using rule 48 (expression -> expression NE expression .)
    SEMICOLON       reduce using rule 48 (expression -> expression NE expression .)
    COMMA           reduce using rule 48 (expression -> expression NE expression .)
    RPAREN          reduce using rule 48 (expression -> expression NE expression .)
    COLON           reduce using rule 48 (expression -> expression NE expression .)
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89

  ! PLUS            [ reduce using rule 48 (expression -> expression NE expression .) ]
  ! MINUS           [ reduce using rule 48 (expression -> expression NE expression .) ]
  ! AND             [ reduce using rule 48 (expression -> expression NE expression .) ]
  ! OR              [ reduce using rule 48 (expression -> expression NE expression .) ]
  ! EQ              [ reduce using rule 48 (expression -> expression NE expression .) ]
  ! NE              [ reduce using rule 48 (expression -> expression NE expression .) ]
  ! LT              [ reduce using rule 48 (expression -> expression NE expression .) ]
  ! GT              [ reduce using rule 48 (expression -> expression NE expression .) ]
  ! LE              [ reduce using rule 48 (expression -> expression NE expression .) ]
  ! GE              [ reduce using rule 48 (expression -> expression NE expression .) ]


state 134

    (49) expression -> expression LT expression .
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 49 (expression -> expression LT expression .)
    VAR             reduce using rule 49 (expression -> expression LT expression .)
    VARIABLE        reduce using rule 49 (expression -> expression LT expression .)
    FMT             reduce using rule 49 (expression -> expression LT expression .)
    FUNC            reduce using rule 49 (expression -> expression LT expression .)
    IF              reduce using rule 49 (expression -> expression LT expression .)
    FOR             reduce using rule 49 (expression -> expression LT expression .)
    TYPE            reduce using rule 49 (expression -> expression LT expression .)
    SWITCH          reduce using rule 49 (expression -> expression LT expression .)
    BREAK           reduce using rule 49 (expression -> expression LT expression .)
    $end            reduce using rule 49 (expression -> expression LT expression .)
    RBRACE          reduce using rule 49 (expression -> expression LT expression .)
    CASE            reduce using rule 49 (expression -> expression LT expression .)
    DEFAULT         reduce using rule 49 (expression -> expression LT expression .)
    SEMICOLON       reduce using rule 49 (expression -> expression LT expression .)
    COMMA           reduce using rule 49 (expression -> expression LT expression .)
    RPAREN          reduce using rule 49 (expression -> expression LT expression .)
    COLON           reduce using rule 49 (expression -> expression LT expression .)
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89

  ! PLUS            [ reduce using rule 49 (expression -> expression LT expression .) ]
  ! MINUS           [ reduce using rule 49 (expression -> expression LT expression .) ]
  ! AND             [ reduce using rule 49 (expression -> expression LT expression .) ]
  ! OR              [ reduce using rule 49 (expression -> expression LT expression .) ]
  ! EQ              [ reduce using rule 49 (expression -> expression LT expression .) ]
  ! NE              [ reduce using rule 49 (expression -> expression LT expression .) ]
  ! LT              [ reduce using rule 49 (expression -> expression LT expression .) ]
  ! GT              [ reduce using rule 49 (expression -> expression LT expression .) ]
  ! LE              [ reduce using rule 49 (expression -> expression LT expression .) ]
  ! GE              [ reduce using rule 49 (expression -> expression LT expression .) ]


state 135

    (50) expression -> expression GT expression .
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 50 (expression -> expression GT expression .)
    VAR             reduce using rule 50 (expression -> expression GT expression .)
    VARIABLE        reduce using rule 50 (expression -> expression GT expression .)
    FMT             reduce using rule 50 (expression -> expression GT expression .)
    FUNC            reduce using rule 50 (expression -> expression GT expression .)
    IF              reduce using rule 50 (expression -> expression GT expression .)
    FOR             reduce using rule 50 (expression -> expression GT expression .)
    TYPE            reduce using rule 50 (expression -> expression GT expression .)
    SWITCH          reduce using rule 50 (expression -> expression GT expression .)
    BREAK           reduce using rule 50 (expression -> expression GT expression .)
    $end            reduce using rule 50 (expression -> expression GT expression .)
    RBRACE          reduce using rule 50 (expression -> expression GT expression .)
    CASE            reduce using rule 50 (expression -> expression GT expression .)
    DEFAULT         reduce using rule 50 (expression -> expression GT expression .)
    SEMICOLON       reduce using rule 50 (expression -> expression GT expression .)
    COMMA           reduce using rule 50 (expression -> expression GT expression .)
    RPAREN          reduce using rule 50 (expression -> expression GT expression .)
    COLON           reduce using rule 50 (expression -> expression GT expression .)
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89

  ! PLUS            [ reduce using rule 50 (expression -> expression GT expression .) ]
  ! MINUS           [ reduce using rule 50 (expression -> expression GT expression .) ]
  ! AND             [ reduce using rule 50 (expression -> expression GT expression .) ]
  ! OR              [ reduce using rule 50 (expression -> expression GT expression .) ]
  ! EQ              [ reduce using rule 50 (expression -> expression GT expression .) ]
  ! NE              [ reduce using rule 50 (expression -> expression GT expression .) ]
  ! LT              [ reduce using rule 50 (expression -> expression GT expression .) ]
  ! GT              [ reduce using rule 50 (expression -> expression GT expression .) ]
  ! LE              [ reduce using rule 50 (expression -> expression GT expression .) ]
  ! GE              [ reduce using rule 50 (expression -> expression GT expression .) ]


state 136

    (51) expression -> expression LE expression .
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 51 (expression -> expression LE expression .)
    VAR             reduce using rule 51 (expression -> expression LE expression .)
    VARIABLE        reduce using rule 51 (expression -> expression LE expression .)
    FMT             reduce using rule 51 (expression -> expression LE expression .)
    FUNC            reduce using rule 51 (expression -> expression LE expression .)
    IF              reduce using rule 51 (expression -> expression LE expression .)
    FOR             reduce using rule 51 (expression -> expression LE expression .)
    TYPE            reduce using rule 51 (expression -> expression LE expression .)
    SWITCH          reduce using rule 51 (expression -> expression LE expression .)
    BREAK           reduce using rule 51 (expression -> expression LE expression .)
    $end            reduce using rule 51 (expression -> expression LE expression .)
    RBRACE          reduce using rule 51 (expression -> expression LE expression .)
    CASE            reduce using rule 51 (expression -> expression LE expression .)
    DEFAULT         reduce using rule 51 (expression -> expression LE expression .)
    SEMICOLON       reduce using rule 51 (expression -> expression LE expression .)
    COMMA           reduce using rule 51 (expression -> expression LE expression .)
    RPAREN          reduce using rule 51 (expression -> expression LE expression .)
    COLON           reduce using rule 51 (expression -> expression LE expression .)
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89

  ! PLUS            [ reduce using rule 51 (expression -> expression LE expression .) ]
  ! MINUS           [ reduce using rule 51 (expression -> expression LE expression .) ]
  ! AND             [ reduce using rule 51 (expression -> expression LE expression .) ]
  ! OR              [ reduce using rule 51 (expression -> expression LE expression .) ]
  ! EQ              [ reduce using rule 51 (expression -> expression LE expression .) ]
  ! NE              [ reduce using rule 51 (expression -> expression LE expression .) ]
  ! LT              [ reduce using rule 51 (expression -> expression LE expression .) ]
  ! GT              [ reduce using rule 51 (expression -> expression LE expression .) ]
  ! LE              [ reduce using rule 51 (expression -> expression LE expression .) ]
  ! GE              [ reduce using rule 51 (expression -> expression LE expression .) ]


state 137

    (52) expression -> expression GE expression .
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 52 (expression -> expression GE expression .)
    VAR             reduce using rule 52 (expression -> expression GE expression .)
    VARIABLE        reduce using rule 52 (expression -> expression GE expression .)
    FMT             reduce using rule 52 (expression -> expression GE expression .)
    FUNC            reduce using rule 52 (expression -> expression GE expression .)
    IF              reduce using rule 52 (expression -> expression GE expression .)
    FOR             reduce using rule 52 (expression -> expression GE expression .)
    TYPE            reduce using rule 52 (expression -> expression GE expression .)
    SWITCH          reduce using rule 52 (expression -> expression GE expression .)
    BREAK           reduce using rule 52 (expression -> expression GE expression .)
    $end            reduce using rule 52 (expression -> expression GE expression .)
    RBRACE          reduce using rule 52 (expression -> expression GE expression .)
    CASE            reduce using rule 52 (expression -> expression GE expression .)
    DEFAULT         reduce using rule 52 (expression -> expression GE expression .)
    SEMICOLON       reduce using rule 52 (expression -> expression GE expression .)
    COMMA           reduce using rule 52 (expression -> expression GE expression .)
    RPAREN          reduce using rule 52 (expression -> expression GE expression .)
    COLON           reduce using rule 52 (expression -> expression GE expression .)
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89

  ! PLUS            [ reduce using rule 52 (expression -> expression GE expression .) ]
  ! MINUS           [ reduce using rule 52 (expression -> expression GE expression .) ]
  ! AND             [ reduce using rule 52 (expression -> expression GE expression .) ]
  ! OR              [ reduce using rule 52 (expression -> expression GE expression .) ]
  ! EQ              [ reduce using rule 52 (expression -> expression GE expression .) ]
  ! NE              [ reduce using rule 52 (expression -> expression GE expression .) ]
  ! LT              [ reduce using rule 52 (expression -> expression GE expression .) ]
  ! GT              [ reduce using rule 52 (expression -> expression GE expression .) ]
  ! LE              [ reduce using rule 52 (expression -> expression GE expression .) ]
  ! GE              [ reduce using rule 52 (expression -> expression GE expression .) ]


state 138

    (73) block -> LBRACE program . RBRACE

    RBRACE          shift and go to state 175


state 139

    (84) field_value -> VARIABLE . COLON expression

    COLON           shift and go to state 176


state 140

    (81) struct_instance -> VARIABLE LBRACE struct_fields_values . RBRACE

    RBRACE          shift and go to state 177


state 141

    (82) struct_fields_values -> field_value .
    (83) struct_fields_values -> field_value . COMMA struct_fields_values

    RBRACE          reduce using rule 82 (struct_fields_values -> field_value .)
    COMMA           shift and go to state 178


state 142

    (54) term -> term TIMES factor .

    TIMES           reduce using rule 54 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 54 (term -> term TIMES factor .)
    PLUS            reduce using rule 54 (term -> term TIMES factor .)
    MINUS           reduce using rule 54 (term -> term TIMES factor .)
    AND             reduce using rule 54 (term -> term TIMES factor .)
    OR              reduce using rule 54 (term -> term TIMES factor .)
    EQ              reduce using rule 54 (term -> term TIMES factor .)
    NE              reduce using rule 54 (term -> term TIMES factor .)
    LT              reduce using rule 54 (term -> term TIMES factor .)
    GT              reduce using rule 54 (term -> term TIMES factor .)
    LE              reduce using rule 54 (term -> term TIMES factor .)
    GE              reduce using rule 54 (term -> term TIMES factor .)
    LBRACE          reduce using rule 54 (term -> term TIMES factor .)
    VAR             reduce using rule 54 (term -> term TIMES factor .)
    VARIABLE        reduce using rule 54 (term -> term TIMES factor .)
    FMT             reduce using rule 54 (term -> term TIMES factor .)
    FUNC            reduce using rule 54 (term -> term TIMES factor .)
    IF              reduce using rule 54 (term -> term TIMES factor .)
    FOR             reduce using rule 54 (term -> term TIMES factor .)
    TYPE            reduce using rule 54 (term -> term TIMES factor .)
    SWITCH          reduce using rule 54 (term -> term TIMES factor .)
    BREAK           reduce using rule 54 (term -> term TIMES factor .)
    $end            reduce using rule 54 (term -> term TIMES factor .)
    RBRACE          reduce using rule 54 (term -> term TIMES factor .)
    CASE            reduce using rule 54 (term -> term TIMES factor .)
    DEFAULT         reduce using rule 54 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 54 (term -> term TIMES factor .)
    COMMA           reduce using rule 54 (term -> term TIMES factor .)
    RPAREN          reduce using rule 54 (term -> term TIMES factor .)
    COLON           reduce using rule 54 (term -> term TIMES factor .)


state 143

    (55) term -> term DIVIDE factor .

    TIMES           reduce using rule 55 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 55 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 55 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 55 (term -> term DIVIDE factor .)
    AND             reduce using rule 55 (term -> term DIVIDE factor .)
    OR              reduce using rule 55 (term -> term DIVIDE factor .)
    EQ              reduce using rule 55 (term -> term DIVIDE factor .)
    NE              reduce using rule 55 (term -> term DIVIDE factor .)
    LT              reduce using rule 55 (term -> term DIVIDE factor .)
    GT              reduce using rule 55 (term -> term DIVIDE factor .)
    LE              reduce using rule 55 (term -> term DIVIDE factor .)
    GE              reduce using rule 55 (term -> term DIVIDE factor .)
    LBRACE          reduce using rule 55 (term -> term DIVIDE factor .)
    VAR             reduce using rule 55 (term -> term DIVIDE factor .)
    VARIABLE        reduce using rule 55 (term -> term DIVIDE factor .)
    FMT             reduce using rule 55 (term -> term DIVIDE factor .)
    FUNC            reduce using rule 55 (term -> term DIVIDE factor .)
    IF              reduce using rule 55 (term -> term DIVIDE factor .)
    FOR             reduce using rule 55 (term -> term DIVIDE factor .)
    TYPE            reduce using rule 55 (term -> term DIVIDE factor .)
    SWITCH          reduce using rule 55 (term -> term DIVIDE factor .)
    BREAK           reduce using rule 55 (term -> term DIVIDE factor .)
    $end            reduce using rule 55 (term -> term DIVIDE factor .)
    RBRACE          reduce using rule 55 (term -> term DIVIDE factor .)
    CASE            reduce using rule 55 (term -> term DIVIDE factor .)
    DEFAULT         reduce using rule 55 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 55 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 55 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 55 (term -> term DIVIDE factor .)
    COLON           reduce using rule 55 (term -> term DIVIDE factor .)


state 144

    (60) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    EQ              reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    NE              reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    LE              reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    GE              reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    LBRACE          reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    VAR             reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    VARIABLE        reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    FMT             reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    FUNC            reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    IF              reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    FOR             reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    TYPE            reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    SWITCH          reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    BREAK           reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    CASE            reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    DEFAULT         reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    COLON           reduce using rule 60 (factor -> LPAREN expression RPAREN .)


state 145

    (95) make_expr -> MAKE LPAREN MAP . LBRACKET type RBRACKET type RPAREN

    LBRACKET        shift and go to state 179


state 146

    (96) make_expr -> MAKE LPAREN LBRACKET . RBRACKET type RPAREN

    RBRACKET        shift and go to state 180


state 147

    (70) for_stmt -> FOR assignment SEMICOLON expression . SEMICOLON for_update block
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression

    SEMICOLON       shift and go to state 181
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89


state 148

    (76) struct_def -> TYPE VARIABLE STRUCT LBRACE . struct_fields RBRACE
    (77) struct_fields -> . struct_field
    (78) struct_fields -> . struct_field struct_fields
    (79) struct_field -> . VARIABLE type
    (80) struct_field -> . type
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE

    VARIABLE        shift and go to state 182
    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64

    struct_fields                  shift and go to state 183
    struct_field                   shift and go to state 184
    type                           shift and go to state 185

state 149

    (85) switch_stmt -> SWITCH expression LBRACE case_list . RBRACE

    RBRACE          shift and go to state 186


state 150

    (86) switch_stmt -> SWITCH LBRACE case_list RBRACE .

    VAR             reduce using rule 86 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    VARIABLE        reduce using rule 86 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    FMT             reduce using rule 86 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    FUNC            reduce using rule 86 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    IF              reduce using rule 86 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    FOR             reduce using rule 86 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    TYPE            reduce using rule 86 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    SWITCH          reduce using rule 86 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    BREAK           reduce using rule 86 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    $end            reduce using rule 86 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    RBRACE          reduce using rule 86 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    CASE            reduce using rule 86 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    DEFAULT         reduce using rule 86 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)


state 151

    (88) case_list -> case_clause case_list .

    RBRACE          reduce using rule 88 (case_list -> case_clause case_list .)


state 152

    (89) case_clause -> CASE expression . COLON program
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression

    COLON           shift and go to state 187
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89


state 153

    (90) case_clause -> DEFAULT COLON . program
    (1) program -> . statement
    (2) program -> . statement program
    (3) statement -> . declaration
    (4) statement -> . assignment
    (5) statement -> . print_stmt
    (6) statement -> . input_stmt
    (7) statement -> . struct_method
    (8) statement -> . func_def
    (9) statement -> . func_no_params
    (10) statement -> . func_call
    (11) statement -> . if_stmt
    (12) statement -> . for_stmt
    (13) statement -> . struct_def
    (14) statement -> . switch_stmt
    (15) statement -> . map_declaration
    (16) statement -> . array_declaration
    (17) statement -> . slice_declaration
    (18) statement -> . make_stmt
    (19) statement -> . new_stmt
    (20) statement -> . break_stmt
    (21) statement -> . increment_stmt
    (22) declaration -> . VAR VARIABLE type
    (23) declaration -> . VAR VARIABLE type ASIG expression
    (27) assignment -> . VARIABLE ASSIGN expression
    (28) assignment -> . VARIABLE ASIG expression
    (29) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (30) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (31) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (74) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (75) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (32) func_def -> . FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (33) func_def -> . FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (34) func_no_params -> . FUNC VARIABLE LPAREN RPAREN block
    (35) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (36) func_call -> . VARIABLE LPAREN RPAREN
    (67) if_stmt -> . IF expression block
    (68) if_stmt -> . IF expression block ELSE block
    (69) for_stmt -> . FOR expression block
    (70) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update block
    (76) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (85) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (86) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (91) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (92) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (97) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (98) array_declaration -> . VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (101) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (102) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (93) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (105) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (106) break_stmt -> . BREAK
    (107) increment_stmt -> . VARIABLE INCREMENT
    (108) increment_stmt -> . VARIABLE DECREMENT

    VAR             shift and go to state 22
    VARIABLE        shift and go to state 23
    FMT             shift and go to state 24
    FUNC            shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    TYPE            shift and go to state 28
    SWITCH          shift and go to state 29
    BREAK           shift and go to state 30

    program                        shift and go to state 188
    statement                      shift and go to state 2
    declaration                    shift and go to state 3
    assignment                     shift and go to state 4
    print_stmt                     shift and go to state 5
    input_stmt                     shift and go to state 6
    struct_method                  shift and go to state 7
    func_def                       shift and go to state 8
    func_no_params                 shift and go to state 9
    func_call                      shift and go to state 10
    if_stmt                        shift and go to state 11
    for_stmt                       shift and go to state 12
    struct_def                     shift and go to state 13
    switch_stmt                    shift and go to state 14
    map_declaration                shift and go to state 15
    array_declaration              shift and go to state 16
    slice_declaration              shift and go to state 17
    make_stmt                      shift and go to state 18
    new_stmt                       shift and go to state 19
    break_stmt                     shift and go to state 20
    increment_stmt                 shift and go to state 21

state 154

    (23) declaration -> VAR VARIABLE type ASIG expression .
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression

    VAR             reduce using rule 23 (declaration -> VAR VARIABLE type ASIG expression .)
    VARIABLE        reduce using rule 23 (declaration -> VAR VARIABLE type ASIG expression .)
    FMT             reduce using rule 23 (declaration -> VAR VARIABLE type ASIG expression .)
    FUNC            reduce using rule 23 (declaration -> VAR VARIABLE type ASIG expression .)
    IF              reduce using rule 23 (declaration -> VAR VARIABLE type ASIG expression .)
    FOR             reduce using rule 23 (declaration -> VAR VARIABLE type ASIG expression .)
    TYPE            reduce using rule 23 (declaration -> VAR VARIABLE type ASIG expression .)
    SWITCH          reduce using rule 23 (declaration -> VAR VARIABLE type ASIG expression .)
    BREAK           reduce using rule 23 (declaration -> VAR VARIABLE type ASIG expression .)
    $end            reduce using rule 23 (declaration -> VAR VARIABLE type ASIG expression .)
    RBRACE          reduce using rule 23 (declaration -> VAR VARIABLE type ASIG expression .)
    CASE            reduce using rule 23 (declaration -> VAR VARIABLE type ASIG expression .)
    DEFAULT         reduce using rule 23 (declaration -> VAR VARIABLE type ASIG expression .)
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89


state 155

    (91) map_declaration -> VAR VARIABLE MAP LBRACKET type . RBRACKET type

    RBRACKET        shift and go to state 189


state 156

    (97) array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET . type
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64

    type                           shift and go to state 190

state 157

    (101) slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .

    VAR             reduce using rule 101 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    VARIABLE        reduce using rule 101 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    FMT             reduce using rule 101 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    FUNC            reduce using rule 101 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    IF              reduce using rule 101 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    FOR             reduce using rule 101 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    TYPE            reduce using rule 101 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    SWITCH          reduce using rule 101 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    BREAK           reduce using rule 101 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    $end            reduce using rule 101 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    RBRACE          reduce using rule 101 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    CASE            reduce using rule 101 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    DEFAULT         reduce using rule 101 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)


state 158

    (92) map_declaration -> VARIABLE ASIG MAP LBRACKET type . RBRACKET type

    RBRACKET        shift and go to state 191


state 159

    (98) array_declaration -> VARIABLE ASIG LBRACKET NUMBER RBRACKET . type LBRACE array_values RBRACE
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64

    type                           shift and go to state 192

state 160

    (102) slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type . LBRACE slice_values RBRACE

    LBRACE          shift and go to state 193


state 161

    (93) make_stmt -> VARIABLE ASIG MAKE LPAREN MAP . LBRACKET type RBRACKET type RPAREN
    (95) make_expr -> MAKE LPAREN MAP . LBRACKET type RBRACKET type RPAREN

    LBRACKET        shift and go to state 194


state 162

    (94) make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET . RBRACKET type RPAREN
    (96) make_expr -> MAKE LPAREN LBRACKET . RBRACKET type RPAREN

    RBRACKET        shift and go to state 195


state 163

    (105) new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE . RPAREN

    RPAREN          shift and go to state 196


state 164

    (41) arg_list -> expression COMMA arg_list .

    RPAREN          reduce using rule 41 (arg_list -> expression COMMA arg_list .)


state 165

    (29) print_stmt -> FMT DOT PRINTF LPAREN STRING . COMMA expression RPAREN

    COMMA           shift and go to state 197


state 166

    (30) print_stmt -> FMT DOT PRINTLN LPAREN expression . RPAREN
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression

    RPAREN          shift and go to state 198
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89


state 167

    (31) input_stmt -> FMT DOT SCANLN LPAREN AMPER . VARIABLE RPAREN

    VARIABLE        shift and go to state 199


state 168

    (74) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN . VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (75) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN . VARIABLE LPAREN RPAREN type LBRACE program RBRACE

    VARIABLE        shift and go to state 200


state 169

    (39) param -> VARIABLE type .

    COMMA           reduce using rule 39 (param -> VARIABLE type .)
    RPAREN          reduce using rule 39 (param -> VARIABLE type .)


state 170

    (32) func_def -> FUNC VARIABLE LPAREN param_list RPAREN . type LBRACE program RBRACE
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64

    type                           shift and go to state 201

state 171

    (33) func_def -> FUNC VARIABLE LPAREN RPAREN type . LBRACE program RBRACE

    LBRACE          shift and go to state 202


state 172

    (34) func_no_params -> FUNC VARIABLE LPAREN RPAREN block .

    VAR             reduce using rule 34 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    VARIABLE        reduce using rule 34 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    FMT             reduce using rule 34 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    FUNC            reduce using rule 34 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    IF              reduce using rule 34 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    FOR             reduce using rule 34 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    TYPE            reduce using rule 34 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    SWITCH          reduce using rule 34 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    BREAK           reduce using rule 34 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    $end            reduce using rule 34 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    RBRACE          reduce using rule 34 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    CASE            reduce using rule 34 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    DEFAULT         reduce using rule 34 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)


state 173

    (38) param_list -> param COMMA . param_list
    (37) param_list -> . param
    (38) param_list -> . param COMMA param_list
    (39) param -> . VARIABLE type

    VARIABLE        shift and go to state 120

    param                          shift and go to state 123
    param_list                     shift and go to state 203

state 174

    (68) if_stmt -> IF expression block ELSE block .

    VAR             reduce using rule 68 (if_stmt -> IF expression block ELSE block .)
    VARIABLE        reduce using rule 68 (if_stmt -> IF expression block ELSE block .)
    FMT             reduce using rule 68 (if_stmt -> IF expression block ELSE block .)
    FUNC            reduce using rule 68 (if_stmt -> IF expression block ELSE block .)
    IF              reduce using rule 68 (if_stmt -> IF expression block ELSE block .)
    FOR             reduce using rule 68 (if_stmt -> IF expression block ELSE block .)
    TYPE            reduce using rule 68 (if_stmt -> IF expression block ELSE block .)
    SWITCH          reduce using rule 68 (if_stmt -> IF expression block ELSE block .)
    BREAK           reduce using rule 68 (if_stmt -> IF expression block ELSE block .)
    $end            reduce using rule 68 (if_stmt -> IF expression block ELSE block .)
    RBRACE          reduce using rule 68 (if_stmt -> IF expression block ELSE block .)
    CASE            reduce using rule 68 (if_stmt -> IF expression block ELSE block .)
    DEFAULT         reduce using rule 68 (if_stmt -> IF expression block ELSE block .)


state 175

    (73) block -> LBRACE program RBRACE .

    ELSE            reduce using rule 73 (block -> LBRACE program RBRACE .)
    VAR             reduce using rule 73 (block -> LBRACE program RBRACE .)
    VARIABLE        reduce using rule 73 (block -> LBRACE program RBRACE .)
    FMT             reduce using rule 73 (block -> LBRACE program RBRACE .)
    FUNC            reduce using rule 73 (block -> LBRACE program RBRACE .)
    IF              reduce using rule 73 (block -> LBRACE program RBRACE .)
    FOR             reduce using rule 73 (block -> LBRACE program RBRACE .)
    TYPE            reduce using rule 73 (block -> LBRACE program RBRACE .)
    SWITCH          reduce using rule 73 (block -> LBRACE program RBRACE .)
    BREAK           reduce using rule 73 (block -> LBRACE program RBRACE .)
    $end            reduce using rule 73 (block -> LBRACE program RBRACE .)
    RBRACE          reduce using rule 73 (block -> LBRACE program RBRACE .)
    CASE            reduce using rule 73 (block -> LBRACE program RBRACE .)
    DEFAULT         reduce using rule 73 (block -> LBRACE program RBRACE .)


state 176

    (84) field_value -> VARIABLE COLON . expression
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 204
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 177

    (81) struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .

    TIMES           reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    DIVIDE          reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    PLUS            reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    MINUS           reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    AND             reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    OR              reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    EQ              reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    NE              reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    LT              reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    GT              reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    LE              reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    GE              reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    LBRACE          reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    VAR             reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    VARIABLE        reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    FMT             reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    FUNC            reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    IF              reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    FOR             reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    TYPE            reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    SWITCH          reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    BREAK           reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    $end            reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    RBRACE          reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    CASE            reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    DEFAULT         reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    SEMICOLON       reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    COMMA           reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    RPAREN          reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    COLON           reduce using rule 81 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)


state 178

    (83) struct_fields_values -> field_value COMMA . struct_fields_values
    (82) struct_fields_values -> . field_value
    (83) struct_fields_values -> . field_value COMMA struct_fields_values
    (84) field_value -> . VARIABLE COLON expression

    VARIABLE        shift and go to state 139

    field_value                    shift and go to state 141
    struct_fields_values           shift and go to state 205

state 179

    (95) make_expr -> MAKE LPAREN MAP LBRACKET . type RBRACKET type RPAREN
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64

    type                           shift and go to state 206

state 180

    (96) make_expr -> MAKE LPAREN LBRACKET RBRACKET . type RPAREN
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64

    type                           shift and go to state 207

state 181

    (70) for_stmt -> FOR assignment SEMICOLON expression SEMICOLON . for_update block
    (71) for_update -> . assignment
    (72) for_update -> . increment_stmt
    (27) assignment -> . VARIABLE ASSIGN expression
    (28) assignment -> . VARIABLE ASIG expression
    (107) increment_stmt -> . VARIABLE INCREMENT
    (108) increment_stmt -> . VARIABLE DECREMENT

    VARIABLE        shift and go to state 211

    assignment                     shift and go to state 208
    for_update                     shift and go to state 209
    increment_stmt                 shift and go to state 210

state 182

    (79) struct_field -> VARIABLE . type
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64

    type                           shift and go to state 212

state 183

    (76) struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields . RBRACE

    RBRACE          shift and go to state 213


state 184

    (77) struct_fields -> struct_field .
    (78) struct_fields -> struct_field . struct_fields
    (77) struct_fields -> . struct_field
    (78) struct_fields -> . struct_field struct_fields
    (79) struct_field -> . VARIABLE type
    (80) struct_field -> . type
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE

    RBRACE          reduce using rule 77 (struct_fields -> struct_field .)
    VARIABLE        shift and go to state 182
    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64

    struct_field                   shift and go to state 184
    struct_fields                  shift and go to state 214
    type                           shift and go to state 185

state 185

    (80) struct_field -> type .

    VARIABLE        reduce using rule 80 (struct_field -> type .)
    INT_TYPE        reduce using rule 80 (struct_field -> type .)
    FLOAT64_TYPE    reduce using rule 80 (struct_field -> type .)
    STRING_TYPE     reduce using rule 80 (struct_field -> type .)
    BOOL_TYPE       reduce using rule 80 (struct_field -> type .)
    RBRACE          reduce using rule 80 (struct_field -> type .)


state 186

    (85) switch_stmt -> SWITCH expression LBRACE case_list RBRACE .

    VAR             reduce using rule 85 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    VARIABLE        reduce using rule 85 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    FMT             reduce using rule 85 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    FUNC            reduce using rule 85 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    IF              reduce using rule 85 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    FOR             reduce using rule 85 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    TYPE            reduce using rule 85 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    SWITCH          reduce using rule 85 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    BREAK           reduce using rule 85 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    $end            reduce using rule 85 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    RBRACE          reduce using rule 85 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    CASE            reduce using rule 85 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    DEFAULT         reduce using rule 85 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)


state 187

    (89) case_clause -> CASE expression COLON . program
    (1) program -> . statement
    (2) program -> . statement program
    (3) statement -> . declaration
    (4) statement -> . assignment
    (5) statement -> . print_stmt
    (6) statement -> . input_stmt
    (7) statement -> . struct_method
    (8) statement -> . func_def
    (9) statement -> . func_no_params
    (10) statement -> . func_call
    (11) statement -> . if_stmt
    (12) statement -> . for_stmt
    (13) statement -> . struct_def
    (14) statement -> . switch_stmt
    (15) statement -> . map_declaration
    (16) statement -> . array_declaration
    (17) statement -> . slice_declaration
    (18) statement -> . make_stmt
    (19) statement -> . new_stmt
    (20) statement -> . break_stmt
    (21) statement -> . increment_stmt
    (22) declaration -> . VAR VARIABLE type
    (23) declaration -> . VAR VARIABLE type ASIG expression
    (27) assignment -> . VARIABLE ASSIGN expression
    (28) assignment -> . VARIABLE ASIG expression
    (29) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (30) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (31) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (74) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (75) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (32) func_def -> . FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (33) func_def -> . FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (34) func_no_params -> . FUNC VARIABLE LPAREN RPAREN block
    (35) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (36) func_call -> . VARIABLE LPAREN RPAREN
    (67) if_stmt -> . IF expression block
    (68) if_stmt -> . IF expression block ELSE block
    (69) for_stmt -> . FOR expression block
    (70) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update block
    (76) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (85) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (86) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (91) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (92) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (97) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (98) array_declaration -> . VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (101) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (102) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (93) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (105) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (106) break_stmt -> . BREAK
    (107) increment_stmt -> . VARIABLE INCREMENT
    (108) increment_stmt -> . VARIABLE DECREMENT

    VAR             shift and go to state 22
    VARIABLE        shift and go to state 23
    FMT             shift and go to state 24
    FUNC            shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    TYPE            shift and go to state 28
    SWITCH          shift and go to state 29
    BREAK           shift and go to state 30

    program                        shift and go to state 215
    statement                      shift and go to state 2
    declaration                    shift and go to state 3
    assignment                     shift and go to state 4
    print_stmt                     shift and go to state 5
    input_stmt                     shift and go to state 6
    struct_method                  shift and go to state 7
    func_def                       shift and go to state 8
    func_no_params                 shift and go to state 9
    func_call                      shift and go to state 10
    if_stmt                        shift and go to state 11
    for_stmt                       shift and go to state 12
    struct_def                     shift and go to state 13
    switch_stmt                    shift and go to state 14
    map_declaration                shift and go to state 15
    array_declaration              shift and go to state 16
    slice_declaration              shift and go to state 17
    make_stmt                      shift and go to state 18
    new_stmt                       shift and go to state 19
    break_stmt                     shift and go to state 20
    increment_stmt                 shift and go to state 21

state 188

    (90) case_clause -> DEFAULT COLON program .

    CASE            reduce using rule 90 (case_clause -> DEFAULT COLON program .)
    DEFAULT         reduce using rule 90 (case_clause -> DEFAULT COLON program .)
    RBRACE          reduce using rule 90 (case_clause -> DEFAULT COLON program .)


state 189

    (91) map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET . type
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64

    type                           shift and go to state 216

state 190

    (97) array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .

    VAR             reduce using rule 97 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    VARIABLE        reduce using rule 97 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    FMT             reduce using rule 97 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    FUNC            reduce using rule 97 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    IF              reduce using rule 97 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    FOR             reduce using rule 97 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    TYPE            reduce using rule 97 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    SWITCH          reduce using rule 97 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    BREAK           reduce using rule 97 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    $end            reduce using rule 97 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    RBRACE          reduce using rule 97 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    CASE            reduce using rule 97 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    DEFAULT         reduce using rule 97 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)


state 191

    (92) map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET . type
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64

    type                           shift and go to state 217

state 192

    (98) array_declaration -> VARIABLE ASIG LBRACKET NUMBER RBRACKET type . LBRACE array_values RBRACE

    LBRACE          shift and go to state 218


state 193

    (102) slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE . slice_values RBRACE
    (103) slice_values -> . expression
    (104) slice_values -> . expression COMMA slice_values
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    slice_values                   shift and go to state 219
    expression                     shift and go to state 220
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 194

    (93) make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET . type RBRACKET type RPAREN
    (95) make_expr -> MAKE LPAREN MAP LBRACKET . type RBRACKET type RPAREN
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64

    type                           shift and go to state 221

state 195

    (94) make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET . type RPAREN
    (96) make_expr -> MAKE LPAREN LBRACKET RBRACKET . type RPAREN
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64

    type                           shift and go to state 222

state 196

    (105) new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .

    VAR             reduce using rule 105 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    VARIABLE        reduce using rule 105 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    FMT             reduce using rule 105 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    FUNC            reduce using rule 105 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    IF              reduce using rule 105 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    FOR             reduce using rule 105 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    TYPE            reduce using rule 105 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    SWITCH          reduce using rule 105 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    BREAK           reduce using rule 105 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    $end            reduce using rule 105 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    RBRACE          reduce using rule 105 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    CASE            reduce using rule 105 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    DEFAULT         reduce using rule 105 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)


state 197

    (29) print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA . expression RPAREN
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 223
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 198

    (30) print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .

    VAR             reduce using rule 30 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    VARIABLE        reduce using rule 30 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    FMT             reduce using rule 30 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    FUNC            reduce using rule 30 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    IF              reduce using rule 30 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    FOR             reduce using rule 30 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    TYPE            reduce using rule 30 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    SWITCH          reduce using rule 30 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    BREAK           reduce using rule 30 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    $end            reduce using rule 30 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    RBRACE          reduce using rule 30 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    CASE            reduce using rule 30 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    DEFAULT         reduce using rule 30 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)


state 199

    (31) input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE . RPAREN

    RPAREN          shift and go to state 224


state 200

    (74) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE . LPAREN param_list RPAREN type LBRACE program RBRACE
    (75) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE . LPAREN RPAREN type LBRACE program RBRACE

    LPAREN          shift and go to state 225


state 201

    (32) func_def -> FUNC VARIABLE LPAREN param_list RPAREN type . LBRACE program RBRACE

    LBRACE          shift and go to state 226


state 202

    (33) func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE . program RBRACE
    (1) program -> . statement
    (2) program -> . statement program
    (3) statement -> . declaration
    (4) statement -> . assignment
    (5) statement -> . print_stmt
    (6) statement -> . input_stmt
    (7) statement -> . struct_method
    (8) statement -> . func_def
    (9) statement -> . func_no_params
    (10) statement -> . func_call
    (11) statement -> . if_stmt
    (12) statement -> . for_stmt
    (13) statement -> . struct_def
    (14) statement -> . switch_stmt
    (15) statement -> . map_declaration
    (16) statement -> . array_declaration
    (17) statement -> . slice_declaration
    (18) statement -> . make_stmt
    (19) statement -> . new_stmt
    (20) statement -> . break_stmt
    (21) statement -> . increment_stmt
    (22) declaration -> . VAR VARIABLE type
    (23) declaration -> . VAR VARIABLE type ASIG expression
    (27) assignment -> . VARIABLE ASSIGN expression
    (28) assignment -> . VARIABLE ASIG expression
    (29) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (30) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (31) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (74) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (75) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (32) func_def -> . FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (33) func_def -> . FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (34) func_no_params -> . FUNC VARIABLE LPAREN RPAREN block
    (35) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (36) func_call -> . VARIABLE LPAREN RPAREN
    (67) if_stmt -> . IF expression block
    (68) if_stmt -> . IF expression block ELSE block
    (69) for_stmt -> . FOR expression block
    (70) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update block
    (76) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (85) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (86) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (91) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (92) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (97) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (98) array_declaration -> . VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (101) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (102) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (93) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (105) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (106) break_stmt -> . BREAK
    (107) increment_stmt -> . VARIABLE INCREMENT
    (108) increment_stmt -> . VARIABLE DECREMENT

    VAR             shift and go to state 22
    VARIABLE        shift and go to state 23
    FMT             shift and go to state 24
    FUNC            shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    TYPE            shift and go to state 28
    SWITCH          shift and go to state 29
    BREAK           shift and go to state 30

    program                        shift and go to state 227
    statement                      shift and go to state 2
    declaration                    shift and go to state 3
    assignment                     shift and go to state 4
    print_stmt                     shift and go to state 5
    input_stmt                     shift and go to state 6
    struct_method                  shift and go to state 7
    func_def                       shift and go to state 8
    func_no_params                 shift and go to state 9
    func_call                      shift and go to state 10
    if_stmt                        shift and go to state 11
    for_stmt                       shift and go to state 12
    struct_def                     shift and go to state 13
    switch_stmt                    shift and go to state 14
    map_declaration                shift and go to state 15
    array_declaration              shift and go to state 16
    slice_declaration              shift and go to state 17
    make_stmt                      shift and go to state 18
    new_stmt                       shift and go to state 19
    break_stmt                     shift and go to state 20
    increment_stmt                 shift and go to state 21

state 203

    (38) param_list -> param COMMA param_list .

    RPAREN          reduce using rule 38 (param_list -> param COMMA param_list .)


state 204

    (84) field_value -> VARIABLE COLON expression .
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression

    COMMA           reduce using rule 84 (field_value -> VARIABLE COLON expression .)
    RBRACE          reduce using rule 84 (field_value -> VARIABLE COLON expression .)
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89


state 205

    (83) struct_fields_values -> field_value COMMA struct_fields_values .

    RBRACE          reduce using rule 83 (struct_fields_values -> field_value COMMA struct_fields_values .)


state 206

    (95) make_expr -> MAKE LPAREN MAP LBRACKET type . RBRACKET type RPAREN

    RBRACKET        shift and go to state 228


state 207

    (96) make_expr -> MAKE LPAREN LBRACKET RBRACKET type . RPAREN

    RPAREN          shift and go to state 229


state 208

    (71) for_update -> assignment .

    LBRACE          reduce using rule 71 (for_update -> assignment .)


state 209

    (70) for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update . block
    (73) block -> . LBRACE program RBRACE

    LBRACE          shift and go to state 90

    block                          shift and go to state 230

state 210

    (72) for_update -> increment_stmt .

    LBRACE          reduce using rule 72 (for_update -> increment_stmt .)


state 211

    (27) assignment -> VARIABLE . ASSIGN expression
    (28) assignment -> VARIABLE . ASIG expression
    (107) increment_stmt -> VARIABLE . INCREMENT
    (108) increment_stmt -> VARIABLE . DECREMENT

    ASSIGN          shift and go to state 33
    ASIG            shift and go to state 98
    INCREMENT       shift and go to state 36
    DECREMENT       shift and go to state 37


state 212

    (79) struct_field -> VARIABLE type .

    VARIABLE        reduce using rule 79 (struct_field -> VARIABLE type .)
    INT_TYPE        reduce using rule 79 (struct_field -> VARIABLE type .)
    FLOAT64_TYPE    reduce using rule 79 (struct_field -> VARIABLE type .)
    STRING_TYPE     reduce using rule 79 (struct_field -> VARIABLE type .)
    BOOL_TYPE       reduce using rule 79 (struct_field -> VARIABLE type .)
    RBRACE          reduce using rule 79 (struct_field -> VARIABLE type .)


state 213

    (76) struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .

    VAR             reduce using rule 76 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    VARIABLE        reduce using rule 76 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    FMT             reduce using rule 76 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    FUNC            reduce using rule 76 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    IF              reduce using rule 76 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    FOR             reduce using rule 76 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    TYPE            reduce using rule 76 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    SWITCH          reduce using rule 76 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    BREAK           reduce using rule 76 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    $end            reduce using rule 76 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    RBRACE          reduce using rule 76 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    CASE            reduce using rule 76 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    DEFAULT         reduce using rule 76 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)


state 214

    (78) struct_fields -> struct_field struct_fields .

    RBRACE          reduce using rule 78 (struct_fields -> struct_field struct_fields .)


state 215

    (89) case_clause -> CASE expression COLON program .

    CASE            reduce using rule 89 (case_clause -> CASE expression COLON program .)
    DEFAULT         reduce using rule 89 (case_clause -> CASE expression COLON program .)
    RBRACE          reduce using rule 89 (case_clause -> CASE expression COLON program .)


state 216

    (91) map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .

    VAR             reduce using rule 91 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    VARIABLE        reduce using rule 91 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    FMT             reduce using rule 91 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    FUNC            reduce using rule 91 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    IF              reduce using rule 91 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    FOR             reduce using rule 91 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    TYPE            reduce using rule 91 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    SWITCH          reduce using rule 91 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    BREAK           reduce using rule 91 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    $end            reduce using rule 91 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    RBRACE          reduce using rule 91 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    CASE            reduce using rule 91 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    DEFAULT         reduce using rule 91 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)


state 217

    (92) map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .

    VAR             reduce using rule 92 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    VARIABLE        reduce using rule 92 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    FMT             reduce using rule 92 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    FUNC            reduce using rule 92 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    IF              reduce using rule 92 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    FOR             reduce using rule 92 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    TYPE            reduce using rule 92 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    SWITCH          reduce using rule 92 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    BREAK           reduce using rule 92 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    $end            reduce using rule 92 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    RBRACE          reduce using rule 92 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    CASE            reduce using rule 92 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    DEFAULT         reduce using rule 92 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)


state 218

    (98) array_declaration -> VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE . array_values RBRACE
    (99) array_values -> . expression
    (100) array_values -> . expression COMMA array_values
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    array_values                   shift and go to state 231
    expression                     shift and go to state 232
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 219

    (102) slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values . RBRACE

    RBRACE          shift and go to state 233


state 220

    (103) slice_values -> expression .
    (104) slice_values -> expression . COMMA slice_values
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression

    RBRACE          reduce using rule 103 (slice_values -> expression .)
    COMMA           shift and go to state 234
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89


state 221

    (93) make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type . RBRACKET type RPAREN
    (95) make_expr -> MAKE LPAREN MAP LBRACKET type . RBRACKET type RPAREN

    RBRACKET        shift and go to state 235


state 222

    (94) make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type . RPAREN
    (96) make_expr -> MAKE LPAREN LBRACKET RBRACKET type . RPAREN

    RPAREN          shift and go to state 236


state 223

    (29) print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression . RPAREN
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression

    RPAREN          shift and go to state 237
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89


state 224

    (31) input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .

    VAR             reduce using rule 31 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    VARIABLE        reduce using rule 31 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    FMT             reduce using rule 31 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    FUNC            reduce using rule 31 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    IF              reduce using rule 31 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    FOR             reduce using rule 31 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    TYPE            reduce using rule 31 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    SWITCH          reduce using rule 31 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    BREAK           reduce using rule 31 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    $end            reduce using rule 31 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    RBRACE          reduce using rule 31 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    CASE            reduce using rule 31 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    DEFAULT         reduce using rule 31 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)


state 225

    (74) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN . param_list RPAREN type LBRACE program RBRACE
    (75) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN . RPAREN type LBRACE program RBRACE
    (37) param_list -> . param
    (38) param_list -> . param COMMA param_list
    (39) param -> . VARIABLE type

    RPAREN          shift and go to state 238
    VARIABLE        shift and go to state 120

    param_list                     shift and go to state 239
    param                          shift and go to state 123

state 226

    (32) func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE . program RBRACE
    (1) program -> . statement
    (2) program -> . statement program
    (3) statement -> . declaration
    (4) statement -> . assignment
    (5) statement -> . print_stmt
    (6) statement -> . input_stmt
    (7) statement -> . struct_method
    (8) statement -> . func_def
    (9) statement -> . func_no_params
    (10) statement -> . func_call
    (11) statement -> . if_stmt
    (12) statement -> . for_stmt
    (13) statement -> . struct_def
    (14) statement -> . switch_stmt
    (15) statement -> . map_declaration
    (16) statement -> . array_declaration
    (17) statement -> . slice_declaration
    (18) statement -> . make_stmt
    (19) statement -> . new_stmt
    (20) statement -> . break_stmt
    (21) statement -> . increment_stmt
    (22) declaration -> . VAR VARIABLE type
    (23) declaration -> . VAR VARIABLE type ASIG expression
    (27) assignment -> . VARIABLE ASSIGN expression
    (28) assignment -> . VARIABLE ASIG expression
    (29) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (30) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (31) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (74) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (75) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (32) func_def -> . FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (33) func_def -> . FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (34) func_no_params -> . FUNC VARIABLE LPAREN RPAREN block
    (35) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (36) func_call -> . VARIABLE LPAREN RPAREN
    (67) if_stmt -> . IF expression block
    (68) if_stmt -> . IF expression block ELSE block
    (69) for_stmt -> . FOR expression block
    (70) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update block
    (76) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (85) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (86) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (91) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (92) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (97) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (98) array_declaration -> . VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (101) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (102) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (93) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (105) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (106) break_stmt -> . BREAK
    (107) increment_stmt -> . VARIABLE INCREMENT
    (108) increment_stmt -> . VARIABLE DECREMENT

    VAR             shift and go to state 22
    VARIABLE        shift and go to state 23
    FMT             shift and go to state 24
    FUNC            shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    TYPE            shift and go to state 28
    SWITCH          shift and go to state 29
    BREAK           shift and go to state 30

    program                        shift and go to state 240
    statement                      shift and go to state 2
    declaration                    shift and go to state 3
    assignment                     shift and go to state 4
    print_stmt                     shift and go to state 5
    input_stmt                     shift and go to state 6
    struct_method                  shift and go to state 7
    func_def                       shift and go to state 8
    func_no_params                 shift and go to state 9
    func_call                      shift and go to state 10
    if_stmt                        shift and go to state 11
    for_stmt                       shift and go to state 12
    struct_def                     shift and go to state 13
    switch_stmt                    shift and go to state 14
    map_declaration                shift and go to state 15
    array_declaration              shift and go to state 16
    slice_declaration              shift and go to state 17
    make_stmt                      shift and go to state 18
    new_stmt                       shift and go to state 19
    break_stmt                     shift and go to state 20
    increment_stmt                 shift and go to state 21

state 227

    (33) func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program . RBRACE

    RBRACE          shift and go to state 241


state 228

    (95) make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET . type RPAREN
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64

    type                           shift and go to state 242

state 229

    (96) make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .

    TIMES           reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    DIVIDE          reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    PLUS            reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    MINUS           reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    AND             reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    OR              reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    EQ              reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    NE              reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    LT              reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    GT              reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    LE              reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    GE              reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    LBRACE          reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    VAR             reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    VARIABLE        reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    FMT             reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    FUNC            reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    IF              reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    FOR             reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    TYPE            reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    SWITCH          reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    BREAK           reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    $end            reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    RBRACE          reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    CASE            reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    DEFAULT         reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    SEMICOLON       reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    COMMA           reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    RPAREN          reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    COLON           reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)


state 230

    (70) for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .

    VAR             reduce using rule 70 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    VARIABLE        reduce using rule 70 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    FMT             reduce using rule 70 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    FUNC            reduce using rule 70 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    IF              reduce using rule 70 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    FOR             reduce using rule 70 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    TYPE            reduce using rule 70 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    SWITCH          reduce using rule 70 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    BREAK           reduce using rule 70 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    $end            reduce using rule 70 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    RBRACE          reduce using rule 70 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    CASE            reduce using rule 70 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    DEFAULT         reduce using rule 70 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)


state 231

    (98) array_declaration -> VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values . RBRACE

    RBRACE          shift and go to state 243


state 232

    (99) array_values -> expression .
    (100) array_values -> expression . COMMA array_values
    (43) expression -> expression . PLUS term
    (44) expression -> expression . MINUS term
    (45) expression -> expression . AND expression
    (46) expression -> expression . OR expression
    (47) expression -> expression . EQ expression
    (48) expression -> expression . NE expression
    (49) expression -> expression . LT expression
    (50) expression -> expression . GT expression
    (51) expression -> expression . LE expression
    (52) expression -> expression . GE expression

    RBRACE          reduce using rule 99 (array_values -> expression .)
    COMMA           shift and go to state 244
    PLUS            shift and go to state 80
    MINUS           shift and go to state 81
    AND             shift and go to state 82
    OR              shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    GT              shift and go to state 87
    LE              shift and go to state 88
    GE              shift and go to state 89


state 233

    (102) slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .

    VAR             reduce using rule 102 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    VARIABLE        reduce using rule 102 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    FMT             reduce using rule 102 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    FUNC            reduce using rule 102 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    IF              reduce using rule 102 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    FOR             reduce using rule 102 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    TYPE            reduce using rule 102 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    SWITCH          reduce using rule 102 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    BREAK           reduce using rule 102 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    $end            reduce using rule 102 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    RBRACE          reduce using rule 102 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    CASE            reduce using rule 102 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    DEFAULT         reduce using rule 102 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)


state 234

    (104) slice_values -> expression COMMA . slice_values
    (103) slice_values -> . expression
    (104) slice_values -> . expression COMMA slice_values
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 220
    slice_values                   shift and go to state 245
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 235

    (93) make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET . type RPAREN
    (95) make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET . type RPAREN
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64

    type                           shift and go to state 246

state 236

    (94) make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .
    (96) make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .

  ! reduce/reduce conflict for VAR resolved using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for FMT resolved using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for FUNC resolved using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for IF resolved using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for FOR resolved using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for TYPE resolved using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for SWITCH resolved using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for BREAK resolved using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for $end resolved using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for RBRACE resolved using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for CASE resolved using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    VAR             reduce using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    VARIABLE        reduce using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    FMT             reduce using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    FUNC            reduce using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    IF              reduce using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    FOR             reduce using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    TYPE            reduce using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    SWITCH          reduce using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    BREAK           reduce using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    $end            reduce using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    RBRACE          reduce using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    CASE            reduce using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    DEFAULT         reduce using rule 94 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    TIMES           reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    DIVIDE          reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    PLUS            reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    MINUS           reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    AND             reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    OR              reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    EQ              reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    NE              reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    LT              reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    GT              reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    LE              reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    GE              reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)

  ! VAR             [ reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! VARIABLE        [ reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! FMT             [ reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! FUNC            [ reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! IF              [ reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! FOR             [ reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! TYPE            [ reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! SWITCH          [ reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! BREAK           [ reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! $end            [ reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! RBRACE          [ reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! CASE            [ reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! DEFAULT         [ reduce using rule 96 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]


state 237

    (29) print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .

    VAR             reduce using rule 29 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    VARIABLE        reduce using rule 29 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    FMT             reduce using rule 29 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    FUNC            reduce using rule 29 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    IF              reduce using rule 29 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    FOR             reduce using rule 29 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    TYPE            reduce using rule 29 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    SWITCH          reduce using rule 29 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    BREAK           reduce using rule 29 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    $end            reduce using rule 29 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    RBRACE          reduce using rule 29 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    CASE            reduce using rule 29 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    DEFAULT         reduce using rule 29 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)


state 238

    (75) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN . type LBRACE program RBRACE
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64

    type                           shift and go to state 247

state 239

    (74) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list . RPAREN type LBRACE program RBRACE

    RPAREN          shift and go to state 248


state 240

    (32) func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program . RBRACE

    RBRACE          shift and go to state 249


state 241

    (33) func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .

    VAR             reduce using rule 33 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    VARIABLE        reduce using rule 33 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    FMT             reduce using rule 33 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    FUNC            reduce using rule 33 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    IF              reduce using rule 33 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    FOR             reduce using rule 33 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    TYPE            reduce using rule 33 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    SWITCH          reduce using rule 33 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    BREAK           reduce using rule 33 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    $end            reduce using rule 33 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    RBRACE          reduce using rule 33 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    CASE            reduce using rule 33 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    DEFAULT         reduce using rule 33 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)


state 242

    (95) make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type . RPAREN

    RPAREN          shift and go to state 250


state 243

    (98) array_declaration -> VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .

    VAR             reduce using rule 98 (array_declaration -> VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    VARIABLE        reduce using rule 98 (array_declaration -> VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    FMT             reduce using rule 98 (array_declaration -> VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    FUNC            reduce using rule 98 (array_declaration -> VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    IF              reduce using rule 98 (array_declaration -> VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    FOR             reduce using rule 98 (array_declaration -> VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    TYPE            reduce using rule 98 (array_declaration -> VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    SWITCH          reduce using rule 98 (array_declaration -> VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    BREAK           reduce using rule 98 (array_declaration -> VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    $end            reduce using rule 98 (array_declaration -> VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    RBRACE          reduce using rule 98 (array_declaration -> VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    CASE            reduce using rule 98 (array_declaration -> VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    DEFAULT         reduce using rule 98 (array_declaration -> VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)


state 244

    (100) array_values -> expression COMMA . array_values
    (99) array_values -> . expression
    (100) array_values -> . expression COMMA array_values
    (24) expression -> . NUMBER
    (25) expression -> . FLOAT
    (26) expression -> . VARIABLE
    (42) expression -> . term
    (43) expression -> . expression PLUS term
    (44) expression -> . expression MINUS term
    (45) expression -> . expression AND expression
    (46) expression -> . expression OR expression
    (47) expression -> . expression EQ expression
    (48) expression -> . expression NE expression
    (49) expression -> . expression LT expression
    (50) expression -> . expression GT expression
    (51) expression -> . expression LE expression
    (52) expression -> . expression GE expression
    (53) term -> . factor
    (54) term -> . term TIMES factor
    (55) term -> . term DIVIDE factor
    (56) factor -> . NUMBER
    (57) factor -> . FLOAT
    (58) factor -> . STRING
    (59) factor -> . VARIABLE
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . make_expr
    (62) factor -> . struct_instance
    (95) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (96) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (81) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 42
    FLOAT           shift and go to state 43
    VARIABLE        shift and go to state 44
    STRING          shift and go to state 47
    LPAREN          shift and go to state 48
    MAKE            shift and go to state 51

    expression                     shift and go to state 232
    array_values                   shift and go to state 251
    term                           shift and go to state 45
    factor                         shift and go to state 46
    make_expr                      shift and go to state 49
    struct_instance                shift and go to state 50

state 245

    (104) slice_values -> expression COMMA slice_values .

    RBRACE          reduce using rule 104 (slice_values -> expression COMMA slice_values .)


state 246

    (93) make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type . RPAREN
    (95) make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type . RPAREN

    RPAREN          shift and go to state 252


state 247

    (75) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type . LBRACE program RBRACE

    LBRACE          shift and go to state 253


state 248

    (74) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN . type LBRACE program RBRACE
    (63) type -> . INT_TYPE
    (64) type -> . FLOAT64_TYPE
    (65) type -> . STRING_TYPE
    (66) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 61
    FLOAT64_TYPE    shift and go to state 62
    STRING_TYPE     shift and go to state 63
    BOOL_TYPE       shift and go to state 64

    type                           shift and go to state 254

state 249

    (32) func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .

    VAR             reduce using rule 32 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    VARIABLE        reduce using rule 32 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    FMT             reduce using rule 32 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    FUNC            reduce using rule 32 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    IF              reduce using rule 32 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    FOR             reduce using rule 32 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    TYPE            reduce using rule 32 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    SWITCH          reduce using rule 32 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    BREAK           reduce using rule 32 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    $end            reduce using rule 32 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    RBRACE          reduce using rule 32 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    CASE            reduce using rule 32 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    DEFAULT         reduce using rule 32 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)


state 250

    (95) make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .

    TIMES           reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    DIVIDE          reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    PLUS            reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    MINUS           reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    AND             reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    OR              reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    EQ              reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    NE              reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LT              reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    GT              reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LE              reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    GE              reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LBRACE          reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VAR             reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VARIABLE        reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FMT             reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FUNC            reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    IF              reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FOR             reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    TYPE            reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    SWITCH          reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    BREAK           reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    $end            reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RBRACE          reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CASE            reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    DEFAULT         reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    SEMICOLON       reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    COMMA           reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RPAREN          reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    COLON           reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)


state 251

    (100) array_values -> expression COMMA array_values .

    RBRACE          reduce using rule 100 (array_values -> expression COMMA array_values .)


state 252

    (93) make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .
    (95) make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .

  ! reduce/reduce conflict for VAR resolved using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for FMT resolved using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for FUNC resolved using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for IF resolved using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for FOR resolved using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for TYPE resolved using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for SWITCH resolved using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for BREAK resolved using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for $end resolved using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for RBRACE resolved using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for CASE resolved using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VAR             reduce using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VARIABLE        reduce using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FMT             reduce using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FUNC            reduce using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    IF              reduce using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FOR             reduce using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    TYPE            reduce using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    SWITCH          reduce using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    BREAK           reduce using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    $end            reduce using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RBRACE          reduce using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CASE            reduce using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    DEFAULT         reduce using rule 93 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    TIMES           reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    DIVIDE          reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    PLUS            reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    MINUS           reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    AND             reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    OR              reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    EQ              reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    NE              reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LT              reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    GT              reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LE              reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    GE              reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)

  ! VAR             [ reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! VARIABLE        [ reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! FMT             [ reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! FUNC            [ reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! IF              [ reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! FOR             [ reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! TYPE            [ reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! SWITCH          [ reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! BREAK           [ reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! $end            [ reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! RBRACE          [ reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! CASE            [ reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! DEFAULT         [ reduce using rule 95 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]


state 253

    (75) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE . program RBRACE
    (1) program -> . statement
    (2) program -> . statement program
    (3) statement -> . declaration
    (4) statement -> . assignment
    (5) statement -> . print_stmt
    (6) statement -> . input_stmt
    (7) statement -> . struct_method
    (8) statement -> . func_def
    (9) statement -> . func_no_params
    (10) statement -> . func_call
    (11) statement -> . if_stmt
    (12) statement -> . for_stmt
    (13) statement -> . struct_def
    (14) statement -> . switch_stmt
    (15) statement -> . map_declaration
    (16) statement -> . array_declaration
    (17) statement -> . slice_declaration
    (18) statement -> . make_stmt
    (19) statement -> . new_stmt
    (20) statement -> . break_stmt
    (21) statement -> . increment_stmt
    (22) declaration -> . VAR VARIABLE type
    (23) declaration -> . VAR VARIABLE type ASIG expression
    (27) assignment -> . VARIABLE ASSIGN expression
    (28) assignment -> . VARIABLE ASIG expression
    (29) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (30) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (31) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (74) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (75) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (32) func_def -> . FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (33) func_def -> . FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (34) func_no_params -> . FUNC VARIABLE LPAREN RPAREN block
    (35) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (36) func_call -> . VARIABLE LPAREN RPAREN
    (67) if_stmt -> . IF expression block
    (68) if_stmt -> . IF expression block ELSE block
    (69) for_stmt -> . FOR expression block
    (70) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update block
    (76) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (85) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (86) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (91) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (92) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (97) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (98) array_declaration -> . VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (101) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (102) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (93) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (105) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (106) break_stmt -> . BREAK
    (107) increment_stmt -> . VARIABLE INCREMENT
    (108) increment_stmt -> . VARIABLE DECREMENT

    VAR             shift and go to state 22
    VARIABLE        shift and go to state 23
    FMT             shift and go to state 24
    FUNC            shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    TYPE            shift and go to state 28
    SWITCH          shift and go to state 29
    BREAK           shift and go to state 30

    program                        shift and go to state 255
    statement                      shift and go to state 2
    declaration                    shift and go to state 3
    assignment                     shift and go to state 4
    print_stmt                     shift and go to state 5
    input_stmt                     shift and go to state 6
    struct_method                  shift and go to state 7
    func_def                       shift and go to state 8
    func_no_params                 shift and go to state 9
    func_call                      shift and go to state 10
    if_stmt                        shift and go to state 11
    for_stmt                       shift and go to state 12
    struct_def                     shift and go to state 13
    switch_stmt                    shift and go to state 14
    map_declaration                shift and go to state 15
    array_declaration              shift and go to state 16
    slice_declaration              shift and go to state 17
    make_stmt                      shift and go to state 18
    new_stmt                       shift and go to state 19
    break_stmt                     shift and go to state 20
    increment_stmt                 shift and go to state 21

state 254

    (74) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type . LBRACE program RBRACE

    LBRACE          shift and go to state 256


state 255

    (75) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program . RBRACE

    RBRACE          shift and go to state 257


state 256

    (74) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE . program RBRACE
    (1) program -> . statement
    (2) program -> . statement program
    (3) statement -> . declaration
    (4) statement -> . assignment
    (5) statement -> . print_stmt
    (6) statement -> . input_stmt
    (7) statement -> . struct_method
    (8) statement -> . func_def
    (9) statement -> . func_no_params
    (10) statement -> . func_call
    (11) statement -> . if_stmt
    (12) statement -> . for_stmt
    (13) statement -> . struct_def
    (14) statement -> . switch_stmt
    (15) statement -> . map_declaration
    (16) statement -> . array_declaration
    (17) statement -> . slice_declaration
    (18) statement -> . make_stmt
    (19) statement -> . new_stmt
    (20) statement -> . break_stmt
    (21) statement -> . increment_stmt
    (22) declaration -> . VAR VARIABLE type
    (23) declaration -> . VAR VARIABLE type ASIG expression
    (27) assignment -> . VARIABLE ASSIGN expression
    (28) assignment -> . VARIABLE ASIG expression
    (29) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (30) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (31) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (74) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (75) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (32) func_def -> . FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (33) func_def -> . FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (34) func_no_params -> . FUNC VARIABLE LPAREN RPAREN block
    (35) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (36) func_call -> . VARIABLE LPAREN RPAREN
    (67) if_stmt -> . IF expression block
    (68) if_stmt -> . IF expression block ELSE block
    (69) for_stmt -> . FOR expression block
    (70) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update block
    (76) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (85) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (86) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (91) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (92) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (97) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (98) array_declaration -> . VARIABLE ASIG LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (101) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (102) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (93) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (94) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (105) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (106) break_stmt -> . BREAK
    (107) increment_stmt -> . VARIABLE INCREMENT
    (108) increment_stmt -> . VARIABLE DECREMENT

    VAR             shift and go to state 22
    VARIABLE        shift and go to state 23
    FMT             shift and go to state 24
    FUNC            shift and go to state 25
    IF              shift and go to state 26
    FOR             shift and go to state 27
    TYPE            shift and go to state 28
    SWITCH          shift and go to state 29
    BREAK           shift and go to state 30

    program                        shift and go to state 258
    statement                      shift and go to state 2
    declaration                    shift and go to state 3
    assignment                     shift and go to state 4
    print_stmt                     shift and go to state 5
    input_stmt                     shift and go to state 6
    struct_method                  shift and go to state 7
    func_def                       shift and go to state 8
    func_no_params                 shift and go to state 9
    func_call                      shift and go to state 10
    if_stmt                        shift and go to state 11
    for_stmt                       shift and go to state 12
    struct_def                     shift and go to state 13
    switch_stmt                    shift and go to state 14
    map_declaration                shift and go to state 15
    array_declaration              shift and go to state 16
    slice_declaration              shift and go to state 17
    make_stmt                      shift and go to state 18
    new_stmt                       shift and go to state 19
    break_stmt                     shift and go to state 20
    increment_stmt                 shift and go to state 21

state 257

    (75) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .

    VAR             reduce using rule 75 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    VARIABLE        reduce using rule 75 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    FMT             reduce using rule 75 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    FUNC            reduce using rule 75 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    IF              reduce using rule 75 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    FOR             reduce using rule 75 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    TYPE            reduce using rule 75 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    SWITCH          reduce using rule 75 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    BREAK           reduce using rule 75 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    $end            reduce using rule 75 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    RBRACE          reduce using rule 75 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    CASE            reduce using rule 75 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    DEFAULT         reduce using rule 75 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)


state 258

    (74) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program . RBRACE

    RBRACE          shift and go to state 259


state 259

    (74) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .

    VAR             reduce using rule 74 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    VARIABLE        reduce using rule 74 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    FMT             reduce using rule 74 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    FUNC            reduce using rule 74 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    IF              reduce using rule 74 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    FOR             reduce using rule 74 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    TYPE            reduce using rule 74 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    SWITCH          reduce using rule 74 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    BREAK           reduce using rule 74 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    $end            reduce using rule 74 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    RBRACE          reduce using rule 74 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    CASE            reduce using rule 74 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    DEFAULT         reduce using rule 74 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBRACE in state 44 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 54 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 128 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 130 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 130 resolved as shift
WARNING: shift/reduce conflict for AND in state 130 resolved as shift
WARNING: shift/reduce conflict for OR in state 130 resolved as shift
WARNING: shift/reduce conflict for EQ in state 130 resolved as shift
WARNING: shift/reduce conflict for NE in state 130 resolved as shift
WARNING: shift/reduce conflict for LT in state 130 resolved as shift
WARNING: shift/reduce conflict for GT in state 130 resolved as shift
WARNING: shift/reduce conflict for LE in state 130 resolved as shift
WARNING: shift/reduce conflict for GE in state 130 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 131 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 131 resolved as shift
WARNING: shift/reduce conflict for AND in state 131 resolved as shift
WARNING: shift/reduce conflict for OR in state 131 resolved as shift
WARNING: shift/reduce conflict for EQ in state 131 resolved as shift
WARNING: shift/reduce conflict for NE in state 131 resolved as shift
WARNING: shift/reduce conflict for LT in state 131 resolved as shift
WARNING: shift/reduce conflict for GT in state 131 resolved as shift
WARNING: shift/reduce conflict for LE in state 131 resolved as shift
WARNING: shift/reduce conflict for GE in state 131 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 132 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 132 resolved as shift
WARNING: shift/reduce conflict for AND in state 132 resolved as shift
WARNING: shift/reduce conflict for OR in state 132 resolved as shift
WARNING: shift/reduce conflict for EQ in state 132 resolved as shift
WARNING: shift/reduce conflict for NE in state 132 resolved as shift
WARNING: shift/reduce conflict for LT in state 132 resolved as shift
WARNING: shift/reduce conflict for GT in state 132 resolved as shift
WARNING: shift/reduce conflict for LE in state 132 resolved as shift
WARNING: shift/reduce conflict for GE in state 132 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 133 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 133 resolved as shift
WARNING: shift/reduce conflict for AND in state 133 resolved as shift
WARNING: shift/reduce conflict for OR in state 133 resolved as shift
WARNING: shift/reduce conflict for EQ in state 133 resolved as shift
WARNING: shift/reduce conflict for NE in state 133 resolved as shift
WARNING: shift/reduce conflict for LT in state 133 resolved as shift
WARNING: shift/reduce conflict for GT in state 133 resolved as shift
WARNING: shift/reduce conflict for LE in state 133 resolved as shift
WARNING: shift/reduce conflict for GE in state 133 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 134 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 134 resolved as shift
WARNING: shift/reduce conflict for AND in state 134 resolved as shift
WARNING: shift/reduce conflict for OR in state 134 resolved as shift
WARNING: shift/reduce conflict for EQ in state 134 resolved as shift
WARNING: shift/reduce conflict for NE in state 134 resolved as shift
WARNING: shift/reduce conflict for LT in state 134 resolved as shift
WARNING: shift/reduce conflict for GT in state 134 resolved as shift
WARNING: shift/reduce conflict for LE in state 134 resolved as shift
WARNING: shift/reduce conflict for GE in state 134 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 135 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 135 resolved as shift
WARNING: shift/reduce conflict for AND in state 135 resolved as shift
WARNING: shift/reduce conflict for OR in state 135 resolved as shift
WARNING: shift/reduce conflict for EQ in state 135 resolved as shift
WARNING: shift/reduce conflict for NE in state 135 resolved as shift
WARNING: shift/reduce conflict for LT in state 135 resolved as shift
WARNING: shift/reduce conflict for GT in state 135 resolved as shift
WARNING: shift/reduce conflict for LE in state 135 resolved as shift
WARNING: shift/reduce conflict for GE in state 135 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 136 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 136 resolved as shift
WARNING: shift/reduce conflict for AND in state 136 resolved as shift
WARNING: shift/reduce conflict for OR in state 136 resolved as shift
WARNING: shift/reduce conflict for EQ in state 136 resolved as shift
WARNING: shift/reduce conflict for NE in state 136 resolved as shift
WARNING: shift/reduce conflict for LT in state 136 resolved as shift
WARNING: shift/reduce conflict for GT in state 136 resolved as shift
WARNING: shift/reduce conflict for LE in state 136 resolved as shift
WARNING: shift/reduce conflict for GE in state 136 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 137 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 137 resolved as shift
WARNING: shift/reduce conflict for AND in state 137 resolved as shift
WARNING: shift/reduce conflict for OR in state 137 resolved as shift
WARNING: shift/reduce conflict for EQ in state 137 resolved as shift
WARNING: shift/reduce conflict for NE in state 137 resolved as shift
WARNING: shift/reduce conflict for LT in state 137 resolved as shift
WARNING: shift/reduce conflict for GT in state 137 resolved as shift
WARNING: shift/reduce conflict for LE in state 137 resolved as shift
WARNING: shift/reduce conflict for GE in state 137 resolved as shift
WARNING: reduce/reduce conflict in state 42 resolved using rule (expression -> NUMBER)
WARNING: rejected rule (factor -> NUMBER) in state 42
WARNING: reduce/reduce conflict in state 43 resolved using rule (expression -> FLOAT)
WARNING: rejected rule (factor -> FLOAT) in state 43
WARNING: reduce/reduce conflict in state 44 resolved using rule (expression -> VARIABLE)
WARNING: rejected rule (factor -> VARIABLE) in state 44
WARNING: reduce/reduce conflict in state 54 resolved using rule (expression -> VARIABLE)
WARNING: rejected rule (factor -> VARIABLE) in state 54
WARNING: reduce/reduce conflict in state 236 resolved using rule (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN)
WARNING: rejected rule (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN) in state 236
WARNING: reduce/reduce conflict in state 252 resolved using rule (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN)
WARNING: rejected rule (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN) in state 252
