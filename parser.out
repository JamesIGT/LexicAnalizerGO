Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    FALSE
    MOD
    NOT
    PRINT
    RANGE
    TRUE
    UINT

Grammar

Rule 0     S' -> start
Rule 1     start -> PACKAGE MAIN import_stmt program
Rule 2     import_stmt -> IMPORT LPAREN STRING RPAREN
Rule 3     import_stmt -> IMPORT STRING
Rule 4     program -> statement
Rule 5     program -> statement program
Rule 6     statement -> declaration
Rule 7     statement -> assignment
Rule 8     statement -> print_stmt
Rule 9     statement -> input_stmt
Rule 10    statement -> continue_stmt
Rule 11    statement -> struct_method
Rule 12    statement -> func_def
Rule 13    statement -> func_no_params
Rule 14    statement -> func_call
Rule 15    statement -> if_stmt
Rule 16    statement -> for_stmt
Rule 17    statement -> struct_def
Rule 18    statement -> switch_stmt
Rule 19    statement -> map_declaration
Rule 20    statement -> map_declaration_values
Rule 21    statement -> array_declaration
Rule 22    statement -> array_literal
Rule 23    statement -> slice_declaration
Rule 24    statement -> make_stmt
Rule 25    statement -> new_stmt
Rule 26    statement -> break_stmt
Rule 27    statement -> increment_stmt
Rule 28    statement -> return_stmt
Rule 29    declaration -> VAR VARIABLE type
Rule 30    declaration -> VAR VARIABLE type ASIG expression
Rule 31    declaration -> VAR VARIABLE type ASSIGN expression
Rule 32    expression -> NUMBER
Rule 33    expression -> FLOAT
Rule 34    expression -> VARIABLE
Rule 35    assignment -> VARIABLE ASSIGN expression
Rule 36    assignment -> VARIABLE ASIG expression
Rule 37    print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
Rule 38    print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN
Rule 39    input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
Rule 40    func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
Rule 41    func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE
Rule 42    return_stmt -> RETURN expression
Rule 43    func_no_params -> FUNC VARIABLE LPAREN RPAREN block
Rule 44    func_call -> VARIABLE LPAREN arg_list RPAREN
Rule 45    func_call -> VARIABLE LPAREN RPAREN
Rule 46    param_list -> param
Rule 47    param_list -> param COMMA param_list
Rule 48    param -> VARIABLE type
Rule 49    arg_list -> expression
Rule 50    arg_list -> expression COMMA arg_list
Rule 51    expression -> term
Rule 52    expression -> expression PLUS term
Rule 53    expression -> expression MINUS term
Rule 54    expression -> expression AND expression
Rule 55    expression -> expression OR expression
Rule 56    expression -> expression EQ expression
Rule 57    expression -> expression NE expression
Rule 58    expression -> expression LT expression
Rule 59    expression -> expression GT expression
Rule 60    expression -> expression LE expression
Rule 61    expression -> expression GE expression
Rule 62    term -> factor
Rule 63    term -> term TIMES factor
Rule 64    term -> term DIVIDE factor
Rule 65    factor -> NUMBER
Rule 66    factor -> FLOAT
Rule 67    factor -> STRING
Rule 68    factor -> VARIABLE
Rule 69    factor -> LPAREN expression RPAREN
Rule 70    factor -> make_expr
Rule 71    factor -> struct_instance
Rule 72    type -> INT_TYPE
Rule 73    type -> FLOAT64_TYPE
Rule 74    type -> STRING_TYPE
Rule 75    type -> BOOL_TYPE
Rule 76    if_stmt -> IF expression block
Rule 77    if_stmt -> IF expression block ELSE block
Rule 78    for_stmt -> FOR expression block
Rule 79    for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block
Rule 80    continue_stmt -> CONTINUE
Rule 81    for_update -> assignment
Rule 82    for_update -> increment_stmt
Rule 83    block -> LBRACE program RBRACE
Rule 84    struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
Rule 85    struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
Rule 86    struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
Rule 87    struct_fields -> struct_field
Rule 88    struct_fields -> struct_field struct_fields
Rule 89    struct_field -> VARIABLE type
Rule 90    struct_field -> type
Rule 91    struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE
Rule 92    struct_fields_values -> field_value
Rule 93    struct_fields_values -> field_value COMMA struct_fields_values
Rule 94    field_value -> VARIABLE COLON expression
Rule 95    switch_stmt -> SWITCH expression LBRACE case_list RBRACE
Rule 96    switch_stmt -> SWITCH LBRACE case_list RBRACE
Rule 97    case_list -> case_clause
Rule 98    case_list -> case_clause case_list
Rule 99    case_clause -> CASE expression COLON program
Rule 100   case_clause -> DEFAULT COLON program
Rule 101   map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type
Rule 102   map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type
Rule 103   make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
Rule 104   make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
Rule 105   make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
Rule 106   make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN
Rule 107   map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
Rule 108   map_kv_pairs -> map_kv_pair
Rule 109   map_kv_pairs -> map_kv_pair COMMA map_kv_pairs
Rule 110   map_kv_pair -> STRING COLON expression
Rule 111   array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type
Rule 112   array_declaration -> VAR VARIABLE ASSIGN array_literal
Rule 113   array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
Rule 114   array_values -> expression
Rule 115   array_values -> expression COMMA array_values
Rule 116   slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type
Rule 117   slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
Rule 118   slice_values -> expression
Rule 119   slice_values -> expression COMMA slice_values
Rule 120   new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
Rule 121   break_stmt -> BREAK
Rule 122   increment_stmt -> VARIABLE INCREMENT
Rule 123   increment_stmt -> VARIABLE DECREMENT

Terminals, with rules where they appear

AMPER                : 39
AND                  : 54
ASIG                 : 30 36 102 103 104 107 117 120
ASSIGN               : 31 35 112
BOOL_TYPE            : 75
BREAK                : 121
CASE                 : 99
COLON                : 94 99 100 110
COMMA                : 37 47 50 93 109 115 119
CONTINUE             : 80
DECREMENT            : 123
DEFAULT              : 100
DIVIDE               : 64
DOT                  : 37 38 39
ELSE                 : 77
EQ                   : 56
FALSE                : 
FLOAT                : 33 66
FLOAT64_TYPE         : 73
FMT                  : 37 38 39
FOR                  : 78 79
FUNC                 : 40 41 43 84 85
GE                   : 61
GT                   : 59
IF                   : 76 77
IMPORT               : 2 3
INCREMENT            : 122
INT_TYPE             : 72
LBRACE               : 40 41 83 84 85 86 91 95 96 107 113 117
LBRACKET             : 101 102 103 104 105 106 107 111 113 116 117
LE                   : 60
LPAREN               : 2 37 38 39 40 41 43 44 45 69 84 84 85 85 103 104 105 106 120
LT                   : 58
MAIN                 : 1
MAKE                 : 103 104 105 106
MAP                  : 101 102 103 105 107
MINUS                : 53
MOD                  : 
NE                   : 57
NEW                  : 120
NOT                  : 
NUMBER               : 32 65 111 113
OR                   : 55
PACKAGE              : 1
PLUS                 : 52
PRINT                : 
PRINTF               : 37
PRINTLN              : 38
RANGE                : 
RBRACE               : 40 41 83 84 85 86 91 95 96 107 113 117
RBRACKET             : 101 102 103 104 105 106 107 111 113 116 117
RETURN               : 42
RPAREN               : 2 37 38 39 40 41 43 44 45 69 84 84 85 85 103 104 105 106 120
SCANLN               : 39
SEMICOLON            : 79 79
STRING               : 2 3 37 67 110
STRING_TYPE          : 74
STRUCT               : 86
SWITCH               : 95 96
TIMES                : 63
TRUE                 : 
TYPE                 : 86
UINT                 : 
VAR                  : 29 30 31 101 111 112 116
VARIABLE             : 29 30 31 34 35 36 39 40 41 43 44 45 48 68 84 84 84 85 85 85 86 89 91 94 101 102 103 104 107 111 112 116 117 120 120 122 123
error                : 

Nonterminals, with rules where they appear

arg_list             : 44 50
array_declaration    : 21
array_literal        : 22 112
array_values         : 113 115
assignment           : 7 79 81
block                : 43 76 77 77 78 79
break_stmt           : 26
case_clause          : 97 98
case_list            : 95 96 98
continue_stmt        : 10
declaration          : 6
expression           : 30 31 35 36 37 38 42 49 50 52 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 69 76 77 78 79 94 95 99 110 114 115 118 119
factor               : 62 63 64
field_value          : 92 93
for_stmt             : 16
for_update           : 79
func_call            : 14
func_def             : 12
func_no_params       : 13
if_stmt              : 15
import_stmt          : 1
increment_stmt       : 27 82
input_stmt           : 9
make_expr            : 70
make_stmt            : 24
map_declaration      : 19
map_declaration_values : 20
map_kv_pair          : 108 109
map_kv_pairs         : 107 109
new_stmt             : 25
param                : 46 47
param_list           : 40 47 84
print_stmt           : 8
program              : 1 5 40 41 83 84 85 99 100
return_stmt          : 28
slice_declaration    : 23
slice_values         : 117 119
start                : 0
statement            : 4 5
struct_def           : 17
struct_field         : 87 88
struct_fields        : 86 88
struct_fields_values : 91 93
struct_instance      : 71
struct_method        : 11
switch_stmt          : 18
term                 : 51 52 53 63 64
type                 : 29 30 31 40 41 48 84 85 89 90 101 101 102 102 103 103 104 105 105 106 107 107 111 113 116 117

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . PACKAGE MAIN import_stmt program

    PACKAGE         shift and go to state 2

    start                          shift and go to state 1

state 1

    (0) S' -> start .



state 2

    (1) start -> PACKAGE . MAIN import_stmt program

    MAIN            shift and go to state 3


state 3

    (1) start -> PACKAGE MAIN . import_stmt program
    (2) import_stmt -> . IMPORT LPAREN STRING RPAREN
    (3) import_stmt -> . IMPORT STRING

    IMPORT          shift and go to state 5

    import_stmt                    shift and go to state 4

state 4

    (1) start -> PACKAGE MAIN import_stmt . program
    (4) program -> . statement
    (5) program -> . statement program
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . print_stmt
    (9) statement -> . input_stmt
    (10) statement -> . continue_stmt
    (11) statement -> . struct_method
    (12) statement -> . func_def
    (13) statement -> . func_no_params
    (14) statement -> . func_call
    (15) statement -> . if_stmt
    (16) statement -> . for_stmt
    (17) statement -> . struct_def
    (18) statement -> . switch_stmt
    (19) statement -> . map_declaration
    (20) statement -> . map_declaration_values
    (21) statement -> . array_declaration
    (22) statement -> . array_literal
    (23) statement -> . slice_declaration
    (24) statement -> . make_stmt
    (25) statement -> . new_stmt
    (26) statement -> . break_stmt
    (27) statement -> . increment_stmt
    (28) statement -> . return_stmt
    (29) declaration -> . VAR VARIABLE type
    (30) declaration -> . VAR VARIABLE type ASIG expression
    (31) declaration -> . VAR VARIABLE type ASSIGN expression
    (35) assignment -> . VARIABLE ASSIGN expression
    (36) assignment -> . VARIABLE ASIG expression
    (37) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (38) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (39) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (80) continue_stmt -> . CONTINUE
    (84) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (85) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (40) func_def -> . FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (41) func_def -> . FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (43) func_no_params -> . FUNC VARIABLE LPAREN RPAREN block
    (44) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (45) func_call -> . VARIABLE LPAREN RPAREN
    (76) if_stmt -> . IF expression block
    (77) if_stmt -> . IF expression block ELSE block
    (78) for_stmt -> . FOR expression block
    (79) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update block
    (86) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (95) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (96) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (101) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (102) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (107) map_declaration_values -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
    (111) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (112) array_declaration -> . VAR VARIABLE ASSIGN array_literal
    (113) array_literal -> . LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (116) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (117) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (103) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (104) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (120) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (121) break_stmt -> . BREAK
    (122) increment_stmt -> . VARIABLE INCREMENT
    (123) increment_stmt -> . VARIABLE DECREMENT
    (42) return_stmt -> . RETURN expression

    VAR             shift and go to state 31
    VARIABLE        shift and go to state 32
    FMT             shift and go to state 33
    CONTINUE        shift and go to state 34
    FUNC            shift and go to state 35
    IF              shift and go to state 36
    FOR             shift and go to state 37
    TYPE            shift and go to state 38
    SWITCH          shift and go to state 39
    LBRACKET        shift and go to state 40
    BREAK           shift and go to state 41
    RETURN          shift and go to state 42

    program                        shift and go to state 6
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    assignment                     shift and go to state 9
    print_stmt                     shift and go to state 10
    input_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    struct_method                  shift and go to state 13
    func_def                       shift and go to state 14
    func_no_params                 shift and go to state 15
    func_call                      shift and go to state 16
    if_stmt                        shift and go to state 17
    for_stmt                       shift and go to state 18
    struct_def                     shift and go to state 19
    switch_stmt                    shift and go to state 20
    map_declaration                shift and go to state 21
    map_declaration_values         shift and go to state 22
    array_declaration              shift and go to state 23
    array_literal                  shift and go to state 24
    slice_declaration              shift and go to state 25
    make_stmt                      shift and go to state 26
    new_stmt                       shift and go to state 27
    break_stmt                     shift and go to state 28
    increment_stmt                 shift and go to state 29
    return_stmt                    shift and go to state 30

state 5

    (2) import_stmt -> IMPORT . LPAREN STRING RPAREN
    (3) import_stmt -> IMPORT . STRING

    LPAREN          shift and go to state 43
    STRING          shift and go to state 44


state 6

    (1) start -> PACKAGE MAIN import_stmt program .

    $end            reduce using rule 1 (start -> PACKAGE MAIN import_stmt program .)


state 7

    (4) program -> statement .
    (5) program -> statement . program
    (4) program -> . statement
    (5) program -> . statement program
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . print_stmt
    (9) statement -> . input_stmt
    (10) statement -> . continue_stmt
    (11) statement -> . struct_method
    (12) statement -> . func_def
    (13) statement -> . func_no_params
    (14) statement -> . func_call
    (15) statement -> . if_stmt
    (16) statement -> . for_stmt
    (17) statement -> . struct_def
    (18) statement -> . switch_stmt
    (19) statement -> . map_declaration
    (20) statement -> . map_declaration_values
    (21) statement -> . array_declaration
    (22) statement -> . array_literal
    (23) statement -> . slice_declaration
    (24) statement -> . make_stmt
    (25) statement -> . new_stmt
    (26) statement -> . break_stmt
    (27) statement -> . increment_stmt
    (28) statement -> . return_stmt
    (29) declaration -> . VAR VARIABLE type
    (30) declaration -> . VAR VARIABLE type ASIG expression
    (31) declaration -> . VAR VARIABLE type ASSIGN expression
    (35) assignment -> . VARIABLE ASSIGN expression
    (36) assignment -> . VARIABLE ASIG expression
    (37) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (38) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (39) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (80) continue_stmt -> . CONTINUE
    (84) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (85) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (40) func_def -> . FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (41) func_def -> . FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (43) func_no_params -> . FUNC VARIABLE LPAREN RPAREN block
    (44) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (45) func_call -> . VARIABLE LPAREN RPAREN
    (76) if_stmt -> . IF expression block
    (77) if_stmt -> . IF expression block ELSE block
    (78) for_stmt -> . FOR expression block
    (79) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update block
    (86) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (95) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (96) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (101) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (102) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (107) map_declaration_values -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
    (111) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (112) array_declaration -> . VAR VARIABLE ASSIGN array_literal
    (113) array_literal -> . LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (116) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (117) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (103) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (104) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (120) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (121) break_stmt -> . BREAK
    (122) increment_stmt -> . VARIABLE INCREMENT
    (123) increment_stmt -> . VARIABLE DECREMENT
    (42) return_stmt -> . RETURN expression

    $end            reduce using rule 4 (program -> statement .)
    RBRACE          reduce using rule 4 (program -> statement .)
    CASE            reduce using rule 4 (program -> statement .)
    DEFAULT         reduce using rule 4 (program -> statement .)
    VAR             shift and go to state 31
    VARIABLE        shift and go to state 32
    FMT             shift and go to state 33
    CONTINUE        shift and go to state 34
    FUNC            shift and go to state 35
    IF              shift and go to state 36
    FOR             shift and go to state 37
    TYPE            shift and go to state 38
    SWITCH          shift and go to state 39
    LBRACKET        shift and go to state 40
    BREAK           shift and go to state 41
    RETURN          shift and go to state 42

    statement                      shift and go to state 7
    program                        shift and go to state 45
    declaration                    shift and go to state 8
    assignment                     shift and go to state 9
    print_stmt                     shift and go to state 10
    input_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    struct_method                  shift and go to state 13
    func_def                       shift and go to state 14
    func_no_params                 shift and go to state 15
    func_call                      shift and go to state 16
    if_stmt                        shift and go to state 17
    for_stmt                       shift and go to state 18
    struct_def                     shift and go to state 19
    switch_stmt                    shift and go to state 20
    map_declaration                shift and go to state 21
    map_declaration_values         shift and go to state 22
    array_declaration              shift and go to state 23
    array_literal                  shift and go to state 24
    slice_declaration              shift and go to state 25
    make_stmt                      shift and go to state 26
    new_stmt                       shift and go to state 27
    break_stmt                     shift and go to state 28
    increment_stmt                 shift and go to state 29
    return_stmt                    shift and go to state 30

state 8

    (6) statement -> declaration .

    VAR             reduce using rule 6 (statement -> declaration .)
    VARIABLE        reduce using rule 6 (statement -> declaration .)
    FMT             reduce using rule 6 (statement -> declaration .)
    CONTINUE        reduce using rule 6 (statement -> declaration .)
    FUNC            reduce using rule 6 (statement -> declaration .)
    IF              reduce using rule 6 (statement -> declaration .)
    FOR             reduce using rule 6 (statement -> declaration .)
    TYPE            reduce using rule 6 (statement -> declaration .)
    SWITCH          reduce using rule 6 (statement -> declaration .)
    LBRACKET        reduce using rule 6 (statement -> declaration .)
    BREAK           reduce using rule 6 (statement -> declaration .)
    RETURN          reduce using rule 6 (statement -> declaration .)
    $end            reduce using rule 6 (statement -> declaration .)
    RBRACE          reduce using rule 6 (statement -> declaration .)
    CASE            reduce using rule 6 (statement -> declaration .)
    DEFAULT         reduce using rule 6 (statement -> declaration .)


state 9

    (7) statement -> assignment .

    VAR             reduce using rule 7 (statement -> assignment .)
    VARIABLE        reduce using rule 7 (statement -> assignment .)
    FMT             reduce using rule 7 (statement -> assignment .)
    CONTINUE        reduce using rule 7 (statement -> assignment .)
    FUNC            reduce using rule 7 (statement -> assignment .)
    IF              reduce using rule 7 (statement -> assignment .)
    FOR             reduce using rule 7 (statement -> assignment .)
    TYPE            reduce using rule 7 (statement -> assignment .)
    SWITCH          reduce using rule 7 (statement -> assignment .)
    LBRACKET        reduce using rule 7 (statement -> assignment .)
    BREAK           reduce using rule 7 (statement -> assignment .)
    RETURN          reduce using rule 7 (statement -> assignment .)
    $end            reduce using rule 7 (statement -> assignment .)
    RBRACE          reduce using rule 7 (statement -> assignment .)
    CASE            reduce using rule 7 (statement -> assignment .)
    DEFAULT         reduce using rule 7 (statement -> assignment .)


state 10

    (8) statement -> print_stmt .

    VAR             reduce using rule 8 (statement -> print_stmt .)
    VARIABLE        reduce using rule 8 (statement -> print_stmt .)
    FMT             reduce using rule 8 (statement -> print_stmt .)
    CONTINUE        reduce using rule 8 (statement -> print_stmt .)
    FUNC            reduce using rule 8 (statement -> print_stmt .)
    IF              reduce using rule 8 (statement -> print_stmt .)
    FOR             reduce using rule 8 (statement -> print_stmt .)
    TYPE            reduce using rule 8 (statement -> print_stmt .)
    SWITCH          reduce using rule 8 (statement -> print_stmt .)
    LBRACKET        reduce using rule 8 (statement -> print_stmt .)
    BREAK           reduce using rule 8 (statement -> print_stmt .)
    RETURN          reduce using rule 8 (statement -> print_stmt .)
    $end            reduce using rule 8 (statement -> print_stmt .)
    RBRACE          reduce using rule 8 (statement -> print_stmt .)
    CASE            reduce using rule 8 (statement -> print_stmt .)
    DEFAULT         reduce using rule 8 (statement -> print_stmt .)


state 11

    (9) statement -> input_stmt .

    VAR             reduce using rule 9 (statement -> input_stmt .)
    VARIABLE        reduce using rule 9 (statement -> input_stmt .)
    FMT             reduce using rule 9 (statement -> input_stmt .)
    CONTINUE        reduce using rule 9 (statement -> input_stmt .)
    FUNC            reduce using rule 9 (statement -> input_stmt .)
    IF              reduce using rule 9 (statement -> input_stmt .)
    FOR             reduce using rule 9 (statement -> input_stmt .)
    TYPE            reduce using rule 9 (statement -> input_stmt .)
    SWITCH          reduce using rule 9 (statement -> input_stmt .)
    LBRACKET        reduce using rule 9 (statement -> input_stmt .)
    BREAK           reduce using rule 9 (statement -> input_stmt .)
    RETURN          reduce using rule 9 (statement -> input_stmt .)
    $end            reduce using rule 9 (statement -> input_stmt .)
    RBRACE          reduce using rule 9 (statement -> input_stmt .)
    CASE            reduce using rule 9 (statement -> input_stmt .)
    DEFAULT         reduce using rule 9 (statement -> input_stmt .)


state 12

    (10) statement -> continue_stmt .

    VAR             reduce using rule 10 (statement -> continue_stmt .)
    VARIABLE        reduce using rule 10 (statement -> continue_stmt .)
    FMT             reduce using rule 10 (statement -> continue_stmt .)
    CONTINUE        reduce using rule 10 (statement -> continue_stmt .)
    FUNC            reduce using rule 10 (statement -> continue_stmt .)
    IF              reduce using rule 10 (statement -> continue_stmt .)
    FOR             reduce using rule 10 (statement -> continue_stmt .)
    TYPE            reduce using rule 10 (statement -> continue_stmt .)
    SWITCH          reduce using rule 10 (statement -> continue_stmt .)
    LBRACKET        reduce using rule 10 (statement -> continue_stmt .)
    BREAK           reduce using rule 10 (statement -> continue_stmt .)
    RETURN          reduce using rule 10 (statement -> continue_stmt .)
    $end            reduce using rule 10 (statement -> continue_stmt .)
    RBRACE          reduce using rule 10 (statement -> continue_stmt .)
    CASE            reduce using rule 10 (statement -> continue_stmt .)
    DEFAULT         reduce using rule 10 (statement -> continue_stmt .)


state 13

    (11) statement -> struct_method .

    VAR             reduce using rule 11 (statement -> struct_method .)
    VARIABLE        reduce using rule 11 (statement -> struct_method .)
    FMT             reduce using rule 11 (statement -> struct_method .)
    CONTINUE        reduce using rule 11 (statement -> struct_method .)
    FUNC            reduce using rule 11 (statement -> struct_method .)
    IF              reduce using rule 11 (statement -> struct_method .)
    FOR             reduce using rule 11 (statement -> struct_method .)
    TYPE            reduce using rule 11 (statement -> struct_method .)
    SWITCH          reduce using rule 11 (statement -> struct_method .)
    LBRACKET        reduce using rule 11 (statement -> struct_method .)
    BREAK           reduce using rule 11 (statement -> struct_method .)
    RETURN          reduce using rule 11 (statement -> struct_method .)
    $end            reduce using rule 11 (statement -> struct_method .)
    RBRACE          reduce using rule 11 (statement -> struct_method .)
    CASE            reduce using rule 11 (statement -> struct_method .)
    DEFAULT         reduce using rule 11 (statement -> struct_method .)


state 14

    (12) statement -> func_def .

    VAR             reduce using rule 12 (statement -> func_def .)
    VARIABLE        reduce using rule 12 (statement -> func_def .)
    FMT             reduce using rule 12 (statement -> func_def .)
    CONTINUE        reduce using rule 12 (statement -> func_def .)
    FUNC            reduce using rule 12 (statement -> func_def .)
    IF              reduce using rule 12 (statement -> func_def .)
    FOR             reduce using rule 12 (statement -> func_def .)
    TYPE            reduce using rule 12 (statement -> func_def .)
    SWITCH          reduce using rule 12 (statement -> func_def .)
    LBRACKET        reduce using rule 12 (statement -> func_def .)
    BREAK           reduce using rule 12 (statement -> func_def .)
    RETURN          reduce using rule 12 (statement -> func_def .)
    $end            reduce using rule 12 (statement -> func_def .)
    RBRACE          reduce using rule 12 (statement -> func_def .)
    CASE            reduce using rule 12 (statement -> func_def .)
    DEFAULT         reduce using rule 12 (statement -> func_def .)


state 15

    (13) statement -> func_no_params .

    VAR             reduce using rule 13 (statement -> func_no_params .)
    VARIABLE        reduce using rule 13 (statement -> func_no_params .)
    FMT             reduce using rule 13 (statement -> func_no_params .)
    CONTINUE        reduce using rule 13 (statement -> func_no_params .)
    FUNC            reduce using rule 13 (statement -> func_no_params .)
    IF              reduce using rule 13 (statement -> func_no_params .)
    FOR             reduce using rule 13 (statement -> func_no_params .)
    TYPE            reduce using rule 13 (statement -> func_no_params .)
    SWITCH          reduce using rule 13 (statement -> func_no_params .)
    LBRACKET        reduce using rule 13 (statement -> func_no_params .)
    BREAK           reduce using rule 13 (statement -> func_no_params .)
    RETURN          reduce using rule 13 (statement -> func_no_params .)
    $end            reduce using rule 13 (statement -> func_no_params .)
    RBRACE          reduce using rule 13 (statement -> func_no_params .)
    CASE            reduce using rule 13 (statement -> func_no_params .)
    DEFAULT         reduce using rule 13 (statement -> func_no_params .)


state 16

    (14) statement -> func_call .

    VAR             reduce using rule 14 (statement -> func_call .)
    VARIABLE        reduce using rule 14 (statement -> func_call .)
    FMT             reduce using rule 14 (statement -> func_call .)
    CONTINUE        reduce using rule 14 (statement -> func_call .)
    FUNC            reduce using rule 14 (statement -> func_call .)
    IF              reduce using rule 14 (statement -> func_call .)
    FOR             reduce using rule 14 (statement -> func_call .)
    TYPE            reduce using rule 14 (statement -> func_call .)
    SWITCH          reduce using rule 14 (statement -> func_call .)
    LBRACKET        reduce using rule 14 (statement -> func_call .)
    BREAK           reduce using rule 14 (statement -> func_call .)
    RETURN          reduce using rule 14 (statement -> func_call .)
    $end            reduce using rule 14 (statement -> func_call .)
    RBRACE          reduce using rule 14 (statement -> func_call .)
    CASE            reduce using rule 14 (statement -> func_call .)
    DEFAULT         reduce using rule 14 (statement -> func_call .)


state 17

    (15) statement -> if_stmt .

    VAR             reduce using rule 15 (statement -> if_stmt .)
    VARIABLE        reduce using rule 15 (statement -> if_stmt .)
    FMT             reduce using rule 15 (statement -> if_stmt .)
    CONTINUE        reduce using rule 15 (statement -> if_stmt .)
    FUNC            reduce using rule 15 (statement -> if_stmt .)
    IF              reduce using rule 15 (statement -> if_stmt .)
    FOR             reduce using rule 15 (statement -> if_stmt .)
    TYPE            reduce using rule 15 (statement -> if_stmt .)
    SWITCH          reduce using rule 15 (statement -> if_stmt .)
    LBRACKET        reduce using rule 15 (statement -> if_stmt .)
    BREAK           reduce using rule 15 (statement -> if_stmt .)
    RETURN          reduce using rule 15 (statement -> if_stmt .)
    $end            reduce using rule 15 (statement -> if_stmt .)
    RBRACE          reduce using rule 15 (statement -> if_stmt .)
    CASE            reduce using rule 15 (statement -> if_stmt .)
    DEFAULT         reduce using rule 15 (statement -> if_stmt .)


state 18

    (16) statement -> for_stmt .

    VAR             reduce using rule 16 (statement -> for_stmt .)
    VARIABLE        reduce using rule 16 (statement -> for_stmt .)
    FMT             reduce using rule 16 (statement -> for_stmt .)
    CONTINUE        reduce using rule 16 (statement -> for_stmt .)
    FUNC            reduce using rule 16 (statement -> for_stmt .)
    IF              reduce using rule 16 (statement -> for_stmt .)
    FOR             reduce using rule 16 (statement -> for_stmt .)
    TYPE            reduce using rule 16 (statement -> for_stmt .)
    SWITCH          reduce using rule 16 (statement -> for_stmt .)
    LBRACKET        reduce using rule 16 (statement -> for_stmt .)
    BREAK           reduce using rule 16 (statement -> for_stmt .)
    RETURN          reduce using rule 16 (statement -> for_stmt .)
    $end            reduce using rule 16 (statement -> for_stmt .)
    RBRACE          reduce using rule 16 (statement -> for_stmt .)
    CASE            reduce using rule 16 (statement -> for_stmt .)
    DEFAULT         reduce using rule 16 (statement -> for_stmt .)


state 19

    (17) statement -> struct_def .

    VAR             reduce using rule 17 (statement -> struct_def .)
    VARIABLE        reduce using rule 17 (statement -> struct_def .)
    FMT             reduce using rule 17 (statement -> struct_def .)
    CONTINUE        reduce using rule 17 (statement -> struct_def .)
    FUNC            reduce using rule 17 (statement -> struct_def .)
    IF              reduce using rule 17 (statement -> struct_def .)
    FOR             reduce using rule 17 (statement -> struct_def .)
    TYPE            reduce using rule 17 (statement -> struct_def .)
    SWITCH          reduce using rule 17 (statement -> struct_def .)
    LBRACKET        reduce using rule 17 (statement -> struct_def .)
    BREAK           reduce using rule 17 (statement -> struct_def .)
    RETURN          reduce using rule 17 (statement -> struct_def .)
    $end            reduce using rule 17 (statement -> struct_def .)
    RBRACE          reduce using rule 17 (statement -> struct_def .)
    CASE            reduce using rule 17 (statement -> struct_def .)
    DEFAULT         reduce using rule 17 (statement -> struct_def .)


state 20

    (18) statement -> switch_stmt .

    VAR             reduce using rule 18 (statement -> switch_stmt .)
    VARIABLE        reduce using rule 18 (statement -> switch_stmt .)
    FMT             reduce using rule 18 (statement -> switch_stmt .)
    CONTINUE        reduce using rule 18 (statement -> switch_stmt .)
    FUNC            reduce using rule 18 (statement -> switch_stmt .)
    IF              reduce using rule 18 (statement -> switch_stmt .)
    FOR             reduce using rule 18 (statement -> switch_stmt .)
    TYPE            reduce using rule 18 (statement -> switch_stmt .)
    SWITCH          reduce using rule 18 (statement -> switch_stmt .)
    LBRACKET        reduce using rule 18 (statement -> switch_stmt .)
    BREAK           reduce using rule 18 (statement -> switch_stmt .)
    RETURN          reduce using rule 18 (statement -> switch_stmt .)
    $end            reduce using rule 18 (statement -> switch_stmt .)
    RBRACE          reduce using rule 18 (statement -> switch_stmt .)
    CASE            reduce using rule 18 (statement -> switch_stmt .)
    DEFAULT         reduce using rule 18 (statement -> switch_stmt .)


state 21

    (19) statement -> map_declaration .

    VAR             reduce using rule 19 (statement -> map_declaration .)
    VARIABLE        reduce using rule 19 (statement -> map_declaration .)
    FMT             reduce using rule 19 (statement -> map_declaration .)
    CONTINUE        reduce using rule 19 (statement -> map_declaration .)
    FUNC            reduce using rule 19 (statement -> map_declaration .)
    IF              reduce using rule 19 (statement -> map_declaration .)
    FOR             reduce using rule 19 (statement -> map_declaration .)
    TYPE            reduce using rule 19 (statement -> map_declaration .)
    SWITCH          reduce using rule 19 (statement -> map_declaration .)
    LBRACKET        reduce using rule 19 (statement -> map_declaration .)
    BREAK           reduce using rule 19 (statement -> map_declaration .)
    RETURN          reduce using rule 19 (statement -> map_declaration .)
    $end            reduce using rule 19 (statement -> map_declaration .)
    RBRACE          reduce using rule 19 (statement -> map_declaration .)
    CASE            reduce using rule 19 (statement -> map_declaration .)
    DEFAULT         reduce using rule 19 (statement -> map_declaration .)


state 22

    (20) statement -> map_declaration_values .

    VAR             reduce using rule 20 (statement -> map_declaration_values .)
    VARIABLE        reduce using rule 20 (statement -> map_declaration_values .)
    FMT             reduce using rule 20 (statement -> map_declaration_values .)
    CONTINUE        reduce using rule 20 (statement -> map_declaration_values .)
    FUNC            reduce using rule 20 (statement -> map_declaration_values .)
    IF              reduce using rule 20 (statement -> map_declaration_values .)
    FOR             reduce using rule 20 (statement -> map_declaration_values .)
    TYPE            reduce using rule 20 (statement -> map_declaration_values .)
    SWITCH          reduce using rule 20 (statement -> map_declaration_values .)
    LBRACKET        reduce using rule 20 (statement -> map_declaration_values .)
    BREAK           reduce using rule 20 (statement -> map_declaration_values .)
    RETURN          reduce using rule 20 (statement -> map_declaration_values .)
    $end            reduce using rule 20 (statement -> map_declaration_values .)
    RBRACE          reduce using rule 20 (statement -> map_declaration_values .)
    CASE            reduce using rule 20 (statement -> map_declaration_values .)
    DEFAULT         reduce using rule 20 (statement -> map_declaration_values .)


state 23

    (21) statement -> array_declaration .

    VAR             reduce using rule 21 (statement -> array_declaration .)
    VARIABLE        reduce using rule 21 (statement -> array_declaration .)
    FMT             reduce using rule 21 (statement -> array_declaration .)
    CONTINUE        reduce using rule 21 (statement -> array_declaration .)
    FUNC            reduce using rule 21 (statement -> array_declaration .)
    IF              reduce using rule 21 (statement -> array_declaration .)
    FOR             reduce using rule 21 (statement -> array_declaration .)
    TYPE            reduce using rule 21 (statement -> array_declaration .)
    SWITCH          reduce using rule 21 (statement -> array_declaration .)
    LBRACKET        reduce using rule 21 (statement -> array_declaration .)
    BREAK           reduce using rule 21 (statement -> array_declaration .)
    RETURN          reduce using rule 21 (statement -> array_declaration .)
    $end            reduce using rule 21 (statement -> array_declaration .)
    RBRACE          reduce using rule 21 (statement -> array_declaration .)
    CASE            reduce using rule 21 (statement -> array_declaration .)
    DEFAULT         reduce using rule 21 (statement -> array_declaration .)


state 24

    (22) statement -> array_literal .

    VAR             reduce using rule 22 (statement -> array_literal .)
    VARIABLE        reduce using rule 22 (statement -> array_literal .)
    FMT             reduce using rule 22 (statement -> array_literal .)
    CONTINUE        reduce using rule 22 (statement -> array_literal .)
    FUNC            reduce using rule 22 (statement -> array_literal .)
    IF              reduce using rule 22 (statement -> array_literal .)
    FOR             reduce using rule 22 (statement -> array_literal .)
    TYPE            reduce using rule 22 (statement -> array_literal .)
    SWITCH          reduce using rule 22 (statement -> array_literal .)
    LBRACKET        reduce using rule 22 (statement -> array_literal .)
    BREAK           reduce using rule 22 (statement -> array_literal .)
    RETURN          reduce using rule 22 (statement -> array_literal .)
    $end            reduce using rule 22 (statement -> array_literal .)
    RBRACE          reduce using rule 22 (statement -> array_literal .)
    CASE            reduce using rule 22 (statement -> array_literal .)
    DEFAULT         reduce using rule 22 (statement -> array_literal .)


state 25

    (23) statement -> slice_declaration .

    VAR             reduce using rule 23 (statement -> slice_declaration .)
    VARIABLE        reduce using rule 23 (statement -> slice_declaration .)
    FMT             reduce using rule 23 (statement -> slice_declaration .)
    CONTINUE        reduce using rule 23 (statement -> slice_declaration .)
    FUNC            reduce using rule 23 (statement -> slice_declaration .)
    IF              reduce using rule 23 (statement -> slice_declaration .)
    FOR             reduce using rule 23 (statement -> slice_declaration .)
    TYPE            reduce using rule 23 (statement -> slice_declaration .)
    SWITCH          reduce using rule 23 (statement -> slice_declaration .)
    LBRACKET        reduce using rule 23 (statement -> slice_declaration .)
    BREAK           reduce using rule 23 (statement -> slice_declaration .)
    RETURN          reduce using rule 23 (statement -> slice_declaration .)
    $end            reduce using rule 23 (statement -> slice_declaration .)
    RBRACE          reduce using rule 23 (statement -> slice_declaration .)
    CASE            reduce using rule 23 (statement -> slice_declaration .)
    DEFAULT         reduce using rule 23 (statement -> slice_declaration .)


state 26

    (24) statement -> make_stmt .

    VAR             reduce using rule 24 (statement -> make_stmt .)
    VARIABLE        reduce using rule 24 (statement -> make_stmt .)
    FMT             reduce using rule 24 (statement -> make_stmt .)
    CONTINUE        reduce using rule 24 (statement -> make_stmt .)
    FUNC            reduce using rule 24 (statement -> make_stmt .)
    IF              reduce using rule 24 (statement -> make_stmt .)
    FOR             reduce using rule 24 (statement -> make_stmt .)
    TYPE            reduce using rule 24 (statement -> make_stmt .)
    SWITCH          reduce using rule 24 (statement -> make_stmt .)
    LBRACKET        reduce using rule 24 (statement -> make_stmt .)
    BREAK           reduce using rule 24 (statement -> make_stmt .)
    RETURN          reduce using rule 24 (statement -> make_stmt .)
    $end            reduce using rule 24 (statement -> make_stmt .)
    RBRACE          reduce using rule 24 (statement -> make_stmt .)
    CASE            reduce using rule 24 (statement -> make_stmt .)
    DEFAULT         reduce using rule 24 (statement -> make_stmt .)


state 27

    (25) statement -> new_stmt .

    VAR             reduce using rule 25 (statement -> new_stmt .)
    VARIABLE        reduce using rule 25 (statement -> new_stmt .)
    FMT             reduce using rule 25 (statement -> new_stmt .)
    CONTINUE        reduce using rule 25 (statement -> new_stmt .)
    FUNC            reduce using rule 25 (statement -> new_stmt .)
    IF              reduce using rule 25 (statement -> new_stmt .)
    FOR             reduce using rule 25 (statement -> new_stmt .)
    TYPE            reduce using rule 25 (statement -> new_stmt .)
    SWITCH          reduce using rule 25 (statement -> new_stmt .)
    LBRACKET        reduce using rule 25 (statement -> new_stmt .)
    BREAK           reduce using rule 25 (statement -> new_stmt .)
    RETURN          reduce using rule 25 (statement -> new_stmt .)
    $end            reduce using rule 25 (statement -> new_stmt .)
    RBRACE          reduce using rule 25 (statement -> new_stmt .)
    CASE            reduce using rule 25 (statement -> new_stmt .)
    DEFAULT         reduce using rule 25 (statement -> new_stmt .)


state 28

    (26) statement -> break_stmt .

    VAR             reduce using rule 26 (statement -> break_stmt .)
    VARIABLE        reduce using rule 26 (statement -> break_stmt .)
    FMT             reduce using rule 26 (statement -> break_stmt .)
    CONTINUE        reduce using rule 26 (statement -> break_stmt .)
    FUNC            reduce using rule 26 (statement -> break_stmt .)
    IF              reduce using rule 26 (statement -> break_stmt .)
    FOR             reduce using rule 26 (statement -> break_stmt .)
    TYPE            reduce using rule 26 (statement -> break_stmt .)
    SWITCH          reduce using rule 26 (statement -> break_stmt .)
    LBRACKET        reduce using rule 26 (statement -> break_stmt .)
    BREAK           reduce using rule 26 (statement -> break_stmt .)
    RETURN          reduce using rule 26 (statement -> break_stmt .)
    $end            reduce using rule 26 (statement -> break_stmt .)
    RBRACE          reduce using rule 26 (statement -> break_stmt .)
    CASE            reduce using rule 26 (statement -> break_stmt .)
    DEFAULT         reduce using rule 26 (statement -> break_stmt .)


state 29

    (27) statement -> increment_stmt .

    VAR             reduce using rule 27 (statement -> increment_stmt .)
    VARIABLE        reduce using rule 27 (statement -> increment_stmt .)
    FMT             reduce using rule 27 (statement -> increment_stmt .)
    CONTINUE        reduce using rule 27 (statement -> increment_stmt .)
    FUNC            reduce using rule 27 (statement -> increment_stmt .)
    IF              reduce using rule 27 (statement -> increment_stmt .)
    FOR             reduce using rule 27 (statement -> increment_stmt .)
    TYPE            reduce using rule 27 (statement -> increment_stmt .)
    SWITCH          reduce using rule 27 (statement -> increment_stmt .)
    LBRACKET        reduce using rule 27 (statement -> increment_stmt .)
    BREAK           reduce using rule 27 (statement -> increment_stmt .)
    RETURN          reduce using rule 27 (statement -> increment_stmt .)
    $end            reduce using rule 27 (statement -> increment_stmt .)
    RBRACE          reduce using rule 27 (statement -> increment_stmt .)
    CASE            reduce using rule 27 (statement -> increment_stmt .)
    DEFAULT         reduce using rule 27 (statement -> increment_stmt .)


state 30

    (28) statement -> return_stmt .

    VAR             reduce using rule 28 (statement -> return_stmt .)
    VARIABLE        reduce using rule 28 (statement -> return_stmt .)
    FMT             reduce using rule 28 (statement -> return_stmt .)
    CONTINUE        reduce using rule 28 (statement -> return_stmt .)
    FUNC            reduce using rule 28 (statement -> return_stmt .)
    IF              reduce using rule 28 (statement -> return_stmt .)
    FOR             reduce using rule 28 (statement -> return_stmt .)
    TYPE            reduce using rule 28 (statement -> return_stmt .)
    SWITCH          reduce using rule 28 (statement -> return_stmt .)
    LBRACKET        reduce using rule 28 (statement -> return_stmt .)
    BREAK           reduce using rule 28 (statement -> return_stmt .)
    RETURN          reduce using rule 28 (statement -> return_stmt .)
    $end            reduce using rule 28 (statement -> return_stmt .)
    RBRACE          reduce using rule 28 (statement -> return_stmt .)
    CASE            reduce using rule 28 (statement -> return_stmt .)
    DEFAULT         reduce using rule 28 (statement -> return_stmt .)


state 31

    (29) declaration -> VAR . VARIABLE type
    (30) declaration -> VAR . VARIABLE type ASIG expression
    (31) declaration -> VAR . VARIABLE type ASSIGN expression
    (101) map_declaration -> VAR . VARIABLE MAP LBRACKET type RBRACKET type
    (111) array_declaration -> VAR . VARIABLE LBRACKET NUMBER RBRACKET type
    (112) array_declaration -> VAR . VARIABLE ASSIGN array_literal
    (116) slice_declaration -> VAR . VARIABLE LBRACKET RBRACKET type

    VARIABLE        shift and go to state 46


state 32

    (35) assignment -> VARIABLE . ASSIGN expression
    (36) assignment -> VARIABLE . ASIG expression
    (44) func_call -> VARIABLE . LPAREN arg_list RPAREN
    (45) func_call -> VARIABLE . LPAREN RPAREN
    (102) map_declaration -> VARIABLE . ASIG MAP LBRACKET type RBRACKET type
    (107) map_declaration_values -> VARIABLE . ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
    (117) slice_declaration -> VARIABLE . ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (103) make_stmt -> VARIABLE . ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (104) make_stmt -> VARIABLE . ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (120) new_stmt -> VARIABLE . ASIG NEW LPAREN VARIABLE RPAREN
    (122) increment_stmt -> VARIABLE . INCREMENT
    (123) increment_stmt -> VARIABLE . DECREMENT

    ASSIGN          shift and go to state 47
    ASIG            shift and go to state 48
    LPAREN          shift and go to state 49
    INCREMENT       shift and go to state 50
    DECREMENT       shift and go to state 51


state 33

    (37) print_stmt -> FMT . DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (38) print_stmt -> FMT . DOT PRINTLN LPAREN expression RPAREN
    (39) input_stmt -> FMT . DOT SCANLN LPAREN AMPER VARIABLE RPAREN

    DOT             shift and go to state 52


state 34

    (80) continue_stmt -> CONTINUE .

    VAR             reduce using rule 80 (continue_stmt -> CONTINUE .)
    VARIABLE        reduce using rule 80 (continue_stmt -> CONTINUE .)
    FMT             reduce using rule 80 (continue_stmt -> CONTINUE .)
    CONTINUE        reduce using rule 80 (continue_stmt -> CONTINUE .)
    FUNC            reduce using rule 80 (continue_stmt -> CONTINUE .)
    IF              reduce using rule 80 (continue_stmt -> CONTINUE .)
    FOR             reduce using rule 80 (continue_stmt -> CONTINUE .)
    TYPE            reduce using rule 80 (continue_stmt -> CONTINUE .)
    SWITCH          reduce using rule 80 (continue_stmt -> CONTINUE .)
    LBRACKET        reduce using rule 80 (continue_stmt -> CONTINUE .)
    BREAK           reduce using rule 80 (continue_stmt -> CONTINUE .)
    RETURN          reduce using rule 80 (continue_stmt -> CONTINUE .)
    $end            reduce using rule 80 (continue_stmt -> CONTINUE .)
    RBRACE          reduce using rule 80 (continue_stmt -> CONTINUE .)
    CASE            reduce using rule 80 (continue_stmt -> CONTINUE .)
    DEFAULT         reduce using rule 80 (continue_stmt -> CONTINUE .)


state 35

    (84) struct_method -> FUNC . LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (85) struct_method -> FUNC . LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (40) func_def -> FUNC . VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (41) func_def -> FUNC . VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (43) func_no_params -> FUNC . VARIABLE LPAREN RPAREN block

    LPAREN          shift and go to state 53
    VARIABLE        shift and go to state 54


state 36

    (76) if_stmt -> IF . expression block
    (77) if_stmt -> IF . expression block ELSE block
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 55
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 37

    (78) for_stmt -> FOR . expression block
    (79) for_stmt -> FOR . assignment SEMICOLON expression SEMICOLON for_update block
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (35) assignment -> . VARIABLE ASSIGN expression
    (36) assignment -> . VARIABLE ASIG expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 68
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 66
    assignment                     shift and go to state 67
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 38

    (86) struct_def -> TYPE . VARIABLE STRUCT LBRACE struct_fields RBRACE

    VARIABLE        shift and go to state 69


state 39

    (95) switch_stmt -> SWITCH . expression LBRACE case_list RBRACE
    (96) switch_stmt -> SWITCH . LBRACE case_list RBRACE
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    LBRACE          shift and go to state 71
    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 70
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 40

    (113) array_literal -> LBRACKET . NUMBER RBRACKET type LBRACE array_values RBRACE

    NUMBER          shift and go to state 72


state 41

    (121) break_stmt -> BREAK .

    VAR             reduce using rule 121 (break_stmt -> BREAK .)
    VARIABLE        reduce using rule 121 (break_stmt -> BREAK .)
    FMT             reduce using rule 121 (break_stmt -> BREAK .)
    CONTINUE        reduce using rule 121 (break_stmt -> BREAK .)
    FUNC            reduce using rule 121 (break_stmt -> BREAK .)
    IF              reduce using rule 121 (break_stmt -> BREAK .)
    FOR             reduce using rule 121 (break_stmt -> BREAK .)
    TYPE            reduce using rule 121 (break_stmt -> BREAK .)
    SWITCH          reduce using rule 121 (break_stmt -> BREAK .)
    LBRACKET        reduce using rule 121 (break_stmt -> BREAK .)
    BREAK           reduce using rule 121 (break_stmt -> BREAK .)
    RETURN          reduce using rule 121 (break_stmt -> BREAK .)
    $end            reduce using rule 121 (break_stmt -> BREAK .)
    RBRACE          reduce using rule 121 (break_stmt -> BREAK .)
    CASE            reduce using rule 121 (break_stmt -> BREAK .)
    DEFAULT         reduce using rule 121 (break_stmt -> BREAK .)


state 42

    (42) return_stmt -> RETURN . expression
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 73
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 43

    (2) import_stmt -> IMPORT LPAREN . STRING RPAREN

    STRING          shift and go to state 74


state 44

    (3) import_stmt -> IMPORT STRING .

    VAR             reduce using rule 3 (import_stmt -> IMPORT STRING .)
    VARIABLE        reduce using rule 3 (import_stmt -> IMPORT STRING .)
    FMT             reduce using rule 3 (import_stmt -> IMPORT STRING .)
    CONTINUE        reduce using rule 3 (import_stmt -> IMPORT STRING .)
    FUNC            reduce using rule 3 (import_stmt -> IMPORT STRING .)
    IF              reduce using rule 3 (import_stmt -> IMPORT STRING .)
    FOR             reduce using rule 3 (import_stmt -> IMPORT STRING .)
    TYPE            reduce using rule 3 (import_stmt -> IMPORT STRING .)
    SWITCH          reduce using rule 3 (import_stmt -> IMPORT STRING .)
    LBRACKET        reduce using rule 3 (import_stmt -> IMPORT STRING .)
    BREAK           reduce using rule 3 (import_stmt -> IMPORT STRING .)
    RETURN          reduce using rule 3 (import_stmt -> IMPORT STRING .)


state 45

    (5) program -> statement program .

    $end            reduce using rule 5 (program -> statement program .)
    RBRACE          reduce using rule 5 (program -> statement program .)
    CASE            reduce using rule 5 (program -> statement program .)
    DEFAULT         reduce using rule 5 (program -> statement program .)


state 46

    (29) declaration -> VAR VARIABLE . type
    (30) declaration -> VAR VARIABLE . type ASIG expression
    (31) declaration -> VAR VARIABLE . type ASSIGN expression
    (101) map_declaration -> VAR VARIABLE . MAP LBRACKET type RBRACKET type
    (111) array_declaration -> VAR VARIABLE . LBRACKET NUMBER RBRACKET type
    (112) array_declaration -> VAR VARIABLE . ASSIGN array_literal
    (116) slice_declaration -> VAR VARIABLE . LBRACKET RBRACKET type
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE

    MAP             shift and go to state 77
    LBRACKET        shift and go to state 78
    ASSIGN          shift and go to state 76
    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82

    type                           shift and go to state 75

state 47

    (35) assignment -> VARIABLE ASSIGN . expression
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 83
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 48

    (36) assignment -> VARIABLE ASIG . expression
    (102) map_declaration -> VARIABLE ASIG . MAP LBRACKET type RBRACKET type
    (107) map_declaration_values -> VARIABLE ASIG . MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
    (117) slice_declaration -> VARIABLE ASIG . LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (103) make_stmt -> VARIABLE ASIG . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (104) make_stmt -> VARIABLE ASIG . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (120) new_stmt -> VARIABLE ASIG . NEW LPAREN VARIABLE RPAREN
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    MAP             shift and go to state 85
    LBRACKET        shift and go to state 86
    MAKE            shift and go to state 87
    NEW             shift and go to state 88
    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62

    expression                     shift and go to state 84
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 49

    (44) func_call -> VARIABLE LPAREN . arg_list RPAREN
    (45) func_call -> VARIABLE LPAREN . RPAREN
    (49) arg_list -> . expression
    (50) arg_list -> . expression COMMA arg_list
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    RPAREN          shift and go to state 90
    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    arg_list                       shift and go to state 89
    expression                     shift and go to state 91
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 50

    (122) increment_stmt -> VARIABLE INCREMENT .

    VAR             reduce using rule 122 (increment_stmt -> VARIABLE INCREMENT .)
    VARIABLE        reduce using rule 122 (increment_stmt -> VARIABLE INCREMENT .)
    FMT             reduce using rule 122 (increment_stmt -> VARIABLE INCREMENT .)
    CONTINUE        reduce using rule 122 (increment_stmt -> VARIABLE INCREMENT .)
    FUNC            reduce using rule 122 (increment_stmt -> VARIABLE INCREMENT .)
    IF              reduce using rule 122 (increment_stmt -> VARIABLE INCREMENT .)
    FOR             reduce using rule 122 (increment_stmt -> VARIABLE INCREMENT .)
    TYPE            reduce using rule 122 (increment_stmt -> VARIABLE INCREMENT .)
    SWITCH          reduce using rule 122 (increment_stmt -> VARIABLE INCREMENT .)
    LBRACKET        reduce using rule 122 (increment_stmt -> VARIABLE INCREMENT .)
    BREAK           reduce using rule 122 (increment_stmt -> VARIABLE INCREMENT .)
    RETURN          reduce using rule 122 (increment_stmt -> VARIABLE INCREMENT .)
    $end            reduce using rule 122 (increment_stmt -> VARIABLE INCREMENT .)
    RBRACE          reduce using rule 122 (increment_stmt -> VARIABLE INCREMENT .)
    CASE            reduce using rule 122 (increment_stmt -> VARIABLE INCREMENT .)
    DEFAULT         reduce using rule 122 (increment_stmt -> VARIABLE INCREMENT .)
    LBRACE          reduce using rule 122 (increment_stmt -> VARIABLE INCREMENT .)


state 51

    (123) increment_stmt -> VARIABLE DECREMENT .

    VAR             reduce using rule 123 (increment_stmt -> VARIABLE DECREMENT .)
    VARIABLE        reduce using rule 123 (increment_stmt -> VARIABLE DECREMENT .)
    FMT             reduce using rule 123 (increment_stmt -> VARIABLE DECREMENT .)
    CONTINUE        reduce using rule 123 (increment_stmt -> VARIABLE DECREMENT .)
    FUNC            reduce using rule 123 (increment_stmt -> VARIABLE DECREMENT .)
    IF              reduce using rule 123 (increment_stmt -> VARIABLE DECREMENT .)
    FOR             reduce using rule 123 (increment_stmt -> VARIABLE DECREMENT .)
    TYPE            reduce using rule 123 (increment_stmt -> VARIABLE DECREMENT .)
    SWITCH          reduce using rule 123 (increment_stmt -> VARIABLE DECREMENT .)
    LBRACKET        reduce using rule 123 (increment_stmt -> VARIABLE DECREMENT .)
    BREAK           reduce using rule 123 (increment_stmt -> VARIABLE DECREMENT .)
    RETURN          reduce using rule 123 (increment_stmt -> VARIABLE DECREMENT .)
    $end            reduce using rule 123 (increment_stmt -> VARIABLE DECREMENT .)
    RBRACE          reduce using rule 123 (increment_stmt -> VARIABLE DECREMENT .)
    CASE            reduce using rule 123 (increment_stmt -> VARIABLE DECREMENT .)
    DEFAULT         reduce using rule 123 (increment_stmt -> VARIABLE DECREMENT .)
    LBRACE          reduce using rule 123 (increment_stmt -> VARIABLE DECREMENT .)


state 52

    (37) print_stmt -> FMT DOT . PRINTF LPAREN STRING COMMA expression RPAREN
    (38) print_stmt -> FMT DOT . PRINTLN LPAREN expression RPAREN
    (39) input_stmt -> FMT DOT . SCANLN LPAREN AMPER VARIABLE RPAREN

    PRINTF          shift and go to state 92
    PRINTLN         shift and go to state 93
    SCANLN          shift and go to state 94


state 53

    (84) struct_method -> FUNC LPAREN . VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (85) struct_method -> FUNC LPAREN . VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE

    VARIABLE        shift and go to state 95


state 54

    (40) func_def -> FUNC VARIABLE . LPAREN param_list RPAREN type LBRACE program RBRACE
    (41) func_def -> FUNC VARIABLE . LPAREN RPAREN type LBRACE program RBRACE
    (43) func_no_params -> FUNC VARIABLE . LPAREN RPAREN block

    LPAREN          shift and go to state 96


state 55

    (76) if_stmt -> IF expression . block
    (77) if_stmt -> IF expression . block ELSE block
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression
    (83) block -> . LBRACE program RBRACE

    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107
    LBRACE          shift and go to state 108

    block                          shift and go to state 97

state 56

    (32) expression -> NUMBER .
    (65) factor -> NUMBER .

  ! reduce/reduce conflict for PLUS resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for MINUS resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for AND resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for OR resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for EQ resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for NE resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for LT resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for GT resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for LE resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for GE resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for LBRACE resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for VAR resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for FMT resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for FUNC resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for IF resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for FOR resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for TYPE resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for SWITCH resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for BREAK resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for RETURN resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for $end resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for RBRACE resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for CASE resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for COMMA resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 32 (expression -> NUMBER .)
  ! reduce/reduce conflict for COLON resolved using rule 32 (expression -> NUMBER .)
    PLUS            reduce using rule 32 (expression -> NUMBER .)
    MINUS           reduce using rule 32 (expression -> NUMBER .)
    AND             reduce using rule 32 (expression -> NUMBER .)
    OR              reduce using rule 32 (expression -> NUMBER .)
    EQ              reduce using rule 32 (expression -> NUMBER .)
    NE              reduce using rule 32 (expression -> NUMBER .)
    LT              reduce using rule 32 (expression -> NUMBER .)
    GT              reduce using rule 32 (expression -> NUMBER .)
    LE              reduce using rule 32 (expression -> NUMBER .)
    GE              reduce using rule 32 (expression -> NUMBER .)
    LBRACE          reduce using rule 32 (expression -> NUMBER .)
    VAR             reduce using rule 32 (expression -> NUMBER .)
    VARIABLE        reduce using rule 32 (expression -> NUMBER .)
    FMT             reduce using rule 32 (expression -> NUMBER .)
    CONTINUE        reduce using rule 32 (expression -> NUMBER .)
    FUNC            reduce using rule 32 (expression -> NUMBER .)
    IF              reduce using rule 32 (expression -> NUMBER .)
    FOR             reduce using rule 32 (expression -> NUMBER .)
    TYPE            reduce using rule 32 (expression -> NUMBER .)
    SWITCH          reduce using rule 32 (expression -> NUMBER .)
    LBRACKET        reduce using rule 32 (expression -> NUMBER .)
    BREAK           reduce using rule 32 (expression -> NUMBER .)
    RETURN          reduce using rule 32 (expression -> NUMBER .)
    $end            reduce using rule 32 (expression -> NUMBER .)
    RBRACE          reduce using rule 32 (expression -> NUMBER .)
    CASE            reduce using rule 32 (expression -> NUMBER .)
    DEFAULT         reduce using rule 32 (expression -> NUMBER .)
    SEMICOLON       reduce using rule 32 (expression -> NUMBER .)
    COMMA           reduce using rule 32 (expression -> NUMBER .)
    RPAREN          reduce using rule 32 (expression -> NUMBER .)
    COLON           reduce using rule 32 (expression -> NUMBER .)
    TIMES           reduce using rule 65 (factor -> NUMBER .)
    DIVIDE          reduce using rule 65 (factor -> NUMBER .)

  ! PLUS            [ reduce using rule 65 (factor -> NUMBER .) ]
  ! MINUS           [ reduce using rule 65 (factor -> NUMBER .) ]
  ! AND             [ reduce using rule 65 (factor -> NUMBER .) ]
  ! OR              [ reduce using rule 65 (factor -> NUMBER .) ]
  ! EQ              [ reduce using rule 65 (factor -> NUMBER .) ]
  ! NE              [ reduce using rule 65 (factor -> NUMBER .) ]
  ! LT              [ reduce using rule 65 (factor -> NUMBER .) ]
  ! GT              [ reduce using rule 65 (factor -> NUMBER .) ]
  ! LE              [ reduce using rule 65 (factor -> NUMBER .) ]
  ! GE              [ reduce using rule 65 (factor -> NUMBER .) ]
  ! LBRACE          [ reduce using rule 65 (factor -> NUMBER .) ]
  ! VAR             [ reduce using rule 65 (factor -> NUMBER .) ]
  ! VARIABLE        [ reduce using rule 65 (factor -> NUMBER .) ]
  ! FMT             [ reduce using rule 65 (factor -> NUMBER .) ]
  ! CONTINUE        [ reduce using rule 65 (factor -> NUMBER .) ]
  ! FUNC            [ reduce using rule 65 (factor -> NUMBER .) ]
  ! IF              [ reduce using rule 65 (factor -> NUMBER .) ]
  ! FOR             [ reduce using rule 65 (factor -> NUMBER .) ]
  ! TYPE            [ reduce using rule 65 (factor -> NUMBER .) ]
  ! SWITCH          [ reduce using rule 65 (factor -> NUMBER .) ]
  ! LBRACKET        [ reduce using rule 65 (factor -> NUMBER .) ]
  ! BREAK           [ reduce using rule 65 (factor -> NUMBER .) ]
  ! RETURN          [ reduce using rule 65 (factor -> NUMBER .) ]
  ! $end            [ reduce using rule 65 (factor -> NUMBER .) ]
  ! RBRACE          [ reduce using rule 65 (factor -> NUMBER .) ]
  ! CASE            [ reduce using rule 65 (factor -> NUMBER .) ]
  ! DEFAULT         [ reduce using rule 65 (factor -> NUMBER .) ]
  ! SEMICOLON       [ reduce using rule 65 (factor -> NUMBER .) ]
  ! COMMA           [ reduce using rule 65 (factor -> NUMBER .) ]
  ! RPAREN          [ reduce using rule 65 (factor -> NUMBER .) ]
  ! COLON           [ reduce using rule 65 (factor -> NUMBER .) ]


state 57

    (33) expression -> FLOAT .
    (66) factor -> FLOAT .

  ! reduce/reduce conflict for PLUS resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for MINUS resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for AND resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for OR resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for EQ resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for NE resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for LT resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for GT resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for LE resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for GE resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for LBRACE resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for VAR resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for FMT resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for FUNC resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for IF resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for FOR resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for TYPE resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for SWITCH resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for BREAK resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for RETURN resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for $end resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for RBRACE resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for CASE resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for COMMA resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for RPAREN resolved using rule 33 (expression -> FLOAT .)
  ! reduce/reduce conflict for COLON resolved using rule 33 (expression -> FLOAT .)
    PLUS            reduce using rule 33 (expression -> FLOAT .)
    MINUS           reduce using rule 33 (expression -> FLOAT .)
    AND             reduce using rule 33 (expression -> FLOAT .)
    OR              reduce using rule 33 (expression -> FLOAT .)
    EQ              reduce using rule 33 (expression -> FLOAT .)
    NE              reduce using rule 33 (expression -> FLOAT .)
    LT              reduce using rule 33 (expression -> FLOAT .)
    GT              reduce using rule 33 (expression -> FLOAT .)
    LE              reduce using rule 33 (expression -> FLOAT .)
    GE              reduce using rule 33 (expression -> FLOAT .)
    LBRACE          reduce using rule 33 (expression -> FLOAT .)
    VAR             reduce using rule 33 (expression -> FLOAT .)
    VARIABLE        reduce using rule 33 (expression -> FLOAT .)
    FMT             reduce using rule 33 (expression -> FLOAT .)
    CONTINUE        reduce using rule 33 (expression -> FLOAT .)
    FUNC            reduce using rule 33 (expression -> FLOAT .)
    IF              reduce using rule 33 (expression -> FLOAT .)
    FOR             reduce using rule 33 (expression -> FLOAT .)
    TYPE            reduce using rule 33 (expression -> FLOAT .)
    SWITCH          reduce using rule 33 (expression -> FLOAT .)
    LBRACKET        reduce using rule 33 (expression -> FLOAT .)
    BREAK           reduce using rule 33 (expression -> FLOAT .)
    RETURN          reduce using rule 33 (expression -> FLOAT .)
    $end            reduce using rule 33 (expression -> FLOAT .)
    RBRACE          reduce using rule 33 (expression -> FLOAT .)
    CASE            reduce using rule 33 (expression -> FLOAT .)
    DEFAULT         reduce using rule 33 (expression -> FLOAT .)
    SEMICOLON       reduce using rule 33 (expression -> FLOAT .)
    COMMA           reduce using rule 33 (expression -> FLOAT .)
    RPAREN          reduce using rule 33 (expression -> FLOAT .)
    COLON           reduce using rule 33 (expression -> FLOAT .)
    TIMES           reduce using rule 66 (factor -> FLOAT .)
    DIVIDE          reduce using rule 66 (factor -> FLOAT .)

  ! PLUS            [ reduce using rule 66 (factor -> FLOAT .) ]
  ! MINUS           [ reduce using rule 66 (factor -> FLOAT .) ]
  ! AND             [ reduce using rule 66 (factor -> FLOAT .) ]
  ! OR              [ reduce using rule 66 (factor -> FLOAT .) ]
  ! EQ              [ reduce using rule 66 (factor -> FLOAT .) ]
  ! NE              [ reduce using rule 66 (factor -> FLOAT .) ]
  ! LT              [ reduce using rule 66 (factor -> FLOAT .) ]
  ! GT              [ reduce using rule 66 (factor -> FLOAT .) ]
  ! LE              [ reduce using rule 66 (factor -> FLOAT .) ]
  ! GE              [ reduce using rule 66 (factor -> FLOAT .) ]
  ! LBRACE          [ reduce using rule 66 (factor -> FLOAT .) ]
  ! VAR             [ reduce using rule 66 (factor -> FLOAT .) ]
  ! VARIABLE        [ reduce using rule 66 (factor -> FLOAT .) ]
  ! FMT             [ reduce using rule 66 (factor -> FLOAT .) ]
  ! CONTINUE        [ reduce using rule 66 (factor -> FLOAT .) ]
  ! FUNC            [ reduce using rule 66 (factor -> FLOAT .) ]
  ! IF              [ reduce using rule 66 (factor -> FLOAT .) ]
  ! FOR             [ reduce using rule 66 (factor -> FLOAT .) ]
  ! TYPE            [ reduce using rule 66 (factor -> FLOAT .) ]
  ! SWITCH          [ reduce using rule 66 (factor -> FLOAT .) ]
  ! LBRACKET        [ reduce using rule 66 (factor -> FLOAT .) ]
  ! BREAK           [ reduce using rule 66 (factor -> FLOAT .) ]
  ! RETURN          [ reduce using rule 66 (factor -> FLOAT .) ]
  ! $end            [ reduce using rule 66 (factor -> FLOAT .) ]
  ! RBRACE          [ reduce using rule 66 (factor -> FLOAT .) ]
  ! CASE            [ reduce using rule 66 (factor -> FLOAT .) ]
  ! DEFAULT         [ reduce using rule 66 (factor -> FLOAT .) ]
  ! SEMICOLON       [ reduce using rule 66 (factor -> FLOAT .) ]
  ! COMMA           [ reduce using rule 66 (factor -> FLOAT .) ]
  ! RPAREN          [ reduce using rule 66 (factor -> FLOAT .) ]
  ! COLON           [ reduce using rule 66 (factor -> FLOAT .) ]


state 58

    (34) expression -> VARIABLE .
    (68) factor -> VARIABLE .
    (91) struct_instance -> VARIABLE . LBRACE struct_fields_values RBRACE

  ! reduce/reduce conflict for PLUS resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for MINUS resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for AND resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for OR resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for EQ resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for NE resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for LT resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for GT resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for LE resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for GE resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for LBRACE resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for VAR resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for FMT resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for FUNC resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for IF resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for FOR resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for TYPE resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for SWITCH resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for BREAK resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for RETURN resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for $end resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for RBRACE resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for CASE resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for COMMA resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for RPAREN resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for COLON resolved using rule 34 (expression -> VARIABLE .)
  ! shift/reduce conflict for LBRACE resolved as shift
    PLUS            reduce using rule 34 (expression -> VARIABLE .)
    MINUS           reduce using rule 34 (expression -> VARIABLE .)
    AND             reduce using rule 34 (expression -> VARIABLE .)
    OR              reduce using rule 34 (expression -> VARIABLE .)
    EQ              reduce using rule 34 (expression -> VARIABLE .)
    NE              reduce using rule 34 (expression -> VARIABLE .)
    LT              reduce using rule 34 (expression -> VARIABLE .)
    GT              reduce using rule 34 (expression -> VARIABLE .)
    LE              reduce using rule 34 (expression -> VARIABLE .)
    GE              reduce using rule 34 (expression -> VARIABLE .)
    VAR             reduce using rule 34 (expression -> VARIABLE .)
    VARIABLE        reduce using rule 34 (expression -> VARIABLE .)
    FMT             reduce using rule 34 (expression -> VARIABLE .)
    CONTINUE        reduce using rule 34 (expression -> VARIABLE .)
    FUNC            reduce using rule 34 (expression -> VARIABLE .)
    IF              reduce using rule 34 (expression -> VARIABLE .)
    FOR             reduce using rule 34 (expression -> VARIABLE .)
    TYPE            reduce using rule 34 (expression -> VARIABLE .)
    SWITCH          reduce using rule 34 (expression -> VARIABLE .)
    LBRACKET        reduce using rule 34 (expression -> VARIABLE .)
    BREAK           reduce using rule 34 (expression -> VARIABLE .)
    RETURN          reduce using rule 34 (expression -> VARIABLE .)
    $end            reduce using rule 34 (expression -> VARIABLE .)
    RBRACE          reduce using rule 34 (expression -> VARIABLE .)
    CASE            reduce using rule 34 (expression -> VARIABLE .)
    DEFAULT         reduce using rule 34 (expression -> VARIABLE .)
    SEMICOLON       reduce using rule 34 (expression -> VARIABLE .)
    COMMA           reduce using rule 34 (expression -> VARIABLE .)
    RPAREN          reduce using rule 34 (expression -> VARIABLE .)
    COLON           reduce using rule 34 (expression -> VARIABLE .)
    TIMES           reduce using rule 68 (factor -> VARIABLE .)
    DIVIDE          reduce using rule 68 (factor -> VARIABLE .)
    LBRACE          shift and go to state 109

  ! LBRACE          [ reduce using rule 34 (expression -> VARIABLE .) ]
  ! PLUS            [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! MINUS           [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! AND             [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! OR              [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! EQ              [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! NE              [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! LT              [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! GT              [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! LE              [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! GE              [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! LBRACE          [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! VAR             [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! VARIABLE        [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! FMT             [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! CONTINUE        [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! FUNC            [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! IF              [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! FOR             [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! TYPE            [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! SWITCH          [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! LBRACKET        [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! BREAK           [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! RETURN          [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! $end            [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! RBRACE          [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! CASE            [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! DEFAULT         [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! SEMICOLON       [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! COMMA           [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! RPAREN          [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! COLON           [ reduce using rule 68 (factor -> VARIABLE .) ]


state 59

    (51) expression -> term .
    (63) term -> term . TIMES factor
    (64) term -> term . DIVIDE factor

    PLUS            reduce using rule 51 (expression -> term .)
    MINUS           reduce using rule 51 (expression -> term .)
    AND             reduce using rule 51 (expression -> term .)
    OR              reduce using rule 51 (expression -> term .)
    EQ              reduce using rule 51 (expression -> term .)
    NE              reduce using rule 51 (expression -> term .)
    LT              reduce using rule 51 (expression -> term .)
    GT              reduce using rule 51 (expression -> term .)
    LE              reduce using rule 51 (expression -> term .)
    GE              reduce using rule 51 (expression -> term .)
    LBRACE          reduce using rule 51 (expression -> term .)
    VAR             reduce using rule 51 (expression -> term .)
    VARIABLE        reduce using rule 51 (expression -> term .)
    FMT             reduce using rule 51 (expression -> term .)
    CONTINUE        reduce using rule 51 (expression -> term .)
    FUNC            reduce using rule 51 (expression -> term .)
    IF              reduce using rule 51 (expression -> term .)
    FOR             reduce using rule 51 (expression -> term .)
    TYPE            reduce using rule 51 (expression -> term .)
    SWITCH          reduce using rule 51 (expression -> term .)
    LBRACKET        reduce using rule 51 (expression -> term .)
    BREAK           reduce using rule 51 (expression -> term .)
    RETURN          reduce using rule 51 (expression -> term .)
    $end            reduce using rule 51 (expression -> term .)
    RBRACE          reduce using rule 51 (expression -> term .)
    CASE            reduce using rule 51 (expression -> term .)
    DEFAULT         reduce using rule 51 (expression -> term .)
    SEMICOLON       reduce using rule 51 (expression -> term .)
    COMMA           reduce using rule 51 (expression -> term .)
    RPAREN          reduce using rule 51 (expression -> term .)
    COLON           reduce using rule 51 (expression -> term .)
    TIMES           shift and go to state 110
    DIVIDE          shift and go to state 111


state 60

    (62) term -> factor .

    TIMES           reduce using rule 62 (term -> factor .)
    DIVIDE          reduce using rule 62 (term -> factor .)
    PLUS            reduce using rule 62 (term -> factor .)
    MINUS           reduce using rule 62 (term -> factor .)
    AND             reduce using rule 62 (term -> factor .)
    OR              reduce using rule 62 (term -> factor .)
    EQ              reduce using rule 62 (term -> factor .)
    NE              reduce using rule 62 (term -> factor .)
    LT              reduce using rule 62 (term -> factor .)
    GT              reduce using rule 62 (term -> factor .)
    LE              reduce using rule 62 (term -> factor .)
    GE              reduce using rule 62 (term -> factor .)
    LBRACE          reduce using rule 62 (term -> factor .)
    VAR             reduce using rule 62 (term -> factor .)
    VARIABLE        reduce using rule 62 (term -> factor .)
    FMT             reduce using rule 62 (term -> factor .)
    CONTINUE        reduce using rule 62 (term -> factor .)
    FUNC            reduce using rule 62 (term -> factor .)
    IF              reduce using rule 62 (term -> factor .)
    FOR             reduce using rule 62 (term -> factor .)
    TYPE            reduce using rule 62 (term -> factor .)
    SWITCH          reduce using rule 62 (term -> factor .)
    LBRACKET        reduce using rule 62 (term -> factor .)
    BREAK           reduce using rule 62 (term -> factor .)
    RETURN          reduce using rule 62 (term -> factor .)
    $end            reduce using rule 62 (term -> factor .)
    RBRACE          reduce using rule 62 (term -> factor .)
    CASE            reduce using rule 62 (term -> factor .)
    DEFAULT         reduce using rule 62 (term -> factor .)
    SEMICOLON       reduce using rule 62 (term -> factor .)
    COMMA           reduce using rule 62 (term -> factor .)
    RPAREN          reduce using rule 62 (term -> factor .)
    COLON           reduce using rule 62 (term -> factor .)


state 61

    (67) factor -> STRING .

    TIMES           reduce using rule 67 (factor -> STRING .)
    DIVIDE          reduce using rule 67 (factor -> STRING .)
    PLUS            reduce using rule 67 (factor -> STRING .)
    MINUS           reduce using rule 67 (factor -> STRING .)
    AND             reduce using rule 67 (factor -> STRING .)
    OR              reduce using rule 67 (factor -> STRING .)
    EQ              reduce using rule 67 (factor -> STRING .)
    NE              reduce using rule 67 (factor -> STRING .)
    LT              reduce using rule 67 (factor -> STRING .)
    GT              reduce using rule 67 (factor -> STRING .)
    LE              reduce using rule 67 (factor -> STRING .)
    GE              reduce using rule 67 (factor -> STRING .)
    LBRACE          reduce using rule 67 (factor -> STRING .)
    VAR             reduce using rule 67 (factor -> STRING .)
    VARIABLE        reduce using rule 67 (factor -> STRING .)
    FMT             reduce using rule 67 (factor -> STRING .)
    CONTINUE        reduce using rule 67 (factor -> STRING .)
    FUNC            reduce using rule 67 (factor -> STRING .)
    IF              reduce using rule 67 (factor -> STRING .)
    FOR             reduce using rule 67 (factor -> STRING .)
    TYPE            reduce using rule 67 (factor -> STRING .)
    SWITCH          reduce using rule 67 (factor -> STRING .)
    LBRACKET        reduce using rule 67 (factor -> STRING .)
    BREAK           reduce using rule 67 (factor -> STRING .)
    RETURN          reduce using rule 67 (factor -> STRING .)
    $end            reduce using rule 67 (factor -> STRING .)
    RBRACE          reduce using rule 67 (factor -> STRING .)
    CASE            reduce using rule 67 (factor -> STRING .)
    DEFAULT         reduce using rule 67 (factor -> STRING .)
    SEMICOLON       reduce using rule 67 (factor -> STRING .)
    COMMA           reduce using rule 67 (factor -> STRING .)
    RPAREN          reduce using rule 67 (factor -> STRING .)
    COLON           reduce using rule 67 (factor -> STRING .)


state 62

    (69) factor -> LPAREN . expression RPAREN
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 112
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 63

    (70) factor -> make_expr .

    TIMES           reduce using rule 70 (factor -> make_expr .)
    DIVIDE          reduce using rule 70 (factor -> make_expr .)
    PLUS            reduce using rule 70 (factor -> make_expr .)
    MINUS           reduce using rule 70 (factor -> make_expr .)
    AND             reduce using rule 70 (factor -> make_expr .)
    OR              reduce using rule 70 (factor -> make_expr .)
    EQ              reduce using rule 70 (factor -> make_expr .)
    NE              reduce using rule 70 (factor -> make_expr .)
    LT              reduce using rule 70 (factor -> make_expr .)
    GT              reduce using rule 70 (factor -> make_expr .)
    LE              reduce using rule 70 (factor -> make_expr .)
    GE              reduce using rule 70 (factor -> make_expr .)
    LBRACE          reduce using rule 70 (factor -> make_expr .)
    VAR             reduce using rule 70 (factor -> make_expr .)
    VARIABLE        reduce using rule 70 (factor -> make_expr .)
    FMT             reduce using rule 70 (factor -> make_expr .)
    CONTINUE        reduce using rule 70 (factor -> make_expr .)
    FUNC            reduce using rule 70 (factor -> make_expr .)
    IF              reduce using rule 70 (factor -> make_expr .)
    FOR             reduce using rule 70 (factor -> make_expr .)
    TYPE            reduce using rule 70 (factor -> make_expr .)
    SWITCH          reduce using rule 70 (factor -> make_expr .)
    LBRACKET        reduce using rule 70 (factor -> make_expr .)
    BREAK           reduce using rule 70 (factor -> make_expr .)
    RETURN          reduce using rule 70 (factor -> make_expr .)
    $end            reduce using rule 70 (factor -> make_expr .)
    RBRACE          reduce using rule 70 (factor -> make_expr .)
    CASE            reduce using rule 70 (factor -> make_expr .)
    DEFAULT         reduce using rule 70 (factor -> make_expr .)
    SEMICOLON       reduce using rule 70 (factor -> make_expr .)
    COMMA           reduce using rule 70 (factor -> make_expr .)
    RPAREN          reduce using rule 70 (factor -> make_expr .)
    COLON           reduce using rule 70 (factor -> make_expr .)


state 64

    (71) factor -> struct_instance .

    TIMES           reduce using rule 71 (factor -> struct_instance .)
    DIVIDE          reduce using rule 71 (factor -> struct_instance .)
    PLUS            reduce using rule 71 (factor -> struct_instance .)
    MINUS           reduce using rule 71 (factor -> struct_instance .)
    AND             reduce using rule 71 (factor -> struct_instance .)
    OR              reduce using rule 71 (factor -> struct_instance .)
    EQ              reduce using rule 71 (factor -> struct_instance .)
    NE              reduce using rule 71 (factor -> struct_instance .)
    LT              reduce using rule 71 (factor -> struct_instance .)
    GT              reduce using rule 71 (factor -> struct_instance .)
    LE              reduce using rule 71 (factor -> struct_instance .)
    GE              reduce using rule 71 (factor -> struct_instance .)
    LBRACE          reduce using rule 71 (factor -> struct_instance .)
    VAR             reduce using rule 71 (factor -> struct_instance .)
    VARIABLE        reduce using rule 71 (factor -> struct_instance .)
    FMT             reduce using rule 71 (factor -> struct_instance .)
    CONTINUE        reduce using rule 71 (factor -> struct_instance .)
    FUNC            reduce using rule 71 (factor -> struct_instance .)
    IF              reduce using rule 71 (factor -> struct_instance .)
    FOR             reduce using rule 71 (factor -> struct_instance .)
    TYPE            reduce using rule 71 (factor -> struct_instance .)
    SWITCH          reduce using rule 71 (factor -> struct_instance .)
    LBRACKET        reduce using rule 71 (factor -> struct_instance .)
    BREAK           reduce using rule 71 (factor -> struct_instance .)
    RETURN          reduce using rule 71 (factor -> struct_instance .)
    $end            reduce using rule 71 (factor -> struct_instance .)
    RBRACE          reduce using rule 71 (factor -> struct_instance .)
    CASE            reduce using rule 71 (factor -> struct_instance .)
    DEFAULT         reduce using rule 71 (factor -> struct_instance .)
    SEMICOLON       reduce using rule 71 (factor -> struct_instance .)
    COMMA           reduce using rule 71 (factor -> struct_instance .)
    RPAREN          reduce using rule 71 (factor -> struct_instance .)
    COLON           reduce using rule 71 (factor -> struct_instance .)


state 65

    (105) make_expr -> MAKE . LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> MAKE . LPAREN LBRACKET RBRACKET type RPAREN

    LPAREN          shift and go to state 113


state 66

    (78) for_stmt -> FOR expression . block
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression
    (83) block -> . LBRACE program RBRACE

    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107
    LBRACE          shift and go to state 108

    block                          shift and go to state 114

state 67

    (79) for_stmt -> FOR assignment . SEMICOLON expression SEMICOLON for_update block

    SEMICOLON       shift and go to state 115


state 68

    (34) expression -> VARIABLE .
    (35) assignment -> VARIABLE . ASSIGN expression
    (36) assignment -> VARIABLE . ASIG expression
    (68) factor -> VARIABLE .
    (91) struct_instance -> VARIABLE . LBRACE struct_fields_values RBRACE

  ! reduce/reduce conflict for PLUS resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for MINUS resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for AND resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for OR resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for EQ resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for NE resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for LT resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for GT resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for LE resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for GE resolved using rule 34 (expression -> VARIABLE .)
  ! reduce/reduce conflict for LBRACE resolved using rule 34 (expression -> VARIABLE .)
  ! shift/reduce conflict for LBRACE resolved as shift
    PLUS            reduce using rule 34 (expression -> VARIABLE .)
    MINUS           reduce using rule 34 (expression -> VARIABLE .)
    AND             reduce using rule 34 (expression -> VARIABLE .)
    OR              reduce using rule 34 (expression -> VARIABLE .)
    EQ              reduce using rule 34 (expression -> VARIABLE .)
    NE              reduce using rule 34 (expression -> VARIABLE .)
    LT              reduce using rule 34 (expression -> VARIABLE .)
    GT              reduce using rule 34 (expression -> VARIABLE .)
    LE              reduce using rule 34 (expression -> VARIABLE .)
    GE              reduce using rule 34 (expression -> VARIABLE .)
    ASSIGN          shift and go to state 47
    ASIG            shift and go to state 116
    TIMES           reduce using rule 68 (factor -> VARIABLE .)
    DIVIDE          reduce using rule 68 (factor -> VARIABLE .)
    LBRACE          shift and go to state 109

  ! LBRACE          [ reduce using rule 34 (expression -> VARIABLE .) ]
  ! PLUS            [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! MINUS           [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! AND             [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! OR              [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! EQ              [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! NE              [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! LT              [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! GT              [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! LE              [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! GE              [ reduce using rule 68 (factor -> VARIABLE .) ]
  ! LBRACE          [ reduce using rule 68 (factor -> VARIABLE .) ]


state 69

    (86) struct_def -> TYPE VARIABLE . STRUCT LBRACE struct_fields RBRACE

    STRUCT          shift and go to state 117


state 70

    (95) switch_stmt -> SWITCH expression . LBRACE case_list RBRACE
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

    LBRACE          shift and go to state 118
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107


state 71

    (96) switch_stmt -> SWITCH LBRACE . case_list RBRACE
    (97) case_list -> . case_clause
    (98) case_list -> . case_clause case_list
    (99) case_clause -> . CASE expression COLON program
    (100) case_clause -> . DEFAULT COLON program

    CASE            shift and go to state 121
    DEFAULT         shift and go to state 122

    case_list                      shift and go to state 119
    case_clause                    shift and go to state 120

state 72

    (113) array_literal -> LBRACKET NUMBER . RBRACKET type LBRACE array_values RBRACE

    RBRACKET        shift and go to state 123


state 73

    (42) return_stmt -> RETURN expression .
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

    VAR             reduce using rule 42 (return_stmt -> RETURN expression .)
    VARIABLE        reduce using rule 42 (return_stmt -> RETURN expression .)
    FMT             reduce using rule 42 (return_stmt -> RETURN expression .)
    CONTINUE        reduce using rule 42 (return_stmt -> RETURN expression .)
    FUNC            reduce using rule 42 (return_stmt -> RETURN expression .)
    IF              reduce using rule 42 (return_stmt -> RETURN expression .)
    FOR             reduce using rule 42 (return_stmt -> RETURN expression .)
    TYPE            reduce using rule 42 (return_stmt -> RETURN expression .)
    SWITCH          reduce using rule 42 (return_stmt -> RETURN expression .)
    LBRACKET        reduce using rule 42 (return_stmt -> RETURN expression .)
    BREAK           reduce using rule 42 (return_stmt -> RETURN expression .)
    RETURN          reduce using rule 42 (return_stmt -> RETURN expression .)
    $end            reduce using rule 42 (return_stmt -> RETURN expression .)
    RBRACE          reduce using rule 42 (return_stmt -> RETURN expression .)
    CASE            reduce using rule 42 (return_stmt -> RETURN expression .)
    DEFAULT         reduce using rule 42 (return_stmt -> RETURN expression .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107


state 74

    (2) import_stmt -> IMPORT LPAREN STRING . RPAREN

    RPAREN          shift and go to state 124


state 75

    (29) declaration -> VAR VARIABLE type .
    (30) declaration -> VAR VARIABLE type . ASIG expression
    (31) declaration -> VAR VARIABLE type . ASSIGN expression

    VAR             reduce using rule 29 (declaration -> VAR VARIABLE type .)
    VARIABLE        reduce using rule 29 (declaration -> VAR VARIABLE type .)
    FMT             reduce using rule 29 (declaration -> VAR VARIABLE type .)
    CONTINUE        reduce using rule 29 (declaration -> VAR VARIABLE type .)
    FUNC            reduce using rule 29 (declaration -> VAR VARIABLE type .)
    IF              reduce using rule 29 (declaration -> VAR VARIABLE type .)
    FOR             reduce using rule 29 (declaration -> VAR VARIABLE type .)
    TYPE            reduce using rule 29 (declaration -> VAR VARIABLE type .)
    SWITCH          reduce using rule 29 (declaration -> VAR VARIABLE type .)
    LBRACKET        reduce using rule 29 (declaration -> VAR VARIABLE type .)
    BREAK           reduce using rule 29 (declaration -> VAR VARIABLE type .)
    RETURN          reduce using rule 29 (declaration -> VAR VARIABLE type .)
    $end            reduce using rule 29 (declaration -> VAR VARIABLE type .)
    RBRACE          reduce using rule 29 (declaration -> VAR VARIABLE type .)
    CASE            reduce using rule 29 (declaration -> VAR VARIABLE type .)
    DEFAULT         reduce using rule 29 (declaration -> VAR VARIABLE type .)
    ASIG            shift and go to state 125
    ASSIGN          shift and go to state 126


state 76

    (112) array_declaration -> VAR VARIABLE ASSIGN . array_literal
    (113) array_literal -> . LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE

    LBRACKET        shift and go to state 40

    array_literal                  shift and go to state 127

state 77

    (101) map_declaration -> VAR VARIABLE MAP . LBRACKET type RBRACKET type

    LBRACKET        shift and go to state 128


state 78

    (111) array_declaration -> VAR VARIABLE LBRACKET . NUMBER RBRACKET type
    (116) slice_declaration -> VAR VARIABLE LBRACKET . RBRACKET type

    NUMBER          shift and go to state 129
    RBRACKET        shift and go to state 130


state 79

    (72) type -> INT_TYPE .

    ASIG            reduce using rule 72 (type -> INT_TYPE .)
    ASSIGN          reduce using rule 72 (type -> INT_TYPE .)
    VAR             reduce using rule 72 (type -> INT_TYPE .)
    VARIABLE        reduce using rule 72 (type -> INT_TYPE .)
    FMT             reduce using rule 72 (type -> INT_TYPE .)
    CONTINUE        reduce using rule 72 (type -> INT_TYPE .)
    FUNC            reduce using rule 72 (type -> INT_TYPE .)
    IF              reduce using rule 72 (type -> INT_TYPE .)
    FOR             reduce using rule 72 (type -> INT_TYPE .)
    TYPE            reduce using rule 72 (type -> INT_TYPE .)
    SWITCH          reduce using rule 72 (type -> INT_TYPE .)
    LBRACKET        reduce using rule 72 (type -> INT_TYPE .)
    BREAK           reduce using rule 72 (type -> INT_TYPE .)
    RETURN          reduce using rule 72 (type -> INT_TYPE .)
    $end            reduce using rule 72 (type -> INT_TYPE .)
    RBRACE          reduce using rule 72 (type -> INT_TYPE .)
    CASE            reduce using rule 72 (type -> INT_TYPE .)
    DEFAULT         reduce using rule 72 (type -> INT_TYPE .)
    LBRACE          reduce using rule 72 (type -> INT_TYPE .)
    RBRACKET        reduce using rule 72 (type -> INT_TYPE .)
    COMMA           reduce using rule 72 (type -> INT_TYPE .)
    RPAREN          reduce using rule 72 (type -> INT_TYPE .)
    INT_TYPE        reduce using rule 72 (type -> INT_TYPE .)
    FLOAT64_TYPE    reduce using rule 72 (type -> INT_TYPE .)
    STRING_TYPE     reduce using rule 72 (type -> INT_TYPE .)
    BOOL_TYPE       reduce using rule 72 (type -> INT_TYPE .)


state 80

    (73) type -> FLOAT64_TYPE .

    ASIG            reduce using rule 73 (type -> FLOAT64_TYPE .)
    ASSIGN          reduce using rule 73 (type -> FLOAT64_TYPE .)
    VAR             reduce using rule 73 (type -> FLOAT64_TYPE .)
    VARIABLE        reduce using rule 73 (type -> FLOAT64_TYPE .)
    FMT             reduce using rule 73 (type -> FLOAT64_TYPE .)
    CONTINUE        reduce using rule 73 (type -> FLOAT64_TYPE .)
    FUNC            reduce using rule 73 (type -> FLOAT64_TYPE .)
    IF              reduce using rule 73 (type -> FLOAT64_TYPE .)
    FOR             reduce using rule 73 (type -> FLOAT64_TYPE .)
    TYPE            reduce using rule 73 (type -> FLOAT64_TYPE .)
    SWITCH          reduce using rule 73 (type -> FLOAT64_TYPE .)
    LBRACKET        reduce using rule 73 (type -> FLOAT64_TYPE .)
    BREAK           reduce using rule 73 (type -> FLOAT64_TYPE .)
    RETURN          reduce using rule 73 (type -> FLOAT64_TYPE .)
    $end            reduce using rule 73 (type -> FLOAT64_TYPE .)
    RBRACE          reduce using rule 73 (type -> FLOAT64_TYPE .)
    CASE            reduce using rule 73 (type -> FLOAT64_TYPE .)
    DEFAULT         reduce using rule 73 (type -> FLOAT64_TYPE .)
    LBRACE          reduce using rule 73 (type -> FLOAT64_TYPE .)
    RBRACKET        reduce using rule 73 (type -> FLOAT64_TYPE .)
    COMMA           reduce using rule 73 (type -> FLOAT64_TYPE .)
    RPAREN          reduce using rule 73 (type -> FLOAT64_TYPE .)
    INT_TYPE        reduce using rule 73 (type -> FLOAT64_TYPE .)
    FLOAT64_TYPE    reduce using rule 73 (type -> FLOAT64_TYPE .)
    STRING_TYPE     reduce using rule 73 (type -> FLOAT64_TYPE .)
    BOOL_TYPE       reduce using rule 73 (type -> FLOAT64_TYPE .)


state 81

    (74) type -> STRING_TYPE .

    ASIG            reduce using rule 74 (type -> STRING_TYPE .)
    ASSIGN          reduce using rule 74 (type -> STRING_TYPE .)
    VAR             reduce using rule 74 (type -> STRING_TYPE .)
    VARIABLE        reduce using rule 74 (type -> STRING_TYPE .)
    FMT             reduce using rule 74 (type -> STRING_TYPE .)
    CONTINUE        reduce using rule 74 (type -> STRING_TYPE .)
    FUNC            reduce using rule 74 (type -> STRING_TYPE .)
    IF              reduce using rule 74 (type -> STRING_TYPE .)
    FOR             reduce using rule 74 (type -> STRING_TYPE .)
    TYPE            reduce using rule 74 (type -> STRING_TYPE .)
    SWITCH          reduce using rule 74 (type -> STRING_TYPE .)
    LBRACKET        reduce using rule 74 (type -> STRING_TYPE .)
    BREAK           reduce using rule 74 (type -> STRING_TYPE .)
    RETURN          reduce using rule 74 (type -> STRING_TYPE .)
    $end            reduce using rule 74 (type -> STRING_TYPE .)
    RBRACE          reduce using rule 74 (type -> STRING_TYPE .)
    CASE            reduce using rule 74 (type -> STRING_TYPE .)
    DEFAULT         reduce using rule 74 (type -> STRING_TYPE .)
    LBRACE          reduce using rule 74 (type -> STRING_TYPE .)
    RBRACKET        reduce using rule 74 (type -> STRING_TYPE .)
    COMMA           reduce using rule 74 (type -> STRING_TYPE .)
    RPAREN          reduce using rule 74 (type -> STRING_TYPE .)
    INT_TYPE        reduce using rule 74 (type -> STRING_TYPE .)
    FLOAT64_TYPE    reduce using rule 74 (type -> STRING_TYPE .)
    STRING_TYPE     reduce using rule 74 (type -> STRING_TYPE .)
    BOOL_TYPE       reduce using rule 74 (type -> STRING_TYPE .)


state 82

    (75) type -> BOOL_TYPE .

    ASIG            reduce using rule 75 (type -> BOOL_TYPE .)
    ASSIGN          reduce using rule 75 (type -> BOOL_TYPE .)
    VAR             reduce using rule 75 (type -> BOOL_TYPE .)
    VARIABLE        reduce using rule 75 (type -> BOOL_TYPE .)
    FMT             reduce using rule 75 (type -> BOOL_TYPE .)
    CONTINUE        reduce using rule 75 (type -> BOOL_TYPE .)
    FUNC            reduce using rule 75 (type -> BOOL_TYPE .)
    IF              reduce using rule 75 (type -> BOOL_TYPE .)
    FOR             reduce using rule 75 (type -> BOOL_TYPE .)
    TYPE            reduce using rule 75 (type -> BOOL_TYPE .)
    SWITCH          reduce using rule 75 (type -> BOOL_TYPE .)
    LBRACKET        reduce using rule 75 (type -> BOOL_TYPE .)
    BREAK           reduce using rule 75 (type -> BOOL_TYPE .)
    RETURN          reduce using rule 75 (type -> BOOL_TYPE .)
    $end            reduce using rule 75 (type -> BOOL_TYPE .)
    RBRACE          reduce using rule 75 (type -> BOOL_TYPE .)
    CASE            reduce using rule 75 (type -> BOOL_TYPE .)
    DEFAULT         reduce using rule 75 (type -> BOOL_TYPE .)
    LBRACE          reduce using rule 75 (type -> BOOL_TYPE .)
    RBRACKET        reduce using rule 75 (type -> BOOL_TYPE .)
    COMMA           reduce using rule 75 (type -> BOOL_TYPE .)
    RPAREN          reduce using rule 75 (type -> BOOL_TYPE .)
    INT_TYPE        reduce using rule 75 (type -> BOOL_TYPE .)
    FLOAT64_TYPE    reduce using rule 75 (type -> BOOL_TYPE .)
    STRING_TYPE     reduce using rule 75 (type -> BOOL_TYPE .)
    BOOL_TYPE       reduce using rule 75 (type -> BOOL_TYPE .)


state 83

    (35) assignment -> VARIABLE ASSIGN expression .
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

    VAR             reduce using rule 35 (assignment -> VARIABLE ASSIGN expression .)
    VARIABLE        reduce using rule 35 (assignment -> VARIABLE ASSIGN expression .)
    FMT             reduce using rule 35 (assignment -> VARIABLE ASSIGN expression .)
    CONTINUE        reduce using rule 35 (assignment -> VARIABLE ASSIGN expression .)
    FUNC            reduce using rule 35 (assignment -> VARIABLE ASSIGN expression .)
    IF              reduce using rule 35 (assignment -> VARIABLE ASSIGN expression .)
    FOR             reduce using rule 35 (assignment -> VARIABLE ASSIGN expression .)
    TYPE            reduce using rule 35 (assignment -> VARIABLE ASSIGN expression .)
    SWITCH          reduce using rule 35 (assignment -> VARIABLE ASSIGN expression .)
    LBRACKET        reduce using rule 35 (assignment -> VARIABLE ASSIGN expression .)
    BREAK           reduce using rule 35 (assignment -> VARIABLE ASSIGN expression .)
    RETURN          reduce using rule 35 (assignment -> VARIABLE ASSIGN expression .)
    $end            reduce using rule 35 (assignment -> VARIABLE ASSIGN expression .)
    RBRACE          reduce using rule 35 (assignment -> VARIABLE ASSIGN expression .)
    CASE            reduce using rule 35 (assignment -> VARIABLE ASSIGN expression .)
    DEFAULT         reduce using rule 35 (assignment -> VARIABLE ASSIGN expression .)
    SEMICOLON       reduce using rule 35 (assignment -> VARIABLE ASSIGN expression .)
    LBRACE          reduce using rule 35 (assignment -> VARIABLE ASSIGN expression .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107


state 84

    (36) assignment -> VARIABLE ASIG expression .
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

    VAR             reduce using rule 36 (assignment -> VARIABLE ASIG expression .)
    VARIABLE        reduce using rule 36 (assignment -> VARIABLE ASIG expression .)
    FMT             reduce using rule 36 (assignment -> VARIABLE ASIG expression .)
    CONTINUE        reduce using rule 36 (assignment -> VARIABLE ASIG expression .)
    FUNC            reduce using rule 36 (assignment -> VARIABLE ASIG expression .)
    IF              reduce using rule 36 (assignment -> VARIABLE ASIG expression .)
    FOR             reduce using rule 36 (assignment -> VARIABLE ASIG expression .)
    TYPE            reduce using rule 36 (assignment -> VARIABLE ASIG expression .)
    SWITCH          reduce using rule 36 (assignment -> VARIABLE ASIG expression .)
    LBRACKET        reduce using rule 36 (assignment -> VARIABLE ASIG expression .)
    BREAK           reduce using rule 36 (assignment -> VARIABLE ASIG expression .)
    RETURN          reduce using rule 36 (assignment -> VARIABLE ASIG expression .)
    $end            reduce using rule 36 (assignment -> VARIABLE ASIG expression .)
    RBRACE          reduce using rule 36 (assignment -> VARIABLE ASIG expression .)
    CASE            reduce using rule 36 (assignment -> VARIABLE ASIG expression .)
    DEFAULT         reduce using rule 36 (assignment -> VARIABLE ASIG expression .)
    SEMICOLON       reduce using rule 36 (assignment -> VARIABLE ASIG expression .)
    LBRACE          reduce using rule 36 (assignment -> VARIABLE ASIG expression .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107


state 85

    (102) map_declaration -> VARIABLE ASIG MAP . LBRACKET type RBRACKET type
    (107) map_declaration_values -> VARIABLE ASIG MAP . LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE

    LBRACKET        shift and go to state 131


state 86

    (117) slice_declaration -> VARIABLE ASIG LBRACKET . RBRACKET type LBRACE slice_values RBRACE

    RBRACKET        shift and go to state 132


state 87

    (103) make_stmt -> VARIABLE ASIG MAKE . LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (104) make_stmt -> VARIABLE ASIG MAKE . LPAREN LBRACKET RBRACKET type RPAREN
    (105) make_expr -> MAKE . LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> MAKE . LPAREN LBRACKET RBRACKET type RPAREN

    LPAREN          shift and go to state 133


state 88

    (120) new_stmt -> VARIABLE ASIG NEW . LPAREN VARIABLE RPAREN

    LPAREN          shift and go to state 134


state 89

    (44) func_call -> VARIABLE LPAREN arg_list . RPAREN

    RPAREN          shift and go to state 135


state 90

    (45) func_call -> VARIABLE LPAREN RPAREN .

    VAR             reduce using rule 45 (func_call -> VARIABLE LPAREN RPAREN .)
    VARIABLE        reduce using rule 45 (func_call -> VARIABLE LPAREN RPAREN .)
    FMT             reduce using rule 45 (func_call -> VARIABLE LPAREN RPAREN .)
    CONTINUE        reduce using rule 45 (func_call -> VARIABLE LPAREN RPAREN .)
    FUNC            reduce using rule 45 (func_call -> VARIABLE LPAREN RPAREN .)
    IF              reduce using rule 45 (func_call -> VARIABLE LPAREN RPAREN .)
    FOR             reduce using rule 45 (func_call -> VARIABLE LPAREN RPAREN .)
    TYPE            reduce using rule 45 (func_call -> VARIABLE LPAREN RPAREN .)
    SWITCH          reduce using rule 45 (func_call -> VARIABLE LPAREN RPAREN .)
    LBRACKET        reduce using rule 45 (func_call -> VARIABLE LPAREN RPAREN .)
    BREAK           reduce using rule 45 (func_call -> VARIABLE LPAREN RPAREN .)
    RETURN          reduce using rule 45 (func_call -> VARIABLE LPAREN RPAREN .)
    $end            reduce using rule 45 (func_call -> VARIABLE LPAREN RPAREN .)
    RBRACE          reduce using rule 45 (func_call -> VARIABLE LPAREN RPAREN .)
    CASE            reduce using rule 45 (func_call -> VARIABLE LPAREN RPAREN .)
    DEFAULT         reduce using rule 45 (func_call -> VARIABLE LPAREN RPAREN .)


state 91

    (49) arg_list -> expression .
    (50) arg_list -> expression . COMMA arg_list
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

    RPAREN          reduce using rule 49 (arg_list -> expression .)
    COMMA           shift and go to state 136
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107


state 92

    (37) print_stmt -> FMT DOT PRINTF . LPAREN STRING COMMA expression RPAREN

    LPAREN          shift and go to state 137


state 93

    (38) print_stmt -> FMT DOT PRINTLN . LPAREN expression RPAREN

    LPAREN          shift and go to state 138


state 94

    (39) input_stmt -> FMT DOT SCANLN . LPAREN AMPER VARIABLE RPAREN

    LPAREN          shift and go to state 139


state 95

    (84) struct_method -> FUNC LPAREN VARIABLE . VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (85) struct_method -> FUNC LPAREN VARIABLE . VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE

    VARIABLE        shift and go to state 140


state 96

    (40) func_def -> FUNC VARIABLE LPAREN . param_list RPAREN type LBRACE program RBRACE
    (41) func_def -> FUNC VARIABLE LPAREN . RPAREN type LBRACE program RBRACE
    (43) func_no_params -> FUNC VARIABLE LPAREN . RPAREN block
    (46) param_list -> . param
    (47) param_list -> . param COMMA param_list
    (48) param -> . VARIABLE type

    RPAREN          shift and go to state 143
    VARIABLE        shift and go to state 141

    param_list                     shift and go to state 142
    param                          shift and go to state 144

state 97

    (76) if_stmt -> IF expression block .
    (77) if_stmt -> IF expression block . ELSE block

    VAR             reduce using rule 76 (if_stmt -> IF expression block .)
    VARIABLE        reduce using rule 76 (if_stmt -> IF expression block .)
    FMT             reduce using rule 76 (if_stmt -> IF expression block .)
    CONTINUE        reduce using rule 76 (if_stmt -> IF expression block .)
    FUNC            reduce using rule 76 (if_stmt -> IF expression block .)
    IF              reduce using rule 76 (if_stmt -> IF expression block .)
    FOR             reduce using rule 76 (if_stmt -> IF expression block .)
    TYPE            reduce using rule 76 (if_stmt -> IF expression block .)
    SWITCH          reduce using rule 76 (if_stmt -> IF expression block .)
    LBRACKET        reduce using rule 76 (if_stmt -> IF expression block .)
    BREAK           reduce using rule 76 (if_stmt -> IF expression block .)
    RETURN          reduce using rule 76 (if_stmt -> IF expression block .)
    $end            reduce using rule 76 (if_stmt -> IF expression block .)
    RBRACE          reduce using rule 76 (if_stmt -> IF expression block .)
    CASE            reduce using rule 76 (if_stmt -> IF expression block .)
    DEFAULT         reduce using rule 76 (if_stmt -> IF expression block .)
    ELSE            shift and go to state 145


state 98

    (52) expression -> expression PLUS . term
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 147
    FLOAT           shift and go to state 148
    STRING          shift and go to state 61
    VARIABLE        shift and go to state 149
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    term                           shift and go to state 146
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 99

    (53) expression -> expression MINUS . term
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 147
    FLOAT           shift and go to state 148
    STRING          shift and go to state 61
    VARIABLE        shift and go to state 149
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    term                           shift and go to state 150
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 100

    (54) expression -> expression AND . expression
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 151
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 101

    (55) expression -> expression OR . expression
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 152
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 102

    (56) expression -> expression EQ . expression
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 153
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 103

    (57) expression -> expression NE . expression
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 154
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 104

    (58) expression -> expression LT . expression
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 155
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 105

    (59) expression -> expression GT . expression
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 156
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 106

    (60) expression -> expression LE . expression
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 157
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 107

    (61) expression -> expression GE . expression
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 158
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 108

    (83) block -> LBRACE . program RBRACE
    (4) program -> . statement
    (5) program -> . statement program
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . print_stmt
    (9) statement -> . input_stmt
    (10) statement -> . continue_stmt
    (11) statement -> . struct_method
    (12) statement -> . func_def
    (13) statement -> . func_no_params
    (14) statement -> . func_call
    (15) statement -> . if_stmt
    (16) statement -> . for_stmt
    (17) statement -> . struct_def
    (18) statement -> . switch_stmt
    (19) statement -> . map_declaration
    (20) statement -> . map_declaration_values
    (21) statement -> . array_declaration
    (22) statement -> . array_literal
    (23) statement -> . slice_declaration
    (24) statement -> . make_stmt
    (25) statement -> . new_stmt
    (26) statement -> . break_stmt
    (27) statement -> . increment_stmt
    (28) statement -> . return_stmt
    (29) declaration -> . VAR VARIABLE type
    (30) declaration -> . VAR VARIABLE type ASIG expression
    (31) declaration -> . VAR VARIABLE type ASSIGN expression
    (35) assignment -> . VARIABLE ASSIGN expression
    (36) assignment -> . VARIABLE ASIG expression
    (37) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (38) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (39) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (80) continue_stmt -> . CONTINUE
    (84) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (85) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (40) func_def -> . FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (41) func_def -> . FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (43) func_no_params -> . FUNC VARIABLE LPAREN RPAREN block
    (44) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (45) func_call -> . VARIABLE LPAREN RPAREN
    (76) if_stmt -> . IF expression block
    (77) if_stmt -> . IF expression block ELSE block
    (78) for_stmt -> . FOR expression block
    (79) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update block
    (86) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (95) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (96) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (101) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (102) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (107) map_declaration_values -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
    (111) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (112) array_declaration -> . VAR VARIABLE ASSIGN array_literal
    (113) array_literal -> . LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (116) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (117) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (103) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (104) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (120) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (121) break_stmt -> . BREAK
    (122) increment_stmt -> . VARIABLE INCREMENT
    (123) increment_stmt -> . VARIABLE DECREMENT
    (42) return_stmt -> . RETURN expression

    VAR             shift and go to state 31
    VARIABLE        shift and go to state 32
    FMT             shift and go to state 33
    CONTINUE        shift and go to state 34
    FUNC            shift and go to state 35
    IF              shift and go to state 36
    FOR             shift and go to state 37
    TYPE            shift and go to state 38
    SWITCH          shift and go to state 39
    LBRACKET        shift and go to state 40
    BREAK           shift and go to state 41
    RETURN          shift and go to state 42

    program                        shift and go to state 159
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    assignment                     shift and go to state 9
    print_stmt                     shift and go to state 10
    input_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    struct_method                  shift and go to state 13
    func_def                       shift and go to state 14
    func_no_params                 shift and go to state 15
    func_call                      shift and go to state 16
    if_stmt                        shift and go to state 17
    for_stmt                       shift and go to state 18
    struct_def                     shift and go to state 19
    switch_stmt                    shift and go to state 20
    map_declaration                shift and go to state 21
    map_declaration_values         shift and go to state 22
    array_declaration              shift and go to state 23
    array_literal                  shift and go to state 24
    slice_declaration              shift and go to state 25
    make_stmt                      shift and go to state 26
    new_stmt                       shift and go to state 27
    break_stmt                     shift and go to state 28
    increment_stmt                 shift and go to state 29
    return_stmt                    shift and go to state 30

state 109

    (91) struct_instance -> VARIABLE LBRACE . struct_fields_values RBRACE
    (92) struct_fields_values -> . field_value
    (93) struct_fields_values -> . field_value COMMA struct_fields_values
    (94) field_value -> . VARIABLE COLON expression

    VARIABLE        shift and go to state 160

    struct_fields_values           shift and go to state 161
    field_value                    shift and go to state 162

state 110

    (63) term -> term TIMES . factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 147
    FLOAT           shift and go to state 148
    STRING          shift and go to state 61
    VARIABLE        shift and go to state 149
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    factor                         shift and go to state 163
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 111

    (64) term -> term DIVIDE . factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 147
    FLOAT           shift and go to state 148
    STRING          shift and go to state 61
    VARIABLE        shift and go to state 149
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    factor                         shift and go to state 164
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 112

    (69) factor -> LPAREN expression . RPAREN
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

    RPAREN          shift and go to state 165
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107


state 113

    (105) make_expr -> MAKE LPAREN . MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> MAKE LPAREN . LBRACKET RBRACKET type RPAREN

    MAP             shift and go to state 166
    LBRACKET        shift and go to state 167


state 114

    (78) for_stmt -> FOR expression block .

    VAR             reduce using rule 78 (for_stmt -> FOR expression block .)
    VARIABLE        reduce using rule 78 (for_stmt -> FOR expression block .)
    FMT             reduce using rule 78 (for_stmt -> FOR expression block .)
    CONTINUE        reduce using rule 78 (for_stmt -> FOR expression block .)
    FUNC            reduce using rule 78 (for_stmt -> FOR expression block .)
    IF              reduce using rule 78 (for_stmt -> FOR expression block .)
    FOR             reduce using rule 78 (for_stmt -> FOR expression block .)
    TYPE            reduce using rule 78 (for_stmt -> FOR expression block .)
    SWITCH          reduce using rule 78 (for_stmt -> FOR expression block .)
    LBRACKET        reduce using rule 78 (for_stmt -> FOR expression block .)
    BREAK           reduce using rule 78 (for_stmt -> FOR expression block .)
    RETURN          reduce using rule 78 (for_stmt -> FOR expression block .)
    $end            reduce using rule 78 (for_stmt -> FOR expression block .)
    RBRACE          reduce using rule 78 (for_stmt -> FOR expression block .)
    CASE            reduce using rule 78 (for_stmt -> FOR expression block .)
    DEFAULT         reduce using rule 78 (for_stmt -> FOR expression block .)


state 115

    (79) for_stmt -> FOR assignment SEMICOLON . expression SEMICOLON for_update block
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 168
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 116

    (36) assignment -> VARIABLE ASIG . expression
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 84
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 117

    (86) struct_def -> TYPE VARIABLE STRUCT . LBRACE struct_fields RBRACE

    LBRACE          shift and go to state 169


state 118

    (95) switch_stmt -> SWITCH expression LBRACE . case_list RBRACE
    (97) case_list -> . case_clause
    (98) case_list -> . case_clause case_list
    (99) case_clause -> . CASE expression COLON program
    (100) case_clause -> . DEFAULT COLON program

    CASE            shift and go to state 121
    DEFAULT         shift and go to state 122

    case_list                      shift and go to state 170
    case_clause                    shift and go to state 120

state 119

    (96) switch_stmt -> SWITCH LBRACE case_list . RBRACE

    RBRACE          shift and go to state 171


state 120

    (97) case_list -> case_clause .
    (98) case_list -> case_clause . case_list
    (97) case_list -> . case_clause
    (98) case_list -> . case_clause case_list
    (99) case_clause -> . CASE expression COLON program
    (100) case_clause -> . DEFAULT COLON program

    RBRACE          reduce using rule 97 (case_list -> case_clause .)
    CASE            shift and go to state 121
    DEFAULT         shift and go to state 122

    case_clause                    shift and go to state 120
    case_list                      shift and go to state 172

state 121

    (99) case_clause -> CASE . expression COLON program
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 173
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 122

    (100) case_clause -> DEFAULT . COLON program

    COLON           shift and go to state 174


state 123

    (113) array_literal -> LBRACKET NUMBER RBRACKET . type LBRACE array_values RBRACE
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82

    type                           shift and go to state 175

state 124

    (2) import_stmt -> IMPORT LPAREN STRING RPAREN .

    VAR             reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)
    VARIABLE        reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)
    FMT             reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)
    CONTINUE        reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)
    FUNC            reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)
    IF              reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)
    FOR             reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)
    TYPE            reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)
    SWITCH          reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)
    LBRACKET        reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)
    BREAK           reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)
    RETURN          reduce using rule 2 (import_stmt -> IMPORT LPAREN STRING RPAREN .)


state 125

    (30) declaration -> VAR VARIABLE type ASIG . expression
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 176
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 126

    (31) declaration -> VAR VARIABLE type ASSIGN . expression
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 177
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 127

    (112) array_declaration -> VAR VARIABLE ASSIGN array_literal .

    VAR             reduce using rule 112 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    VARIABLE        reduce using rule 112 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    FMT             reduce using rule 112 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    CONTINUE        reduce using rule 112 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    FUNC            reduce using rule 112 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    IF              reduce using rule 112 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    FOR             reduce using rule 112 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    TYPE            reduce using rule 112 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    SWITCH          reduce using rule 112 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    LBRACKET        reduce using rule 112 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    BREAK           reduce using rule 112 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    RETURN          reduce using rule 112 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    $end            reduce using rule 112 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    RBRACE          reduce using rule 112 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    CASE            reduce using rule 112 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)
    DEFAULT         reduce using rule 112 (array_declaration -> VAR VARIABLE ASSIGN array_literal .)


state 128

    (101) map_declaration -> VAR VARIABLE MAP LBRACKET . type RBRACKET type
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82

    type                           shift and go to state 178

state 129

    (111) array_declaration -> VAR VARIABLE LBRACKET NUMBER . RBRACKET type

    RBRACKET        shift and go to state 179


state 130

    (116) slice_declaration -> VAR VARIABLE LBRACKET RBRACKET . type
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82

    type                           shift and go to state 180

state 131

    (102) map_declaration -> VARIABLE ASIG MAP LBRACKET . type RBRACKET type
    (107) map_declaration_values -> VARIABLE ASIG MAP LBRACKET . type RBRACKET type LBRACE map_kv_pairs RBRACE
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82

    type                           shift and go to state 181

state 132

    (117) slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET . type LBRACE slice_values RBRACE
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82

    type                           shift and go to state 182

state 133

    (103) make_stmt -> VARIABLE ASIG MAKE LPAREN . MAP LBRACKET type RBRACKET type RPAREN
    (104) make_stmt -> VARIABLE ASIG MAKE LPAREN . LBRACKET RBRACKET type RPAREN
    (105) make_expr -> MAKE LPAREN . MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> MAKE LPAREN . LBRACKET RBRACKET type RPAREN

    MAP             shift and go to state 183
    LBRACKET        shift and go to state 184


state 134

    (120) new_stmt -> VARIABLE ASIG NEW LPAREN . VARIABLE RPAREN

    VARIABLE        shift and go to state 185


state 135

    (44) func_call -> VARIABLE LPAREN arg_list RPAREN .

    VAR             reduce using rule 44 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    VARIABLE        reduce using rule 44 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    FMT             reduce using rule 44 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    CONTINUE        reduce using rule 44 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    FUNC            reduce using rule 44 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    IF              reduce using rule 44 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    FOR             reduce using rule 44 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    TYPE            reduce using rule 44 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    SWITCH          reduce using rule 44 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    LBRACKET        reduce using rule 44 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    BREAK           reduce using rule 44 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    RETURN          reduce using rule 44 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    $end            reduce using rule 44 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    RBRACE          reduce using rule 44 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    CASE            reduce using rule 44 (func_call -> VARIABLE LPAREN arg_list RPAREN .)
    DEFAULT         reduce using rule 44 (func_call -> VARIABLE LPAREN arg_list RPAREN .)


state 136

    (50) arg_list -> expression COMMA . arg_list
    (49) arg_list -> . expression
    (50) arg_list -> . expression COMMA arg_list
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 91
    arg_list                       shift and go to state 186
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 137

    (37) print_stmt -> FMT DOT PRINTF LPAREN . STRING COMMA expression RPAREN

    STRING          shift and go to state 187


state 138

    (38) print_stmt -> FMT DOT PRINTLN LPAREN . expression RPAREN
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 188
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 139

    (39) input_stmt -> FMT DOT SCANLN LPAREN . AMPER VARIABLE RPAREN

    AMPER           shift and go to state 189


state 140

    (84) struct_method -> FUNC LPAREN VARIABLE VARIABLE . RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (85) struct_method -> FUNC LPAREN VARIABLE VARIABLE . RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE

    RPAREN          shift and go to state 190


state 141

    (48) param -> VARIABLE . type
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82

    type                           shift and go to state 191

state 142

    (40) func_def -> FUNC VARIABLE LPAREN param_list . RPAREN type LBRACE program RBRACE

    RPAREN          shift and go to state 192


state 143

    (41) func_def -> FUNC VARIABLE LPAREN RPAREN . type LBRACE program RBRACE
    (43) func_no_params -> FUNC VARIABLE LPAREN RPAREN . block
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE
    (83) block -> . LBRACE program RBRACE

    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82
    LBRACE          shift and go to state 108

    type                           shift and go to state 193
    block                          shift and go to state 194

state 144

    (46) param_list -> param .
    (47) param_list -> param . COMMA param_list

    RPAREN          reduce using rule 46 (param_list -> param .)
    COMMA           shift and go to state 195


state 145

    (77) if_stmt -> IF expression block ELSE . block
    (83) block -> . LBRACE program RBRACE

    LBRACE          shift and go to state 108

    block                          shift and go to state 196

state 146

    (52) expression -> expression PLUS term .
    (63) term -> term . TIMES factor
    (64) term -> term . DIVIDE factor

    PLUS            reduce using rule 52 (expression -> expression PLUS term .)
    MINUS           reduce using rule 52 (expression -> expression PLUS term .)
    AND             reduce using rule 52 (expression -> expression PLUS term .)
    OR              reduce using rule 52 (expression -> expression PLUS term .)
    EQ              reduce using rule 52 (expression -> expression PLUS term .)
    NE              reduce using rule 52 (expression -> expression PLUS term .)
    LT              reduce using rule 52 (expression -> expression PLUS term .)
    GT              reduce using rule 52 (expression -> expression PLUS term .)
    LE              reduce using rule 52 (expression -> expression PLUS term .)
    GE              reduce using rule 52 (expression -> expression PLUS term .)
    LBRACE          reduce using rule 52 (expression -> expression PLUS term .)
    VAR             reduce using rule 52 (expression -> expression PLUS term .)
    VARIABLE        reduce using rule 52 (expression -> expression PLUS term .)
    FMT             reduce using rule 52 (expression -> expression PLUS term .)
    CONTINUE        reduce using rule 52 (expression -> expression PLUS term .)
    FUNC            reduce using rule 52 (expression -> expression PLUS term .)
    IF              reduce using rule 52 (expression -> expression PLUS term .)
    FOR             reduce using rule 52 (expression -> expression PLUS term .)
    TYPE            reduce using rule 52 (expression -> expression PLUS term .)
    SWITCH          reduce using rule 52 (expression -> expression PLUS term .)
    LBRACKET        reduce using rule 52 (expression -> expression PLUS term .)
    BREAK           reduce using rule 52 (expression -> expression PLUS term .)
    RETURN          reduce using rule 52 (expression -> expression PLUS term .)
    $end            reduce using rule 52 (expression -> expression PLUS term .)
    RBRACE          reduce using rule 52 (expression -> expression PLUS term .)
    CASE            reduce using rule 52 (expression -> expression PLUS term .)
    DEFAULT         reduce using rule 52 (expression -> expression PLUS term .)
    SEMICOLON       reduce using rule 52 (expression -> expression PLUS term .)
    COMMA           reduce using rule 52 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 52 (expression -> expression PLUS term .)
    COLON           reduce using rule 52 (expression -> expression PLUS term .)
    TIMES           shift and go to state 110
    DIVIDE          shift and go to state 111


state 147

    (65) factor -> NUMBER .

    TIMES           reduce using rule 65 (factor -> NUMBER .)
    DIVIDE          reduce using rule 65 (factor -> NUMBER .)
    PLUS            reduce using rule 65 (factor -> NUMBER .)
    MINUS           reduce using rule 65 (factor -> NUMBER .)
    AND             reduce using rule 65 (factor -> NUMBER .)
    OR              reduce using rule 65 (factor -> NUMBER .)
    EQ              reduce using rule 65 (factor -> NUMBER .)
    NE              reduce using rule 65 (factor -> NUMBER .)
    LT              reduce using rule 65 (factor -> NUMBER .)
    GT              reduce using rule 65 (factor -> NUMBER .)
    LE              reduce using rule 65 (factor -> NUMBER .)
    GE              reduce using rule 65 (factor -> NUMBER .)
    LBRACE          reduce using rule 65 (factor -> NUMBER .)
    VAR             reduce using rule 65 (factor -> NUMBER .)
    VARIABLE        reduce using rule 65 (factor -> NUMBER .)
    FMT             reduce using rule 65 (factor -> NUMBER .)
    CONTINUE        reduce using rule 65 (factor -> NUMBER .)
    FUNC            reduce using rule 65 (factor -> NUMBER .)
    IF              reduce using rule 65 (factor -> NUMBER .)
    FOR             reduce using rule 65 (factor -> NUMBER .)
    TYPE            reduce using rule 65 (factor -> NUMBER .)
    SWITCH          reduce using rule 65 (factor -> NUMBER .)
    LBRACKET        reduce using rule 65 (factor -> NUMBER .)
    BREAK           reduce using rule 65 (factor -> NUMBER .)
    RETURN          reduce using rule 65 (factor -> NUMBER .)
    $end            reduce using rule 65 (factor -> NUMBER .)
    RBRACE          reduce using rule 65 (factor -> NUMBER .)
    CASE            reduce using rule 65 (factor -> NUMBER .)
    DEFAULT         reduce using rule 65 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 65 (factor -> NUMBER .)
    COMMA           reduce using rule 65 (factor -> NUMBER .)
    RPAREN          reduce using rule 65 (factor -> NUMBER .)
    COLON           reduce using rule 65 (factor -> NUMBER .)


state 148

    (66) factor -> FLOAT .

    TIMES           reduce using rule 66 (factor -> FLOAT .)
    DIVIDE          reduce using rule 66 (factor -> FLOAT .)
    PLUS            reduce using rule 66 (factor -> FLOAT .)
    MINUS           reduce using rule 66 (factor -> FLOAT .)
    AND             reduce using rule 66 (factor -> FLOAT .)
    OR              reduce using rule 66 (factor -> FLOAT .)
    EQ              reduce using rule 66 (factor -> FLOAT .)
    NE              reduce using rule 66 (factor -> FLOAT .)
    LT              reduce using rule 66 (factor -> FLOAT .)
    GT              reduce using rule 66 (factor -> FLOAT .)
    LE              reduce using rule 66 (factor -> FLOAT .)
    GE              reduce using rule 66 (factor -> FLOAT .)
    LBRACE          reduce using rule 66 (factor -> FLOAT .)
    VAR             reduce using rule 66 (factor -> FLOAT .)
    VARIABLE        reduce using rule 66 (factor -> FLOAT .)
    FMT             reduce using rule 66 (factor -> FLOAT .)
    CONTINUE        reduce using rule 66 (factor -> FLOAT .)
    FUNC            reduce using rule 66 (factor -> FLOAT .)
    IF              reduce using rule 66 (factor -> FLOAT .)
    FOR             reduce using rule 66 (factor -> FLOAT .)
    TYPE            reduce using rule 66 (factor -> FLOAT .)
    SWITCH          reduce using rule 66 (factor -> FLOAT .)
    LBRACKET        reduce using rule 66 (factor -> FLOAT .)
    BREAK           reduce using rule 66 (factor -> FLOAT .)
    RETURN          reduce using rule 66 (factor -> FLOAT .)
    $end            reduce using rule 66 (factor -> FLOAT .)
    RBRACE          reduce using rule 66 (factor -> FLOAT .)
    CASE            reduce using rule 66 (factor -> FLOAT .)
    DEFAULT         reduce using rule 66 (factor -> FLOAT .)
    SEMICOLON       reduce using rule 66 (factor -> FLOAT .)
    COMMA           reduce using rule 66 (factor -> FLOAT .)
    RPAREN          reduce using rule 66 (factor -> FLOAT .)
    COLON           reduce using rule 66 (factor -> FLOAT .)


state 149

    (68) factor -> VARIABLE .
    (91) struct_instance -> VARIABLE . LBRACE struct_fields_values RBRACE

  ! shift/reduce conflict for LBRACE resolved as shift
    TIMES           reduce using rule 68 (factor -> VARIABLE .)
    DIVIDE          reduce using rule 68 (factor -> VARIABLE .)
    PLUS            reduce using rule 68 (factor -> VARIABLE .)
    MINUS           reduce using rule 68 (factor -> VARIABLE .)
    AND             reduce using rule 68 (factor -> VARIABLE .)
    OR              reduce using rule 68 (factor -> VARIABLE .)
    EQ              reduce using rule 68 (factor -> VARIABLE .)
    NE              reduce using rule 68 (factor -> VARIABLE .)
    LT              reduce using rule 68 (factor -> VARIABLE .)
    GT              reduce using rule 68 (factor -> VARIABLE .)
    LE              reduce using rule 68 (factor -> VARIABLE .)
    GE              reduce using rule 68 (factor -> VARIABLE .)
    VAR             reduce using rule 68 (factor -> VARIABLE .)
    VARIABLE        reduce using rule 68 (factor -> VARIABLE .)
    FMT             reduce using rule 68 (factor -> VARIABLE .)
    CONTINUE        reduce using rule 68 (factor -> VARIABLE .)
    FUNC            reduce using rule 68 (factor -> VARIABLE .)
    IF              reduce using rule 68 (factor -> VARIABLE .)
    FOR             reduce using rule 68 (factor -> VARIABLE .)
    TYPE            reduce using rule 68 (factor -> VARIABLE .)
    SWITCH          reduce using rule 68 (factor -> VARIABLE .)
    LBRACKET        reduce using rule 68 (factor -> VARIABLE .)
    BREAK           reduce using rule 68 (factor -> VARIABLE .)
    RETURN          reduce using rule 68 (factor -> VARIABLE .)
    $end            reduce using rule 68 (factor -> VARIABLE .)
    RBRACE          reduce using rule 68 (factor -> VARIABLE .)
    CASE            reduce using rule 68 (factor -> VARIABLE .)
    DEFAULT         reduce using rule 68 (factor -> VARIABLE .)
    SEMICOLON       reduce using rule 68 (factor -> VARIABLE .)
    COMMA           reduce using rule 68 (factor -> VARIABLE .)
    RPAREN          reduce using rule 68 (factor -> VARIABLE .)
    COLON           reduce using rule 68 (factor -> VARIABLE .)
    LBRACE          shift and go to state 109

  ! LBRACE          [ reduce using rule 68 (factor -> VARIABLE .) ]


state 150

    (53) expression -> expression MINUS term .
    (63) term -> term . TIMES factor
    (64) term -> term . DIVIDE factor

    PLUS            reduce using rule 53 (expression -> expression MINUS term .)
    MINUS           reduce using rule 53 (expression -> expression MINUS term .)
    AND             reduce using rule 53 (expression -> expression MINUS term .)
    OR              reduce using rule 53 (expression -> expression MINUS term .)
    EQ              reduce using rule 53 (expression -> expression MINUS term .)
    NE              reduce using rule 53 (expression -> expression MINUS term .)
    LT              reduce using rule 53 (expression -> expression MINUS term .)
    GT              reduce using rule 53 (expression -> expression MINUS term .)
    LE              reduce using rule 53 (expression -> expression MINUS term .)
    GE              reduce using rule 53 (expression -> expression MINUS term .)
    LBRACE          reduce using rule 53 (expression -> expression MINUS term .)
    VAR             reduce using rule 53 (expression -> expression MINUS term .)
    VARIABLE        reduce using rule 53 (expression -> expression MINUS term .)
    FMT             reduce using rule 53 (expression -> expression MINUS term .)
    CONTINUE        reduce using rule 53 (expression -> expression MINUS term .)
    FUNC            reduce using rule 53 (expression -> expression MINUS term .)
    IF              reduce using rule 53 (expression -> expression MINUS term .)
    FOR             reduce using rule 53 (expression -> expression MINUS term .)
    TYPE            reduce using rule 53 (expression -> expression MINUS term .)
    SWITCH          reduce using rule 53 (expression -> expression MINUS term .)
    LBRACKET        reduce using rule 53 (expression -> expression MINUS term .)
    BREAK           reduce using rule 53 (expression -> expression MINUS term .)
    RETURN          reduce using rule 53 (expression -> expression MINUS term .)
    $end            reduce using rule 53 (expression -> expression MINUS term .)
    RBRACE          reduce using rule 53 (expression -> expression MINUS term .)
    CASE            reduce using rule 53 (expression -> expression MINUS term .)
    DEFAULT         reduce using rule 53 (expression -> expression MINUS term .)
    SEMICOLON       reduce using rule 53 (expression -> expression MINUS term .)
    COMMA           reduce using rule 53 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 53 (expression -> expression MINUS term .)
    COLON           reduce using rule 53 (expression -> expression MINUS term .)
    TIMES           shift and go to state 110
    DIVIDE          shift and go to state 111


state 151

    (54) expression -> expression AND expression .
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 54 (expression -> expression AND expression .)
    VAR             reduce using rule 54 (expression -> expression AND expression .)
    VARIABLE        reduce using rule 54 (expression -> expression AND expression .)
    FMT             reduce using rule 54 (expression -> expression AND expression .)
    CONTINUE        reduce using rule 54 (expression -> expression AND expression .)
    FUNC            reduce using rule 54 (expression -> expression AND expression .)
    IF              reduce using rule 54 (expression -> expression AND expression .)
    FOR             reduce using rule 54 (expression -> expression AND expression .)
    TYPE            reduce using rule 54 (expression -> expression AND expression .)
    SWITCH          reduce using rule 54 (expression -> expression AND expression .)
    LBRACKET        reduce using rule 54 (expression -> expression AND expression .)
    BREAK           reduce using rule 54 (expression -> expression AND expression .)
    RETURN          reduce using rule 54 (expression -> expression AND expression .)
    $end            reduce using rule 54 (expression -> expression AND expression .)
    RBRACE          reduce using rule 54 (expression -> expression AND expression .)
    CASE            reduce using rule 54 (expression -> expression AND expression .)
    DEFAULT         reduce using rule 54 (expression -> expression AND expression .)
    SEMICOLON       reduce using rule 54 (expression -> expression AND expression .)
    COMMA           reduce using rule 54 (expression -> expression AND expression .)
    RPAREN          reduce using rule 54 (expression -> expression AND expression .)
    COLON           reduce using rule 54 (expression -> expression AND expression .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107

  ! PLUS            [ reduce using rule 54 (expression -> expression AND expression .) ]
  ! MINUS           [ reduce using rule 54 (expression -> expression AND expression .) ]
  ! AND             [ reduce using rule 54 (expression -> expression AND expression .) ]
  ! OR              [ reduce using rule 54 (expression -> expression AND expression .) ]
  ! EQ              [ reduce using rule 54 (expression -> expression AND expression .) ]
  ! NE              [ reduce using rule 54 (expression -> expression AND expression .) ]
  ! LT              [ reduce using rule 54 (expression -> expression AND expression .) ]
  ! GT              [ reduce using rule 54 (expression -> expression AND expression .) ]
  ! LE              [ reduce using rule 54 (expression -> expression AND expression .) ]
  ! GE              [ reduce using rule 54 (expression -> expression AND expression .) ]


state 152

    (55) expression -> expression OR expression .
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 55 (expression -> expression OR expression .)
    VAR             reduce using rule 55 (expression -> expression OR expression .)
    VARIABLE        reduce using rule 55 (expression -> expression OR expression .)
    FMT             reduce using rule 55 (expression -> expression OR expression .)
    CONTINUE        reduce using rule 55 (expression -> expression OR expression .)
    FUNC            reduce using rule 55 (expression -> expression OR expression .)
    IF              reduce using rule 55 (expression -> expression OR expression .)
    FOR             reduce using rule 55 (expression -> expression OR expression .)
    TYPE            reduce using rule 55 (expression -> expression OR expression .)
    SWITCH          reduce using rule 55 (expression -> expression OR expression .)
    LBRACKET        reduce using rule 55 (expression -> expression OR expression .)
    BREAK           reduce using rule 55 (expression -> expression OR expression .)
    RETURN          reduce using rule 55 (expression -> expression OR expression .)
    $end            reduce using rule 55 (expression -> expression OR expression .)
    RBRACE          reduce using rule 55 (expression -> expression OR expression .)
    CASE            reduce using rule 55 (expression -> expression OR expression .)
    DEFAULT         reduce using rule 55 (expression -> expression OR expression .)
    SEMICOLON       reduce using rule 55 (expression -> expression OR expression .)
    COMMA           reduce using rule 55 (expression -> expression OR expression .)
    RPAREN          reduce using rule 55 (expression -> expression OR expression .)
    COLON           reduce using rule 55 (expression -> expression OR expression .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107

  ! PLUS            [ reduce using rule 55 (expression -> expression OR expression .) ]
  ! MINUS           [ reduce using rule 55 (expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 55 (expression -> expression OR expression .) ]
  ! OR              [ reduce using rule 55 (expression -> expression OR expression .) ]
  ! EQ              [ reduce using rule 55 (expression -> expression OR expression .) ]
  ! NE              [ reduce using rule 55 (expression -> expression OR expression .) ]
  ! LT              [ reduce using rule 55 (expression -> expression OR expression .) ]
  ! GT              [ reduce using rule 55 (expression -> expression OR expression .) ]
  ! LE              [ reduce using rule 55 (expression -> expression OR expression .) ]
  ! GE              [ reduce using rule 55 (expression -> expression OR expression .) ]


state 153

    (56) expression -> expression EQ expression .
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 56 (expression -> expression EQ expression .)
    VAR             reduce using rule 56 (expression -> expression EQ expression .)
    VARIABLE        reduce using rule 56 (expression -> expression EQ expression .)
    FMT             reduce using rule 56 (expression -> expression EQ expression .)
    CONTINUE        reduce using rule 56 (expression -> expression EQ expression .)
    FUNC            reduce using rule 56 (expression -> expression EQ expression .)
    IF              reduce using rule 56 (expression -> expression EQ expression .)
    FOR             reduce using rule 56 (expression -> expression EQ expression .)
    TYPE            reduce using rule 56 (expression -> expression EQ expression .)
    SWITCH          reduce using rule 56 (expression -> expression EQ expression .)
    LBRACKET        reduce using rule 56 (expression -> expression EQ expression .)
    BREAK           reduce using rule 56 (expression -> expression EQ expression .)
    RETURN          reduce using rule 56 (expression -> expression EQ expression .)
    $end            reduce using rule 56 (expression -> expression EQ expression .)
    RBRACE          reduce using rule 56 (expression -> expression EQ expression .)
    CASE            reduce using rule 56 (expression -> expression EQ expression .)
    DEFAULT         reduce using rule 56 (expression -> expression EQ expression .)
    SEMICOLON       reduce using rule 56 (expression -> expression EQ expression .)
    COMMA           reduce using rule 56 (expression -> expression EQ expression .)
    RPAREN          reduce using rule 56 (expression -> expression EQ expression .)
    COLON           reduce using rule 56 (expression -> expression EQ expression .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107

  ! PLUS            [ reduce using rule 56 (expression -> expression EQ expression .) ]
  ! MINUS           [ reduce using rule 56 (expression -> expression EQ expression .) ]
  ! AND             [ reduce using rule 56 (expression -> expression EQ expression .) ]
  ! OR              [ reduce using rule 56 (expression -> expression EQ expression .) ]
  ! EQ              [ reduce using rule 56 (expression -> expression EQ expression .) ]
  ! NE              [ reduce using rule 56 (expression -> expression EQ expression .) ]
  ! LT              [ reduce using rule 56 (expression -> expression EQ expression .) ]
  ! GT              [ reduce using rule 56 (expression -> expression EQ expression .) ]
  ! LE              [ reduce using rule 56 (expression -> expression EQ expression .) ]
  ! GE              [ reduce using rule 56 (expression -> expression EQ expression .) ]


state 154

    (57) expression -> expression NE expression .
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 57 (expression -> expression NE expression .)
    VAR             reduce using rule 57 (expression -> expression NE expression .)
    VARIABLE        reduce using rule 57 (expression -> expression NE expression .)
    FMT             reduce using rule 57 (expression -> expression NE expression .)
    CONTINUE        reduce using rule 57 (expression -> expression NE expression .)
    FUNC            reduce using rule 57 (expression -> expression NE expression .)
    IF              reduce using rule 57 (expression -> expression NE expression .)
    FOR             reduce using rule 57 (expression -> expression NE expression .)
    TYPE            reduce using rule 57 (expression -> expression NE expression .)
    SWITCH          reduce using rule 57 (expression -> expression NE expression .)
    LBRACKET        reduce using rule 57 (expression -> expression NE expression .)
    BREAK           reduce using rule 57 (expression -> expression NE expression .)
    RETURN          reduce using rule 57 (expression -> expression NE expression .)
    $end            reduce using rule 57 (expression -> expression NE expression .)
    RBRACE          reduce using rule 57 (expression -> expression NE expression .)
    CASE            reduce using rule 57 (expression -> expression NE expression .)
    DEFAULT         reduce using rule 57 (expression -> expression NE expression .)
    SEMICOLON       reduce using rule 57 (expression -> expression NE expression .)
    COMMA           reduce using rule 57 (expression -> expression NE expression .)
    RPAREN          reduce using rule 57 (expression -> expression NE expression .)
    COLON           reduce using rule 57 (expression -> expression NE expression .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107

  ! PLUS            [ reduce using rule 57 (expression -> expression NE expression .) ]
  ! MINUS           [ reduce using rule 57 (expression -> expression NE expression .) ]
  ! AND             [ reduce using rule 57 (expression -> expression NE expression .) ]
  ! OR              [ reduce using rule 57 (expression -> expression NE expression .) ]
  ! EQ              [ reduce using rule 57 (expression -> expression NE expression .) ]
  ! NE              [ reduce using rule 57 (expression -> expression NE expression .) ]
  ! LT              [ reduce using rule 57 (expression -> expression NE expression .) ]
  ! GT              [ reduce using rule 57 (expression -> expression NE expression .) ]
  ! LE              [ reduce using rule 57 (expression -> expression NE expression .) ]
  ! GE              [ reduce using rule 57 (expression -> expression NE expression .) ]


state 155

    (58) expression -> expression LT expression .
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 58 (expression -> expression LT expression .)
    VAR             reduce using rule 58 (expression -> expression LT expression .)
    VARIABLE        reduce using rule 58 (expression -> expression LT expression .)
    FMT             reduce using rule 58 (expression -> expression LT expression .)
    CONTINUE        reduce using rule 58 (expression -> expression LT expression .)
    FUNC            reduce using rule 58 (expression -> expression LT expression .)
    IF              reduce using rule 58 (expression -> expression LT expression .)
    FOR             reduce using rule 58 (expression -> expression LT expression .)
    TYPE            reduce using rule 58 (expression -> expression LT expression .)
    SWITCH          reduce using rule 58 (expression -> expression LT expression .)
    LBRACKET        reduce using rule 58 (expression -> expression LT expression .)
    BREAK           reduce using rule 58 (expression -> expression LT expression .)
    RETURN          reduce using rule 58 (expression -> expression LT expression .)
    $end            reduce using rule 58 (expression -> expression LT expression .)
    RBRACE          reduce using rule 58 (expression -> expression LT expression .)
    CASE            reduce using rule 58 (expression -> expression LT expression .)
    DEFAULT         reduce using rule 58 (expression -> expression LT expression .)
    SEMICOLON       reduce using rule 58 (expression -> expression LT expression .)
    COMMA           reduce using rule 58 (expression -> expression LT expression .)
    RPAREN          reduce using rule 58 (expression -> expression LT expression .)
    COLON           reduce using rule 58 (expression -> expression LT expression .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107

  ! PLUS            [ reduce using rule 58 (expression -> expression LT expression .) ]
  ! MINUS           [ reduce using rule 58 (expression -> expression LT expression .) ]
  ! AND             [ reduce using rule 58 (expression -> expression LT expression .) ]
  ! OR              [ reduce using rule 58 (expression -> expression LT expression .) ]
  ! EQ              [ reduce using rule 58 (expression -> expression LT expression .) ]
  ! NE              [ reduce using rule 58 (expression -> expression LT expression .) ]
  ! LT              [ reduce using rule 58 (expression -> expression LT expression .) ]
  ! GT              [ reduce using rule 58 (expression -> expression LT expression .) ]
  ! LE              [ reduce using rule 58 (expression -> expression LT expression .) ]
  ! GE              [ reduce using rule 58 (expression -> expression LT expression .) ]


state 156

    (59) expression -> expression GT expression .
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 59 (expression -> expression GT expression .)
    VAR             reduce using rule 59 (expression -> expression GT expression .)
    VARIABLE        reduce using rule 59 (expression -> expression GT expression .)
    FMT             reduce using rule 59 (expression -> expression GT expression .)
    CONTINUE        reduce using rule 59 (expression -> expression GT expression .)
    FUNC            reduce using rule 59 (expression -> expression GT expression .)
    IF              reduce using rule 59 (expression -> expression GT expression .)
    FOR             reduce using rule 59 (expression -> expression GT expression .)
    TYPE            reduce using rule 59 (expression -> expression GT expression .)
    SWITCH          reduce using rule 59 (expression -> expression GT expression .)
    LBRACKET        reduce using rule 59 (expression -> expression GT expression .)
    BREAK           reduce using rule 59 (expression -> expression GT expression .)
    RETURN          reduce using rule 59 (expression -> expression GT expression .)
    $end            reduce using rule 59 (expression -> expression GT expression .)
    RBRACE          reduce using rule 59 (expression -> expression GT expression .)
    CASE            reduce using rule 59 (expression -> expression GT expression .)
    DEFAULT         reduce using rule 59 (expression -> expression GT expression .)
    SEMICOLON       reduce using rule 59 (expression -> expression GT expression .)
    COMMA           reduce using rule 59 (expression -> expression GT expression .)
    RPAREN          reduce using rule 59 (expression -> expression GT expression .)
    COLON           reduce using rule 59 (expression -> expression GT expression .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107

  ! PLUS            [ reduce using rule 59 (expression -> expression GT expression .) ]
  ! MINUS           [ reduce using rule 59 (expression -> expression GT expression .) ]
  ! AND             [ reduce using rule 59 (expression -> expression GT expression .) ]
  ! OR              [ reduce using rule 59 (expression -> expression GT expression .) ]
  ! EQ              [ reduce using rule 59 (expression -> expression GT expression .) ]
  ! NE              [ reduce using rule 59 (expression -> expression GT expression .) ]
  ! LT              [ reduce using rule 59 (expression -> expression GT expression .) ]
  ! GT              [ reduce using rule 59 (expression -> expression GT expression .) ]
  ! LE              [ reduce using rule 59 (expression -> expression GT expression .) ]
  ! GE              [ reduce using rule 59 (expression -> expression GT expression .) ]


state 157

    (60) expression -> expression LE expression .
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 60 (expression -> expression LE expression .)
    VAR             reduce using rule 60 (expression -> expression LE expression .)
    VARIABLE        reduce using rule 60 (expression -> expression LE expression .)
    FMT             reduce using rule 60 (expression -> expression LE expression .)
    CONTINUE        reduce using rule 60 (expression -> expression LE expression .)
    FUNC            reduce using rule 60 (expression -> expression LE expression .)
    IF              reduce using rule 60 (expression -> expression LE expression .)
    FOR             reduce using rule 60 (expression -> expression LE expression .)
    TYPE            reduce using rule 60 (expression -> expression LE expression .)
    SWITCH          reduce using rule 60 (expression -> expression LE expression .)
    LBRACKET        reduce using rule 60 (expression -> expression LE expression .)
    BREAK           reduce using rule 60 (expression -> expression LE expression .)
    RETURN          reduce using rule 60 (expression -> expression LE expression .)
    $end            reduce using rule 60 (expression -> expression LE expression .)
    RBRACE          reduce using rule 60 (expression -> expression LE expression .)
    CASE            reduce using rule 60 (expression -> expression LE expression .)
    DEFAULT         reduce using rule 60 (expression -> expression LE expression .)
    SEMICOLON       reduce using rule 60 (expression -> expression LE expression .)
    COMMA           reduce using rule 60 (expression -> expression LE expression .)
    RPAREN          reduce using rule 60 (expression -> expression LE expression .)
    COLON           reduce using rule 60 (expression -> expression LE expression .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107

  ! PLUS            [ reduce using rule 60 (expression -> expression LE expression .) ]
  ! MINUS           [ reduce using rule 60 (expression -> expression LE expression .) ]
  ! AND             [ reduce using rule 60 (expression -> expression LE expression .) ]
  ! OR              [ reduce using rule 60 (expression -> expression LE expression .) ]
  ! EQ              [ reduce using rule 60 (expression -> expression LE expression .) ]
  ! NE              [ reduce using rule 60 (expression -> expression LE expression .) ]
  ! LT              [ reduce using rule 60 (expression -> expression LE expression .) ]
  ! GT              [ reduce using rule 60 (expression -> expression LE expression .) ]
  ! LE              [ reduce using rule 60 (expression -> expression LE expression .) ]
  ! GE              [ reduce using rule 60 (expression -> expression LE expression .) ]


state 158

    (61) expression -> expression GE expression .
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GE resolved as shift
    LBRACE          reduce using rule 61 (expression -> expression GE expression .)
    VAR             reduce using rule 61 (expression -> expression GE expression .)
    VARIABLE        reduce using rule 61 (expression -> expression GE expression .)
    FMT             reduce using rule 61 (expression -> expression GE expression .)
    CONTINUE        reduce using rule 61 (expression -> expression GE expression .)
    FUNC            reduce using rule 61 (expression -> expression GE expression .)
    IF              reduce using rule 61 (expression -> expression GE expression .)
    FOR             reduce using rule 61 (expression -> expression GE expression .)
    TYPE            reduce using rule 61 (expression -> expression GE expression .)
    SWITCH          reduce using rule 61 (expression -> expression GE expression .)
    LBRACKET        reduce using rule 61 (expression -> expression GE expression .)
    BREAK           reduce using rule 61 (expression -> expression GE expression .)
    RETURN          reduce using rule 61 (expression -> expression GE expression .)
    $end            reduce using rule 61 (expression -> expression GE expression .)
    RBRACE          reduce using rule 61 (expression -> expression GE expression .)
    CASE            reduce using rule 61 (expression -> expression GE expression .)
    DEFAULT         reduce using rule 61 (expression -> expression GE expression .)
    SEMICOLON       reduce using rule 61 (expression -> expression GE expression .)
    COMMA           reduce using rule 61 (expression -> expression GE expression .)
    RPAREN          reduce using rule 61 (expression -> expression GE expression .)
    COLON           reduce using rule 61 (expression -> expression GE expression .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107

  ! PLUS            [ reduce using rule 61 (expression -> expression GE expression .) ]
  ! MINUS           [ reduce using rule 61 (expression -> expression GE expression .) ]
  ! AND             [ reduce using rule 61 (expression -> expression GE expression .) ]
  ! OR              [ reduce using rule 61 (expression -> expression GE expression .) ]
  ! EQ              [ reduce using rule 61 (expression -> expression GE expression .) ]
  ! NE              [ reduce using rule 61 (expression -> expression GE expression .) ]
  ! LT              [ reduce using rule 61 (expression -> expression GE expression .) ]
  ! GT              [ reduce using rule 61 (expression -> expression GE expression .) ]
  ! LE              [ reduce using rule 61 (expression -> expression GE expression .) ]
  ! GE              [ reduce using rule 61 (expression -> expression GE expression .) ]


state 159

    (83) block -> LBRACE program . RBRACE

    RBRACE          shift and go to state 197


state 160

    (94) field_value -> VARIABLE . COLON expression

    COLON           shift and go to state 198


state 161

    (91) struct_instance -> VARIABLE LBRACE struct_fields_values . RBRACE

    RBRACE          shift and go to state 199


state 162

    (92) struct_fields_values -> field_value .
    (93) struct_fields_values -> field_value . COMMA struct_fields_values

    RBRACE          reduce using rule 92 (struct_fields_values -> field_value .)
    COMMA           shift and go to state 200


state 163

    (63) term -> term TIMES factor .

    TIMES           reduce using rule 63 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 63 (term -> term TIMES factor .)
    PLUS            reduce using rule 63 (term -> term TIMES factor .)
    MINUS           reduce using rule 63 (term -> term TIMES factor .)
    AND             reduce using rule 63 (term -> term TIMES factor .)
    OR              reduce using rule 63 (term -> term TIMES factor .)
    EQ              reduce using rule 63 (term -> term TIMES factor .)
    NE              reduce using rule 63 (term -> term TIMES factor .)
    LT              reduce using rule 63 (term -> term TIMES factor .)
    GT              reduce using rule 63 (term -> term TIMES factor .)
    LE              reduce using rule 63 (term -> term TIMES factor .)
    GE              reduce using rule 63 (term -> term TIMES factor .)
    LBRACE          reduce using rule 63 (term -> term TIMES factor .)
    VAR             reduce using rule 63 (term -> term TIMES factor .)
    VARIABLE        reduce using rule 63 (term -> term TIMES factor .)
    FMT             reduce using rule 63 (term -> term TIMES factor .)
    CONTINUE        reduce using rule 63 (term -> term TIMES factor .)
    FUNC            reduce using rule 63 (term -> term TIMES factor .)
    IF              reduce using rule 63 (term -> term TIMES factor .)
    FOR             reduce using rule 63 (term -> term TIMES factor .)
    TYPE            reduce using rule 63 (term -> term TIMES factor .)
    SWITCH          reduce using rule 63 (term -> term TIMES factor .)
    LBRACKET        reduce using rule 63 (term -> term TIMES factor .)
    BREAK           reduce using rule 63 (term -> term TIMES factor .)
    RETURN          reduce using rule 63 (term -> term TIMES factor .)
    $end            reduce using rule 63 (term -> term TIMES factor .)
    RBRACE          reduce using rule 63 (term -> term TIMES factor .)
    CASE            reduce using rule 63 (term -> term TIMES factor .)
    DEFAULT         reduce using rule 63 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 63 (term -> term TIMES factor .)
    COMMA           reduce using rule 63 (term -> term TIMES factor .)
    RPAREN          reduce using rule 63 (term -> term TIMES factor .)
    COLON           reduce using rule 63 (term -> term TIMES factor .)


state 164

    (64) term -> term DIVIDE factor .

    TIMES           reduce using rule 64 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 64 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 64 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 64 (term -> term DIVIDE factor .)
    AND             reduce using rule 64 (term -> term DIVIDE factor .)
    OR              reduce using rule 64 (term -> term DIVIDE factor .)
    EQ              reduce using rule 64 (term -> term DIVIDE factor .)
    NE              reduce using rule 64 (term -> term DIVIDE factor .)
    LT              reduce using rule 64 (term -> term DIVIDE factor .)
    GT              reduce using rule 64 (term -> term DIVIDE factor .)
    LE              reduce using rule 64 (term -> term DIVIDE factor .)
    GE              reduce using rule 64 (term -> term DIVIDE factor .)
    LBRACE          reduce using rule 64 (term -> term DIVIDE factor .)
    VAR             reduce using rule 64 (term -> term DIVIDE factor .)
    VARIABLE        reduce using rule 64 (term -> term DIVIDE factor .)
    FMT             reduce using rule 64 (term -> term DIVIDE factor .)
    CONTINUE        reduce using rule 64 (term -> term DIVIDE factor .)
    FUNC            reduce using rule 64 (term -> term DIVIDE factor .)
    IF              reduce using rule 64 (term -> term DIVIDE factor .)
    FOR             reduce using rule 64 (term -> term DIVIDE factor .)
    TYPE            reduce using rule 64 (term -> term DIVIDE factor .)
    SWITCH          reduce using rule 64 (term -> term DIVIDE factor .)
    LBRACKET        reduce using rule 64 (term -> term DIVIDE factor .)
    BREAK           reduce using rule 64 (term -> term DIVIDE factor .)
    RETURN          reduce using rule 64 (term -> term DIVIDE factor .)
    $end            reduce using rule 64 (term -> term DIVIDE factor .)
    RBRACE          reduce using rule 64 (term -> term DIVIDE factor .)
    CASE            reduce using rule 64 (term -> term DIVIDE factor .)
    DEFAULT         reduce using rule 64 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 64 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 64 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 64 (term -> term DIVIDE factor .)
    COLON           reduce using rule 64 (term -> term DIVIDE factor .)


state 165

    (69) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    EQ              reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    NE              reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    LE              reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    GE              reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    LBRACE          reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    VAR             reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    VARIABLE        reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    FMT             reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    CONTINUE        reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    FUNC            reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    IF              reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    FOR             reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    TYPE            reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    SWITCH          reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    BREAK           reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    RBRACE          reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    CASE            reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    DEFAULT         reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    COLON           reduce using rule 69 (factor -> LPAREN expression RPAREN .)


state 166

    (105) make_expr -> MAKE LPAREN MAP . LBRACKET type RBRACKET type RPAREN

    LBRACKET        shift and go to state 201


state 167

    (106) make_expr -> MAKE LPAREN LBRACKET . RBRACKET type RPAREN

    RBRACKET        shift and go to state 202


state 168

    (79) for_stmt -> FOR assignment SEMICOLON expression . SEMICOLON for_update block
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

    SEMICOLON       shift and go to state 203
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107


state 169

    (86) struct_def -> TYPE VARIABLE STRUCT LBRACE . struct_fields RBRACE
    (87) struct_fields -> . struct_field
    (88) struct_fields -> . struct_field struct_fields
    (89) struct_field -> . VARIABLE type
    (90) struct_field -> . type
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE

    VARIABLE        shift and go to state 204
    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82

    struct_fields                  shift and go to state 205
    struct_field                   shift and go to state 206
    type                           shift and go to state 207

state 170

    (95) switch_stmt -> SWITCH expression LBRACE case_list . RBRACE

    RBRACE          shift and go to state 208


state 171

    (96) switch_stmt -> SWITCH LBRACE case_list RBRACE .

    VAR             reduce using rule 96 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    VARIABLE        reduce using rule 96 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    FMT             reduce using rule 96 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    CONTINUE        reduce using rule 96 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    FUNC            reduce using rule 96 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    IF              reduce using rule 96 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    FOR             reduce using rule 96 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    TYPE            reduce using rule 96 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    SWITCH          reduce using rule 96 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    LBRACKET        reduce using rule 96 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    BREAK           reduce using rule 96 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    RETURN          reduce using rule 96 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    $end            reduce using rule 96 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    RBRACE          reduce using rule 96 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    CASE            reduce using rule 96 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)
    DEFAULT         reduce using rule 96 (switch_stmt -> SWITCH LBRACE case_list RBRACE .)


state 172

    (98) case_list -> case_clause case_list .

    RBRACE          reduce using rule 98 (case_list -> case_clause case_list .)


state 173

    (99) case_clause -> CASE expression . COLON program
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

    COLON           shift and go to state 209
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107


state 174

    (100) case_clause -> DEFAULT COLON . program
    (4) program -> . statement
    (5) program -> . statement program
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . print_stmt
    (9) statement -> . input_stmt
    (10) statement -> . continue_stmt
    (11) statement -> . struct_method
    (12) statement -> . func_def
    (13) statement -> . func_no_params
    (14) statement -> . func_call
    (15) statement -> . if_stmt
    (16) statement -> . for_stmt
    (17) statement -> . struct_def
    (18) statement -> . switch_stmt
    (19) statement -> . map_declaration
    (20) statement -> . map_declaration_values
    (21) statement -> . array_declaration
    (22) statement -> . array_literal
    (23) statement -> . slice_declaration
    (24) statement -> . make_stmt
    (25) statement -> . new_stmt
    (26) statement -> . break_stmt
    (27) statement -> . increment_stmt
    (28) statement -> . return_stmt
    (29) declaration -> . VAR VARIABLE type
    (30) declaration -> . VAR VARIABLE type ASIG expression
    (31) declaration -> . VAR VARIABLE type ASSIGN expression
    (35) assignment -> . VARIABLE ASSIGN expression
    (36) assignment -> . VARIABLE ASIG expression
    (37) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (38) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (39) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (80) continue_stmt -> . CONTINUE
    (84) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (85) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (40) func_def -> . FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (41) func_def -> . FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (43) func_no_params -> . FUNC VARIABLE LPAREN RPAREN block
    (44) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (45) func_call -> . VARIABLE LPAREN RPAREN
    (76) if_stmt -> . IF expression block
    (77) if_stmt -> . IF expression block ELSE block
    (78) for_stmt -> . FOR expression block
    (79) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update block
    (86) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (95) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (96) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (101) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (102) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (107) map_declaration_values -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
    (111) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (112) array_declaration -> . VAR VARIABLE ASSIGN array_literal
    (113) array_literal -> . LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (116) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (117) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (103) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (104) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (120) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (121) break_stmt -> . BREAK
    (122) increment_stmt -> . VARIABLE INCREMENT
    (123) increment_stmt -> . VARIABLE DECREMENT
    (42) return_stmt -> . RETURN expression

    VAR             shift and go to state 31
    VARIABLE        shift and go to state 32
    FMT             shift and go to state 33
    CONTINUE        shift and go to state 34
    FUNC            shift and go to state 35
    IF              shift and go to state 36
    FOR             shift and go to state 37
    TYPE            shift and go to state 38
    SWITCH          shift and go to state 39
    LBRACKET        shift and go to state 40
    BREAK           shift and go to state 41
    RETURN          shift and go to state 42

    program                        shift and go to state 210
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    assignment                     shift and go to state 9
    print_stmt                     shift and go to state 10
    input_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    struct_method                  shift and go to state 13
    func_def                       shift and go to state 14
    func_no_params                 shift and go to state 15
    func_call                      shift and go to state 16
    if_stmt                        shift and go to state 17
    for_stmt                       shift and go to state 18
    struct_def                     shift and go to state 19
    switch_stmt                    shift and go to state 20
    map_declaration                shift and go to state 21
    map_declaration_values         shift and go to state 22
    array_declaration              shift and go to state 23
    array_literal                  shift and go to state 24
    slice_declaration              shift and go to state 25
    make_stmt                      shift and go to state 26
    new_stmt                       shift and go to state 27
    break_stmt                     shift and go to state 28
    increment_stmt                 shift and go to state 29
    return_stmt                    shift and go to state 30

state 175

    (113) array_literal -> LBRACKET NUMBER RBRACKET type . LBRACE array_values RBRACE

    LBRACE          shift and go to state 211


state 176

    (30) declaration -> VAR VARIABLE type ASIG expression .
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

    VAR             reduce using rule 30 (declaration -> VAR VARIABLE type ASIG expression .)
    VARIABLE        reduce using rule 30 (declaration -> VAR VARIABLE type ASIG expression .)
    FMT             reduce using rule 30 (declaration -> VAR VARIABLE type ASIG expression .)
    CONTINUE        reduce using rule 30 (declaration -> VAR VARIABLE type ASIG expression .)
    FUNC            reduce using rule 30 (declaration -> VAR VARIABLE type ASIG expression .)
    IF              reduce using rule 30 (declaration -> VAR VARIABLE type ASIG expression .)
    FOR             reduce using rule 30 (declaration -> VAR VARIABLE type ASIG expression .)
    TYPE            reduce using rule 30 (declaration -> VAR VARIABLE type ASIG expression .)
    SWITCH          reduce using rule 30 (declaration -> VAR VARIABLE type ASIG expression .)
    LBRACKET        reduce using rule 30 (declaration -> VAR VARIABLE type ASIG expression .)
    BREAK           reduce using rule 30 (declaration -> VAR VARIABLE type ASIG expression .)
    RETURN          reduce using rule 30 (declaration -> VAR VARIABLE type ASIG expression .)
    $end            reduce using rule 30 (declaration -> VAR VARIABLE type ASIG expression .)
    RBRACE          reduce using rule 30 (declaration -> VAR VARIABLE type ASIG expression .)
    CASE            reduce using rule 30 (declaration -> VAR VARIABLE type ASIG expression .)
    DEFAULT         reduce using rule 30 (declaration -> VAR VARIABLE type ASIG expression .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107


state 177

    (31) declaration -> VAR VARIABLE type ASSIGN expression .
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

    VAR             reduce using rule 31 (declaration -> VAR VARIABLE type ASSIGN expression .)
    VARIABLE        reduce using rule 31 (declaration -> VAR VARIABLE type ASSIGN expression .)
    FMT             reduce using rule 31 (declaration -> VAR VARIABLE type ASSIGN expression .)
    CONTINUE        reduce using rule 31 (declaration -> VAR VARIABLE type ASSIGN expression .)
    FUNC            reduce using rule 31 (declaration -> VAR VARIABLE type ASSIGN expression .)
    IF              reduce using rule 31 (declaration -> VAR VARIABLE type ASSIGN expression .)
    FOR             reduce using rule 31 (declaration -> VAR VARIABLE type ASSIGN expression .)
    TYPE            reduce using rule 31 (declaration -> VAR VARIABLE type ASSIGN expression .)
    SWITCH          reduce using rule 31 (declaration -> VAR VARIABLE type ASSIGN expression .)
    LBRACKET        reduce using rule 31 (declaration -> VAR VARIABLE type ASSIGN expression .)
    BREAK           reduce using rule 31 (declaration -> VAR VARIABLE type ASSIGN expression .)
    RETURN          reduce using rule 31 (declaration -> VAR VARIABLE type ASSIGN expression .)
    $end            reduce using rule 31 (declaration -> VAR VARIABLE type ASSIGN expression .)
    RBRACE          reduce using rule 31 (declaration -> VAR VARIABLE type ASSIGN expression .)
    CASE            reduce using rule 31 (declaration -> VAR VARIABLE type ASSIGN expression .)
    DEFAULT         reduce using rule 31 (declaration -> VAR VARIABLE type ASSIGN expression .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107


state 178

    (101) map_declaration -> VAR VARIABLE MAP LBRACKET type . RBRACKET type

    RBRACKET        shift and go to state 212


state 179

    (111) array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET . type
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82

    type                           shift and go to state 213

state 180

    (116) slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .

    VAR             reduce using rule 116 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    VARIABLE        reduce using rule 116 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    FMT             reduce using rule 116 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    CONTINUE        reduce using rule 116 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    FUNC            reduce using rule 116 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    IF              reduce using rule 116 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    FOR             reduce using rule 116 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    TYPE            reduce using rule 116 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    SWITCH          reduce using rule 116 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    LBRACKET        reduce using rule 116 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    BREAK           reduce using rule 116 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    RETURN          reduce using rule 116 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    $end            reduce using rule 116 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    RBRACE          reduce using rule 116 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    CASE            reduce using rule 116 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)
    DEFAULT         reduce using rule 116 (slice_declaration -> VAR VARIABLE LBRACKET RBRACKET type .)


state 181

    (102) map_declaration -> VARIABLE ASIG MAP LBRACKET type . RBRACKET type
    (107) map_declaration_values -> VARIABLE ASIG MAP LBRACKET type . RBRACKET type LBRACE map_kv_pairs RBRACE

    RBRACKET        shift and go to state 214


state 182

    (117) slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type . LBRACE slice_values RBRACE

    LBRACE          shift and go to state 215


state 183

    (103) make_stmt -> VARIABLE ASIG MAKE LPAREN MAP . LBRACKET type RBRACKET type RPAREN
    (105) make_expr -> MAKE LPAREN MAP . LBRACKET type RBRACKET type RPAREN

    LBRACKET        shift and go to state 216


state 184

    (104) make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET . RBRACKET type RPAREN
    (106) make_expr -> MAKE LPAREN LBRACKET . RBRACKET type RPAREN

    RBRACKET        shift and go to state 217


state 185

    (120) new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE . RPAREN

    RPAREN          shift and go to state 218


state 186

    (50) arg_list -> expression COMMA arg_list .

    RPAREN          reduce using rule 50 (arg_list -> expression COMMA arg_list .)


state 187

    (37) print_stmt -> FMT DOT PRINTF LPAREN STRING . COMMA expression RPAREN

    COMMA           shift and go to state 219


state 188

    (38) print_stmt -> FMT DOT PRINTLN LPAREN expression . RPAREN
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

    RPAREN          shift and go to state 220
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107


state 189

    (39) input_stmt -> FMT DOT SCANLN LPAREN AMPER . VARIABLE RPAREN

    VARIABLE        shift and go to state 221


state 190

    (84) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN . VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (85) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN . VARIABLE LPAREN RPAREN type LBRACE program RBRACE

    VARIABLE        shift and go to state 222


state 191

    (48) param -> VARIABLE type .

    COMMA           reduce using rule 48 (param -> VARIABLE type .)
    RPAREN          reduce using rule 48 (param -> VARIABLE type .)


state 192

    (40) func_def -> FUNC VARIABLE LPAREN param_list RPAREN . type LBRACE program RBRACE
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82

    type                           shift and go to state 223

state 193

    (41) func_def -> FUNC VARIABLE LPAREN RPAREN type . LBRACE program RBRACE

    LBRACE          shift and go to state 224


state 194

    (43) func_no_params -> FUNC VARIABLE LPAREN RPAREN block .

    VAR             reduce using rule 43 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    VARIABLE        reduce using rule 43 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    FMT             reduce using rule 43 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    CONTINUE        reduce using rule 43 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    FUNC            reduce using rule 43 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    IF              reduce using rule 43 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    FOR             reduce using rule 43 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    TYPE            reduce using rule 43 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    SWITCH          reduce using rule 43 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    LBRACKET        reduce using rule 43 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    BREAK           reduce using rule 43 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    RETURN          reduce using rule 43 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    $end            reduce using rule 43 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    RBRACE          reduce using rule 43 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    CASE            reduce using rule 43 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)
    DEFAULT         reduce using rule 43 (func_no_params -> FUNC VARIABLE LPAREN RPAREN block .)


state 195

    (47) param_list -> param COMMA . param_list
    (46) param_list -> . param
    (47) param_list -> . param COMMA param_list
    (48) param -> . VARIABLE type

    VARIABLE        shift and go to state 141

    param                          shift and go to state 144
    param_list                     shift and go to state 225

state 196

    (77) if_stmt -> IF expression block ELSE block .

    VAR             reduce using rule 77 (if_stmt -> IF expression block ELSE block .)
    VARIABLE        reduce using rule 77 (if_stmt -> IF expression block ELSE block .)
    FMT             reduce using rule 77 (if_stmt -> IF expression block ELSE block .)
    CONTINUE        reduce using rule 77 (if_stmt -> IF expression block ELSE block .)
    FUNC            reduce using rule 77 (if_stmt -> IF expression block ELSE block .)
    IF              reduce using rule 77 (if_stmt -> IF expression block ELSE block .)
    FOR             reduce using rule 77 (if_stmt -> IF expression block ELSE block .)
    TYPE            reduce using rule 77 (if_stmt -> IF expression block ELSE block .)
    SWITCH          reduce using rule 77 (if_stmt -> IF expression block ELSE block .)
    LBRACKET        reduce using rule 77 (if_stmt -> IF expression block ELSE block .)
    BREAK           reduce using rule 77 (if_stmt -> IF expression block ELSE block .)
    RETURN          reduce using rule 77 (if_stmt -> IF expression block ELSE block .)
    $end            reduce using rule 77 (if_stmt -> IF expression block ELSE block .)
    RBRACE          reduce using rule 77 (if_stmt -> IF expression block ELSE block .)
    CASE            reduce using rule 77 (if_stmt -> IF expression block ELSE block .)
    DEFAULT         reduce using rule 77 (if_stmt -> IF expression block ELSE block .)


state 197

    (83) block -> LBRACE program RBRACE .

    ELSE            reduce using rule 83 (block -> LBRACE program RBRACE .)
    VAR             reduce using rule 83 (block -> LBRACE program RBRACE .)
    VARIABLE        reduce using rule 83 (block -> LBRACE program RBRACE .)
    FMT             reduce using rule 83 (block -> LBRACE program RBRACE .)
    CONTINUE        reduce using rule 83 (block -> LBRACE program RBRACE .)
    FUNC            reduce using rule 83 (block -> LBRACE program RBRACE .)
    IF              reduce using rule 83 (block -> LBRACE program RBRACE .)
    FOR             reduce using rule 83 (block -> LBRACE program RBRACE .)
    TYPE            reduce using rule 83 (block -> LBRACE program RBRACE .)
    SWITCH          reduce using rule 83 (block -> LBRACE program RBRACE .)
    LBRACKET        reduce using rule 83 (block -> LBRACE program RBRACE .)
    BREAK           reduce using rule 83 (block -> LBRACE program RBRACE .)
    RETURN          reduce using rule 83 (block -> LBRACE program RBRACE .)
    $end            reduce using rule 83 (block -> LBRACE program RBRACE .)
    RBRACE          reduce using rule 83 (block -> LBRACE program RBRACE .)
    CASE            reduce using rule 83 (block -> LBRACE program RBRACE .)
    DEFAULT         reduce using rule 83 (block -> LBRACE program RBRACE .)


state 198

    (94) field_value -> VARIABLE COLON . expression
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 226
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 199

    (91) struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .

    TIMES           reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    DIVIDE          reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    PLUS            reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    MINUS           reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    AND             reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    OR              reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    EQ              reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    NE              reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    LT              reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    GT              reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    LE              reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    GE              reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    LBRACE          reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    VAR             reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    VARIABLE        reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    FMT             reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    CONTINUE        reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    FUNC            reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    IF              reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    FOR             reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    TYPE            reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    SWITCH          reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    LBRACKET        reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    BREAK           reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    RETURN          reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    $end            reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    RBRACE          reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    CASE            reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    DEFAULT         reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    SEMICOLON       reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    COMMA           reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    RPAREN          reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)
    COLON           reduce using rule 91 (struct_instance -> VARIABLE LBRACE struct_fields_values RBRACE .)


state 200

    (93) struct_fields_values -> field_value COMMA . struct_fields_values
    (92) struct_fields_values -> . field_value
    (93) struct_fields_values -> . field_value COMMA struct_fields_values
    (94) field_value -> . VARIABLE COLON expression

    VARIABLE        shift and go to state 160

    field_value                    shift and go to state 162
    struct_fields_values           shift and go to state 227

state 201

    (105) make_expr -> MAKE LPAREN MAP LBRACKET . type RBRACKET type RPAREN
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82

    type                           shift and go to state 228

state 202

    (106) make_expr -> MAKE LPAREN LBRACKET RBRACKET . type RPAREN
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82

    type                           shift and go to state 229

state 203

    (79) for_stmt -> FOR assignment SEMICOLON expression SEMICOLON . for_update block
    (81) for_update -> . assignment
    (82) for_update -> . increment_stmt
    (35) assignment -> . VARIABLE ASSIGN expression
    (36) assignment -> . VARIABLE ASIG expression
    (122) increment_stmt -> . VARIABLE INCREMENT
    (123) increment_stmt -> . VARIABLE DECREMENT

    VARIABLE        shift and go to state 233

    assignment                     shift and go to state 230
    for_update                     shift and go to state 231
    increment_stmt                 shift and go to state 232

state 204

    (89) struct_field -> VARIABLE . type
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82

    type                           shift and go to state 234

state 205

    (86) struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields . RBRACE

    RBRACE          shift and go to state 235


state 206

    (87) struct_fields -> struct_field .
    (88) struct_fields -> struct_field . struct_fields
    (87) struct_fields -> . struct_field
    (88) struct_fields -> . struct_field struct_fields
    (89) struct_field -> . VARIABLE type
    (90) struct_field -> . type
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE

    RBRACE          reduce using rule 87 (struct_fields -> struct_field .)
    VARIABLE        shift and go to state 204
    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82

    struct_field                   shift and go to state 206
    struct_fields                  shift and go to state 236
    type                           shift and go to state 207

state 207

    (90) struct_field -> type .

    VARIABLE        reduce using rule 90 (struct_field -> type .)
    INT_TYPE        reduce using rule 90 (struct_field -> type .)
    FLOAT64_TYPE    reduce using rule 90 (struct_field -> type .)
    STRING_TYPE     reduce using rule 90 (struct_field -> type .)
    BOOL_TYPE       reduce using rule 90 (struct_field -> type .)
    RBRACE          reduce using rule 90 (struct_field -> type .)


state 208

    (95) switch_stmt -> SWITCH expression LBRACE case_list RBRACE .

    VAR             reduce using rule 95 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    VARIABLE        reduce using rule 95 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    FMT             reduce using rule 95 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    CONTINUE        reduce using rule 95 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    FUNC            reduce using rule 95 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    IF              reduce using rule 95 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    FOR             reduce using rule 95 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    TYPE            reduce using rule 95 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    SWITCH          reduce using rule 95 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    LBRACKET        reduce using rule 95 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    BREAK           reduce using rule 95 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    RETURN          reduce using rule 95 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    $end            reduce using rule 95 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    RBRACE          reduce using rule 95 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    CASE            reduce using rule 95 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)
    DEFAULT         reduce using rule 95 (switch_stmt -> SWITCH expression LBRACE case_list RBRACE .)


state 209

    (99) case_clause -> CASE expression COLON . program
    (4) program -> . statement
    (5) program -> . statement program
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . print_stmt
    (9) statement -> . input_stmt
    (10) statement -> . continue_stmt
    (11) statement -> . struct_method
    (12) statement -> . func_def
    (13) statement -> . func_no_params
    (14) statement -> . func_call
    (15) statement -> . if_stmt
    (16) statement -> . for_stmt
    (17) statement -> . struct_def
    (18) statement -> . switch_stmt
    (19) statement -> . map_declaration
    (20) statement -> . map_declaration_values
    (21) statement -> . array_declaration
    (22) statement -> . array_literal
    (23) statement -> . slice_declaration
    (24) statement -> . make_stmt
    (25) statement -> . new_stmt
    (26) statement -> . break_stmt
    (27) statement -> . increment_stmt
    (28) statement -> . return_stmt
    (29) declaration -> . VAR VARIABLE type
    (30) declaration -> . VAR VARIABLE type ASIG expression
    (31) declaration -> . VAR VARIABLE type ASSIGN expression
    (35) assignment -> . VARIABLE ASSIGN expression
    (36) assignment -> . VARIABLE ASIG expression
    (37) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (38) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (39) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (80) continue_stmt -> . CONTINUE
    (84) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (85) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (40) func_def -> . FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (41) func_def -> . FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (43) func_no_params -> . FUNC VARIABLE LPAREN RPAREN block
    (44) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (45) func_call -> . VARIABLE LPAREN RPAREN
    (76) if_stmt -> . IF expression block
    (77) if_stmt -> . IF expression block ELSE block
    (78) for_stmt -> . FOR expression block
    (79) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update block
    (86) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (95) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (96) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (101) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (102) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (107) map_declaration_values -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
    (111) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (112) array_declaration -> . VAR VARIABLE ASSIGN array_literal
    (113) array_literal -> . LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (116) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (117) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (103) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (104) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (120) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (121) break_stmt -> . BREAK
    (122) increment_stmt -> . VARIABLE INCREMENT
    (123) increment_stmt -> . VARIABLE DECREMENT
    (42) return_stmt -> . RETURN expression

    VAR             shift and go to state 31
    VARIABLE        shift and go to state 32
    FMT             shift and go to state 33
    CONTINUE        shift and go to state 34
    FUNC            shift and go to state 35
    IF              shift and go to state 36
    FOR             shift and go to state 37
    TYPE            shift and go to state 38
    SWITCH          shift and go to state 39
    LBRACKET        shift and go to state 40
    BREAK           shift and go to state 41
    RETURN          shift and go to state 42

    program                        shift and go to state 237
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    assignment                     shift and go to state 9
    print_stmt                     shift and go to state 10
    input_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    struct_method                  shift and go to state 13
    func_def                       shift and go to state 14
    func_no_params                 shift and go to state 15
    func_call                      shift and go to state 16
    if_stmt                        shift and go to state 17
    for_stmt                       shift and go to state 18
    struct_def                     shift and go to state 19
    switch_stmt                    shift and go to state 20
    map_declaration                shift and go to state 21
    map_declaration_values         shift and go to state 22
    array_declaration              shift and go to state 23
    array_literal                  shift and go to state 24
    slice_declaration              shift and go to state 25
    make_stmt                      shift and go to state 26
    new_stmt                       shift and go to state 27
    break_stmt                     shift and go to state 28
    increment_stmt                 shift and go to state 29
    return_stmt                    shift and go to state 30

state 210

    (100) case_clause -> DEFAULT COLON program .

    CASE            reduce using rule 100 (case_clause -> DEFAULT COLON program .)
    DEFAULT         reduce using rule 100 (case_clause -> DEFAULT COLON program .)
    RBRACE          reduce using rule 100 (case_clause -> DEFAULT COLON program .)


state 211

    (113) array_literal -> LBRACKET NUMBER RBRACKET type LBRACE . array_values RBRACE
    (114) array_values -> . expression
    (115) array_values -> . expression COMMA array_values
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    array_values                   shift and go to state 238
    expression                     shift and go to state 239
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 212

    (101) map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET . type
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82

    type                           shift and go to state 240

state 213

    (111) array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .

    VAR             reduce using rule 111 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    VARIABLE        reduce using rule 111 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    FMT             reduce using rule 111 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    CONTINUE        reduce using rule 111 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    FUNC            reduce using rule 111 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    IF              reduce using rule 111 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    FOR             reduce using rule 111 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    TYPE            reduce using rule 111 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    SWITCH          reduce using rule 111 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    LBRACKET        reduce using rule 111 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    BREAK           reduce using rule 111 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    RETURN          reduce using rule 111 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    $end            reduce using rule 111 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    RBRACE          reduce using rule 111 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    CASE            reduce using rule 111 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)
    DEFAULT         reduce using rule 111 (array_declaration -> VAR VARIABLE LBRACKET NUMBER RBRACKET type .)


state 214

    (102) map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET . type
    (107) map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET . type LBRACE map_kv_pairs RBRACE
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82

    type                           shift and go to state 241

state 215

    (117) slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE . slice_values RBRACE
    (118) slice_values -> . expression
    (119) slice_values -> . expression COMMA slice_values
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    slice_values                   shift and go to state 242
    expression                     shift and go to state 243
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 216

    (103) make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET . type RBRACKET type RPAREN
    (105) make_expr -> MAKE LPAREN MAP LBRACKET . type RBRACKET type RPAREN
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82

    type                           shift and go to state 244

state 217

    (104) make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET . type RPAREN
    (106) make_expr -> MAKE LPAREN LBRACKET RBRACKET . type RPAREN
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82

    type                           shift and go to state 245

state 218

    (120) new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .

    VAR             reduce using rule 120 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    VARIABLE        reduce using rule 120 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    FMT             reduce using rule 120 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    CONTINUE        reduce using rule 120 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    FUNC            reduce using rule 120 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    IF              reduce using rule 120 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    FOR             reduce using rule 120 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    TYPE            reduce using rule 120 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    SWITCH          reduce using rule 120 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    LBRACKET        reduce using rule 120 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    BREAK           reduce using rule 120 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    RETURN          reduce using rule 120 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    $end            reduce using rule 120 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    RBRACE          reduce using rule 120 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    CASE            reduce using rule 120 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)
    DEFAULT         reduce using rule 120 (new_stmt -> VARIABLE ASIG NEW LPAREN VARIABLE RPAREN .)


state 219

    (37) print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA . expression RPAREN
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 246
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 220

    (38) print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .

    VAR             reduce using rule 38 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    VARIABLE        reduce using rule 38 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    FMT             reduce using rule 38 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    CONTINUE        reduce using rule 38 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    FUNC            reduce using rule 38 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    IF              reduce using rule 38 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    FOR             reduce using rule 38 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    TYPE            reduce using rule 38 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    SWITCH          reduce using rule 38 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 38 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    BREAK           reduce using rule 38 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    RETURN          reduce using rule 38 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    $end            reduce using rule 38 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    RBRACE          reduce using rule 38 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    CASE            reduce using rule 38 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)
    DEFAULT         reduce using rule 38 (print_stmt -> FMT DOT PRINTLN LPAREN expression RPAREN .)


state 221

    (39) input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE . RPAREN

    RPAREN          shift and go to state 247


state 222

    (84) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE . LPAREN param_list RPAREN type LBRACE program RBRACE
    (85) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE . LPAREN RPAREN type LBRACE program RBRACE

    LPAREN          shift and go to state 248


state 223

    (40) func_def -> FUNC VARIABLE LPAREN param_list RPAREN type . LBRACE program RBRACE

    LBRACE          shift and go to state 249


state 224

    (41) func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE . program RBRACE
    (4) program -> . statement
    (5) program -> . statement program
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . print_stmt
    (9) statement -> . input_stmt
    (10) statement -> . continue_stmt
    (11) statement -> . struct_method
    (12) statement -> . func_def
    (13) statement -> . func_no_params
    (14) statement -> . func_call
    (15) statement -> . if_stmt
    (16) statement -> . for_stmt
    (17) statement -> . struct_def
    (18) statement -> . switch_stmt
    (19) statement -> . map_declaration
    (20) statement -> . map_declaration_values
    (21) statement -> . array_declaration
    (22) statement -> . array_literal
    (23) statement -> . slice_declaration
    (24) statement -> . make_stmt
    (25) statement -> . new_stmt
    (26) statement -> . break_stmt
    (27) statement -> . increment_stmt
    (28) statement -> . return_stmt
    (29) declaration -> . VAR VARIABLE type
    (30) declaration -> . VAR VARIABLE type ASIG expression
    (31) declaration -> . VAR VARIABLE type ASSIGN expression
    (35) assignment -> . VARIABLE ASSIGN expression
    (36) assignment -> . VARIABLE ASIG expression
    (37) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (38) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (39) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (80) continue_stmt -> . CONTINUE
    (84) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (85) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (40) func_def -> . FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (41) func_def -> . FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (43) func_no_params -> . FUNC VARIABLE LPAREN RPAREN block
    (44) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (45) func_call -> . VARIABLE LPAREN RPAREN
    (76) if_stmt -> . IF expression block
    (77) if_stmt -> . IF expression block ELSE block
    (78) for_stmt -> . FOR expression block
    (79) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update block
    (86) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (95) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (96) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (101) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (102) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (107) map_declaration_values -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
    (111) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (112) array_declaration -> . VAR VARIABLE ASSIGN array_literal
    (113) array_literal -> . LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (116) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (117) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (103) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (104) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (120) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (121) break_stmt -> . BREAK
    (122) increment_stmt -> . VARIABLE INCREMENT
    (123) increment_stmt -> . VARIABLE DECREMENT
    (42) return_stmt -> . RETURN expression

    VAR             shift and go to state 31
    VARIABLE        shift and go to state 32
    FMT             shift and go to state 33
    CONTINUE        shift and go to state 34
    FUNC            shift and go to state 35
    IF              shift and go to state 36
    FOR             shift and go to state 37
    TYPE            shift and go to state 38
    SWITCH          shift and go to state 39
    LBRACKET        shift and go to state 40
    BREAK           shift and go to state 41
    RETURN          shift and go to state 42

    program                        shift and go to state 250
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    assignment                     shift and go to state 9
    print_stmt                     shift and go to state 10
    input_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    struct_method                  shift and go to state 13
    func_def                       shift and go to state 14
    func_no_params                 shift and go to state 15
    func_call                      shift and go to state 16
    if_stmt                        shift and go to state 17
    for_stmt                       shift and go to state 18
    struct_def                     shift and go to state 19
    switch_stmt                    shift and go to state 20
    map_declaration                shift and go to state 21
    map_declaration_values         shift and go to state 22
    array_declaration              shift and go to state 23
    array_literal                  shift and go to state 24
    slice_declaration              shift and go to state 25
    make_stmt                      shift and go to state 26
    new_stmt                       shift and go to state 27
    break_stmt                     shift and go to state 28
    increment_stmt                 shift and go to state 29
    return_stmt                    shift and go to state 30

state 225

    (47) param_list -> param COMMA param_list .

    RPAREN          reduce using rule 47 (param_list -> param COMMA param_list .)


state 226

    (94) field_value -> VARIABLE COLON expression .
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

    COMMA           reduce using rule 94 (field_value -> VARIABLE COLON expression .)
    RBRACE          reduce using rule 94 (field_value -> VARIABLE COLON expression .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107


state 227

    (93) struct_fields_values -> field_value COMMA struct_fields_values .

    RBRACE          reduce using rule 93 (struct_fields_values -> field_value COMMA struct_fields_values .)


state 228

    (105) make_expr -> MAKE LPAREN MAP LBRACKET type . RBRACKET type RPAREN

    RBRACKET        shift and go to state 251


state 229

    (106) make_expr -> MAKE LPAREN LBRACKET RBRACKET type . RPAREN

    RPAREN          shift and go to state 252


state 230

    (81) for_update -> assignment .

    LBRACE          reduce using rule 81 (for_update -> assignment .)


state 231

    (79) for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update . block
    (83) block -> . LBRACE program RBRACE

    LBRACE          shift and go to state 108

    block                          shift and go to state 253

state 232

    (82) for_update -> increment_stmt .

    LBRACE          reduce using rule 82 (for_update -> increment_stmt .)


state 233

    (35) assignment -> VARIABLE . ASSIGN expression
    (36) assignment -> VARIABLE . ASIG expression
    (122) increment_stmt -> VARIABLE . INCREMENT
    (123) increment_stmt -> VARIABLE . DECREMENT

    ASSIGN          shift and go to state 47
    ASIG            shift and go to state 116
    INCREMENT       shift and go to state 50
    DECREMENT       shift and go to state 51


state 234

    (89) struct_field -> VARIABLE type .

    VARIABLE        reduce using rule 89 (struct_field -> VARIABLE type .)
    INT_TYPE        reduce using rule 89 (struct_field -> VARIABLE type .)
    FLOAT64_TYPE    reduce using rule 89 (struct_field -> VARIABLE type .)
    STRING_TYPE     reduce using rule 89 (struct_field -> VARIABLE type .)
    BOOL_TYPE       reduce using rule 89 (struct_field -> VARIABLE type .)
    RBRACE          reduce using rule 89 (struct_field -> VARIABLE type .)


state 235

    (86) struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .

    VAR             reduce using rule 86 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    VARIABLE        reduce using rule 86 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    FMT             reduce using rule 86 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    CONTINUE        reduce using rule 86 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    FUNC            reduce using rule 86 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    IF              reduce using rule 86 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    FOR             reduce using rule 86 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    TYPE            reduce using rule 86 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    SWITCH          reduce using rule 86 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    LBRACKET        reduce using rule 86 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    BREAK           reduce using rule 86 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    RETURN          reduce using rule 86 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    $end            reduce using rule 86 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    RBRACE          reduce using rule 86 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    CASE            reduce using rule 86 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)
    DEFAULT         reduce using rule 86 (struct_def -> TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE .)


state 236

    (88) struct_fields -> struct_field struct_fields .

    RBRACE          reduce using rule 88 (struct_fields -> struct_field struct_fields .)


state 237

    (99) case_clause -> CASE expression COLON program .

    CASE            reduce using rule 99 (case_clause -> CASE expression COLON program .)
    DEFAULT         reduce using rule 99 (case_clause -> CASE expression COLON program .)
    RBRACE          reduce using rule 99 (case_clause -> CASE expression COLON program .)


state 238

    (113) array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values . RBRACE

    RBRACE          shift and go to state 254


state 239

    (114) array_values -> expression .
    (115) array_values -> expression . COMMA array_values
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

    RBRACE          reduce using rule 114 (array_values -> expression .)
    COMMA           shift and go to state 255
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107


state 240

    (101) map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .

    VAR             reduce using rule 101 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    VARIABLE        reduce using rule 101 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    FMT             reduce using rule 101 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    CONTINUE        reduce using rule 101 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    FUNC            reduce using rule 101 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    IF              reduce using rule 101 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    FOR             reduce using rule 101 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    TYPE            reduce using rule 101 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    SWITCH          reduce using rule 101 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    LBRACKET        reduce using rule 101 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    BREAK           reduce using rule 101 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    RETURN          reduce using rule 101 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    $end            reduce using rule 101 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    RBRACE          reduce using rule 101 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    CASE            reduce using rule 101 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)
    DEFAULT         reduce using rule 101 (map_declaration -> VAR VARIABLE MAP LBRACKET type RBRACKET type .)


state 241

    (102) map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .
    (107) map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type . LBRACE map_kv_pairs RBRACE

    VAR             reduce using rule 102 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    VARIABLE        reduce using rule 102 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    FMT             reduce using rule 102 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    CONTINUE        reduce using rule 102 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    FUNC            reduce using rule 102 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    IF              reduce using rule 102 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    FOR             reduce using rule 102 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    TYPE            reduce using rule 102 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    SWITCH          reduce using rule 102 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    LBRACKET        reduce using rule 102 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    BREAK           reduce using rule 102 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    RETURN          reduce using rule 102 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    $end            reduce using rule 102 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    RBRACE          reduce using rule 102 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    CASE            reduce using rule 102 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    DEFAULT         reduce using rule 102 (map_declaration -> VARIABLE ASIG MAP LBRACKET type RBRACKET type .)
    LBRACE          shift and go to state 256


state 242

    (117) slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values . RBRACE

    RBRACE          shift and go to state 257


state 243

    (118) slice_values -> expression .
    (119) slice_values -> expression . COMMA slice_values
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

    RBRACE          reduce using rule 118 (slice_values -> expression .)
    COMMA           shift and go to state 258
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107


state 244

    (103) make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type . RBRACKET type RPAREN
    (105) make_expr -> MAKE LPAREN MAP LBRACKET type . RBRACKET type RPAREN

    RBRACKET        shift and go to state 259


state 245

    (104) make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type . RPAREN
    (106) make_expr -> MAKE LPAREN LBRACKET RBRACKET type . RPAREN

    RPAREN          shift and go to state 260


state 246

    (37) print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression . RPAREN
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

    RPAREN          shift and go to state 261
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107


state 247

    (39) input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .

    VAR             reduce using rule 39 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    VARIABLE        reduce using rule 39 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    FMT             reduce using rule 39 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    CONTINUE        reduce using rule 39 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    FUNC            reduce using rule 39 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    IF              reduce using rule 39 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    FOR             reduce using rule 39 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    TYPE            reduce using rule 39 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    SWITCH          reduce using rule 39 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    LBRACKET        reduce using rule 39 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    BREAK           reduce using rule 39 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    RETURN          reduce using rule 39 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    $end            reduce using rule 39 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    RBRACE          reduce using rule 39 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    CASE            reduce using rule 39 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)
    DEFAULT         reduce using rule 39 (input_stmt -> FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN .)


state 248

    (84) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN . param_list RPAREN type LBRACE program RBRACE
    (85) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN . RPAREN type LBRACE program RBRACE
    (46) param_list -> . param
    (47) param_list -> . param COMMA param_list
    (48) param -> . VARIABLE type

    RPAREN          shift and go to state 262
    VARIABLE        shift and go to state 141

    param_list                     shift and go to state 263
    param                          shift and go to state 144

state 249

    (40) func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE . program RBRACE
    (4) program -> . statement
    (5) program -> . statement program
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . print_stmt
    (9) statement -> . input_stmt
    (10) statement -> . continue_stmt
    (11) statement -> . struct_method
    (12) statement -> . func_def
    (13) statement -> . func_no_params
    (14) statement -> . func_call
    (15) statement -> . if_stmt
    (16) statement -> . for_stmt
    (17) statement -> . struct_def
    (18) statement -> . switch_stmt
    (19) statement -> . map_declaration
    (20) statement -> . map_declaration_values
    (21) statement -> . array_declaration
    (22) statement -> . array_literal
    (23) statement -> . slice_declaration
    (24) statement -> . make_stmt
    (25) statement -> . new_stmt
    (26) statement -> . break_stmt
    (27) statement -> . increment_stmt
    (28) statement -> . return_stmt
    (29) declaration -> . VAR VARIABLE type
    (30) declaration -> . VAR VARIABLE type ASIG expression
    (31) declaration -> . VAR VARIABLE type ASSIGN expression
    (35) assignment -> . VARIABLE ASSIGN expression
    (36) assignment -> . VARIABLE ASIG expression
    (37) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (38) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (39) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (80) continue_stmt -> . CONTINUE
    (84) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (85) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (40) func_def -> . FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (41) func_def -> . FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (43) func_no_params -> . FUNC VARIABLE LPAREN RPAREN block
    (44) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (45) func_call -> . VARIABLE LPAREN RPAREN
    (76) if_stmt -> . IF expression block
    (77) if_stmt -> . IF expression block ELSE block
    (78) for_stmt -> . FOR expression block
    (79) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update block
    (86) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (95) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (96) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (101) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (102) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (107) map_declaration_values -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
    (111) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (112) array_declaration -> . VAR VARIABLE ASSIGN array_literal
    (113) array_literal -> . LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (116) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (117) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (103) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (104) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (120) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (121) break_stmt -> . BREAK
    (122) increment_stmt -> . VARIABLE INCREMENT
    (123) increment_stmt -> . VARIABLE DECREMENT
    (42) return_stmt -> . RETURN expression

    VAR             shift and go to state 31
    VARIABLE        shift and go to state 32
    FMT             shift and go to state 33
    CONTINUE        shift and go to state 34
    FUNC            shift and go to state 35
    IF              shift and go to state 36
    FOR             shift and go to state 37
    TYPE            shift and go to state 38
    SWITCH          shift and go to state 39
    LBRACKET        shift and go to state 40
    BREAK           shift and go to state 41
    RETURN          shift and go to state 42

    program                        shift and go to state 264
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    assignment                     shift and go to state 9
    print_stmt                     shift and go to state 10
    input_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    struct_method                  shift and go to state 13
    func_def                       shift and go to state 14
    func_no_params                 shift and go to state 15
    func_call                      shift and go to state 16
    if_stmt                        shift and go to state 17
    for_stmt                       shift and go to state 18
    struct_def                     shift and go to state 19
    switch_stmt                    shift and go to state 20
    map_declaration                shift and go to state 21
    map_declaration_values         shift and go to state 22
    array_declaration              shift and go to state 23
    array_literal                  shift and go to state 24
    slice_declaration              shift and go to state 25
    make_stmt                      shift and go to state 26
    new_stmt                       shift and go to state 27
    break_stmt                     shift and go to state 28
    increment_stmt                 shift and go to state 29
    return_stmt                    shift and go to state 30

state 250

    (41) func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program . RBRACE

    RBRACE          shift and go to state 265


state 251

    (105) make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET . type RPAREN
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82

    type                           shift and go to state 266

state 252

    (106) make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .

    TIMES           reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    DIVIDE          reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    PLUS            reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    MINUS           reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    AND             reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    OR              reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    EQ              reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    NE              reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    LT              reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    GT              reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    LE              reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    GE              reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    LBRACE          reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    VAR             reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    VARIABLE        reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    FMT             reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    CONTINUE        reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    FUNC            reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    IF              reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    FOR             reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    TYPE            reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    SWITCH          reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    LBRACKET        reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    BREAK           reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    RETURN          reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    $end            reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    RBRACE          reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    CASE            reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    DEFAULT         reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    SEMICOLON       reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    COMMA           reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    RPAREN          reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    COLON           reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)


state 253

    (79) for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .

    VAR             reduce using rule 79 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    VARIABLE        reduce using rule 79 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    FMT             reduce using rule 79 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    CONTINUE        reduce using rule 79 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    FUNC            reduce using rule 79 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    IF              reduce using rule 79 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    FOR             reduce using rule 79 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    TYPE            reduce using rule 79 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    SWITCH          reduce using rule 79 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    LBRACKET        reduce using rule 79 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    BREAK           reduce using rule 79 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    RETURN          reduce using rule 79 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    $end            reduce using rule 79 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    RBRACE          reduce using rule 79 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    CASE            reduce using rule 79 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)
    DEFAULT         reduce using rule 79 (for_stmt -> FOR assignment SEMICOLON expression SEMICOLON for_update block .)


state 254

    (113) array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .

    VAR             reduce using rule 113 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    VARIABLE        reduce using rule 113 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    FMT             reduce using rule 113 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    CONTINUE        reduce using rule 113 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    FUNC            reduce using rule 113 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    IF              reduce using rule 113 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    FOR             reduce using rule 113 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    TYPE            reduce using rule 113 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    SWITCH          reduce using rule 113 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    LBRACKET        reduce using rule 113 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    BREAK           reduce using rule 113 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    RETURN          reduce using rule 113 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    $end            reduce using rule 113 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    RBRACE          reduce using rule 113 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    CASE            reduce using rule 113 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)
    DEFAULT         reduce using rule 113 (array_literal -> LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE .)


state 255

    (115) array_values -> expression COMMA . array_values
    (114) array_values -> . expression
    (115) array_values -> . expression COMMA array_values
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 239
    array_values                   shift and go to state 267
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 256

    (107) map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE . map_kv_pairs RBRACE
    (108) map_kv_pairs -> . map_kv_pair
    (109) map_kv_pairs -> . map_kv_pair COMMA map_kv_pairs
    (110) map_kv_pair -> . STRING COLON expression

    STRING          shift and go to state 270

    map_kv_pairs                   shift and go to state 268
    map_kv_pair                    shift and go to state 269

state 257

    (117) slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .

    VAR             reduce using rule 117 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    VARIABLE        reduce using rule 117 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    FMT             reduce using rule 117 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    CONTINUE        reduce using rule 117 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    FUNC            reduce using rule 117 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    IF              reduce using rule 117 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    FOR             reduce using rule 117 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    TYPE            reduce using rule 117 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    SWITCH          reduce using rule 117 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    LBRACKET        reduce using rule 117 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    BREAK           reduce using rule 117 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    RETURN          reduce using rule 117 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    $end            reduce using rule 117 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    RBRACE          reduce using rule 117 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    CASE            reduce using rule 117 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)
    DEFAULT         reduce using rule 117 (slice_declaration -> VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE .)


state 258

    (119) slice_values -> expression COMMA . slice_values
    (118) slice_values -> . expression
    (119) slice_values -> . expression COMMA slice_values
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 243
    slice_values                   shift and go to state 271
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 259

    (103) make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET . type RPAREN
    (105) make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET . type RPAREN
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82

    type                           shift and go to state 272

state 260

    (104) make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .
    (106) make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .

  ! reduce/reduce conflict for VAR resolved using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for FMT resolved using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for FUNC resolved using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for IF resolved using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for FOR resolved using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for TYPE resolved using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for SWITCH resolved using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for BREAK resolved using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for RETURN resolved using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for $end resolved using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for RBRACE resolved using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for CASE resolved using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    VAR             reduce using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    VARIABLE        reduce using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    FMT             reduce using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    CONTINUE        reduce using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    FUNC            reduce using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    IF              reduce using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    FOR             reduce using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    TYPE            reduce using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    SWITCH          reduce using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    LBRACKET        reduce using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    BREAK           reduce using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    RETURN          reduce using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    $end            reduce using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    RBRACE          reduce using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    CASE            reduce using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    DEFAULT         reduce using rule 104 (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    TIMES           reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    DIVIDE          reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    PLUS            reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    MINUS           reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    AND             reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    OR              reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    EQ              reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    NE              reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    LT              reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    GT              reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    LE              reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)
    GE              reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .)

  ! VAR             [ reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! VARIABLE        [ reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! FMT             [ reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! CONTINUE        [ reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! FUNC            [ reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! IF              [ reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! FOR             [ reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! TYPE            [ reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! SWITCH          [ reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! LBRACKET        [ reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! BREAK           [ reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! RETURN          [ reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! $end            [ reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! RBRACE          [ reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! CASE            [ reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]
  ! DEFAULT         [ reduce using rule 106 (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN .) ]


state 261

    (37) print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .

    VAR             reduce using rule 37 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    VARIABLE        reduce using rule 37 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    FMT             reduce using rule 37 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    CONTINUE        reduce using rule 37 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    FUNC            reduce using rule 37 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    IF              reduce using rule 37 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    FOR             reduce using rule 37 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    TYPE            reduce using rule 37 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    SWITCH          reduce using rule 37 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    LBRACKET        reduce using rule 37 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    BREAK           reduce using rule 37 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    RETURN          reduce using rule 37 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    $end            reduce using rule 37 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    RBRACE          reduce using rule 37 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    CASE            reduce using rule 37 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)
    DEFAULT         reduce using rule 37 (print_stmt -> FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN .)


state 262

    (85) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN . type LBRACE program RBRACE
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82

    type                           shift and go to state 273

state 263

    (84) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list . RPAREN type LBRACE program RBRACE

    RPAREN          shift and go to state 274


state 264

    (40) func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program . RBRACE

    RBRACE          shift and go to state 275


state 265

    (41) func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .

    VAR             reduce using rule 41 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    VARIABLE        reduce using rule 41 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    FMT             reduce using rule 41 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    CONTINUE        reduce using rule 41 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    FUNC            reduce using rule 41 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    IF              reduce using rule 41 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    FOR             reduce using rule 41 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    TYPE            reduce using rule 41 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    SWITCH          reduce using rule 41 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    LBRACKET        reduce using rule 41 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    BREAK           reduce using rule 41 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    RETURN          reduce using rule 41 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    $end            reduce using rule 41 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    RBRACE          reduce using rule 41 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    CASE            reduce using rule 41 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    DEFAULT         reduce using rule 41 (func_def -> FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)


state 266

    (105) make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type . RPAREN

    RPAREN          shift and go to state 276


state 267

    (115) array_values -> expression COMMA array_values .

    RBRACE          reduce using rule 115 (array_values -> expression COMMA array_values .)


state 268

    (107) map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs . RBRACE

    RBRACE          shift and go to state 277


state 269

    (108) map_kv_pairs -> map_kv_pair .
    (109) map_kv_pairs -> map_kv_pair . COMMA map_kv_pairs

    RBRACE          reduce using rule 108 (map_kv_pairs -> map_kv_pair .)
    COMMA           shift and go to state 278


state 270

    (110) map_kv_pair -> STRING . COLON expression

    COLON           shift and go to state 279


state 271

    (119) slice_values -> expression COMMA slice_values .

    RBRACE          reduce using rule 119 (slice_values -> expression COMMA slice_values .)


state 272

    (103) make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type . RPAREN
    (105) make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type . RPAREN

    RPAREN          shift and go to state 280


state 273

    (85) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type . LBRACE program RBRACE

    LBRACE          shift and go to state 281


state 274

    (84) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN . type LBRACE program RBRACE
    (72) type -> . INT_TYPE
    (73) type -> . FLOAT64_TYPE
    (74) type -> . STRING_TYPE
    (75) type -> . BOOL_TYPE

    INT_TYPE        shift and go to state 79
    FLOAT64_TYPE    shift and go to state 80
    STRING_TYPE     shift and go to state 81
    BOOL_TYPE       shift and go to state 82

    type                           shift and go to state 282

state 275

    (40) func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .

    VAR             reduce using rule 40 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    VARIABLE        reduce using rule 40 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    FMT             reduce using rule 40 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    CONTINUE        reduce using rule 40 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    FUNC            reduce using rule 40 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    IF              reduce using rule 40 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    FOR             reduce using rule 40 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    TYPE            reduce using rule 40 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    SWITCH          reduce using rule 40 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    LBRACKET        reduce using rule 40 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    BREAK           reduce using rule 40 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    RETURN          reduce using rule 40 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    $end            reduce using rule 40 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    RBRACE          reduce using rule 40 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    CASE            reduce using rule 40 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    DEFAULT         reduce using rule 40 (func_def -> FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)


state 276

    (105) make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .

    TIMES           reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    DIVIDE          reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    PLUS            reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    MINUS           reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    AND             reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    OR              reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    EQ              reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    NE              reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LT              reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    GT              reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LE              reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    GE              reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LBRACE          reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VAR             reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VARIABLE        reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FMT             reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CONTINUE        reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FUNC            reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    IF              reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FOR             reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    TYPE            reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    SWITCH          reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LBRACKET        reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    BREAK           reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RETURN          reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    $end            reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RBRACE          reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CASE            reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    DEFAULT         reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    SEMICOLON       reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    COMMA           reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RPAREN          reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    COLON           reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)


state 277

    (107) map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .

    VAR             reduce using rule 107 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    VARIABLE        reduce using rule 107 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    FMT             reduce using rule 107 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    CONTINUE        reduce using rule 107 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    FUNC            reduce using rule 107 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    IF              reduce using rule 107 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    FOR             reduce using rule 107 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    TYPE            reduce using rule 107 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    SWITCH          reduce using rule 107 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    LBRACKET        reduce using rule 107 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    BREAK           reduce using rule 107 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    RETURN          reduce using rule 107 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    $end            reduce using rule 107 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    RBRACE          reduce using rule 107 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    CASE            reduce using rule 107 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)
    DEFAULT         reduce using rule 107 (map_declaration_values -> VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE .)


state 278

    (109) map_kv_pairs -> map_kv_pair COMMA . map_kv_pairs
    (108) map_kv_pairs -> . map_kv_pair
    (109) map_kv_pairs -> . map_kv_pair COMMA map_kv_pairs
    (110) map_kv_pair -> . STRING COLON expression

    STRING          shift and go to state 270

    map_kv_pair                    shift and go to state 269
    map_kv_pairs                   shift and go to state 283

state 279

    (110) map_kv_pair -> STRING COLON . expression
    (32) expression -> . NUMBER
    (33) expression -> . FLOAT
    (34) expression -> . VARIABLE
    (51) expression -> . term
    (52) expression -> . expression PLUS term
    (53) expression -> . expression MINUS term
    (54) expression -> . expression AND expression
    (55) expression -> . expression OR expression
    (56) expression -> . expression EQ expression
    (57) expression -> . expression NE expression
    (58) expression -> . expression LT expression
    (59) expression -> . expression GT expression
    (60) expression -> . expression LE expression
    (61) expression -> . expression GE expression
    (62) term -> . factor
    (63) term -> . term TIMES factor
    (64) term -> . term DIVIDE factor
    (65) factor -> . NUMBER
    (66) factor -> . FLOAT
    (67) factor -> . STRING
    (68) factor -> . VARIABLE
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . make_expr
    (71) factor -> . struct_instance
    (105) make_expr -> . MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (106) make_expr -> . MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (91) struct_instance -> . VARIABLE LBRACE struct_fields_values RBRACE

    NUMBER          shift and go to state 56
    FLOAT           shift and go to state 57
    VARIABLE        shift and go to state 58
    STRING          shift and go to state 61
    LPAREN          shift and go to state 62
    MAKE            shift and go to state 65

    expression                     shift and go to state 284
    term                           shift and go to state 59
    factor                         shift and go to state 60
    make_expr                      shift and go to state 63
    struct_instance                shift and go to state 64

state 280

    (103) make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .
    (105) make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .

  ! reduce/reduce conflict for VAR resolved using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for VARIABLE resolved using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for FMT resolved using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for CONTINUE resolved using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for FUNC resolved using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for IF resolved using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for FOR resolved using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for TYPE resolved using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for SWITCH resolved using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for BREAK resolved using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for RETURN resolved using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for $end resolved using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for RBRACE resolved using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for CASE resolved using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VAR             reduce using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    VARIABLE        reduce using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FMT             reduce using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CONTINUE        reduce using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FUNC            reduce using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    IF              reduce using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    FOR             reduce using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    TYPE            reduce using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    SWITCH          reduce using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LBRACKET        reduce using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    BREAK           reduce using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RETURN          reduce using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    $end            reduce using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    RBRACE          reduce using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    CASE            reduce using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    DEFAULT         reduce using rule 103 (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    TIMES           reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    DIVIDE          reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    PLUS            reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    MINUS           reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    AND             reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    OR              reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    EQ              reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    NE              reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LT              reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    GT              reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    LE              reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)
    GE              reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .)

  ! VAR             [ reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! VARIABLE        [ reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! FMT             [ reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! CONTINUE        [ reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! FUNC            [ reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! IF              [ reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! FOR             [ reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! TYPE            [ reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! SWITCH          [ reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! LBRACKET        [ reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! BREAK           [ reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! RETURN          [ reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! $end            [ reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! RBRACE          [ reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! CASE            [ reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]
  ! DEFAULT         [ reduce using rule 105 (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN .) ]


state 281

    (85) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE . program RBRACE
    (4) program -> . statement
    (5) program -> . statement program
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . print_stmt
    (9) statement -> . input_stmt
    (10) statement -> . continue_stmt
    (11) statement -> . struct_method
    (12) statement -> . func_def
    (13) statement -> . func_no_params
    (14) statement -> . func_call
    (15) statement -> . if_stmt
    (16) statement -> . for_stmt
    (17) statement -> . struct_def
    (18) statement -> . switch_stmt
    (19) statement -> . map_declaration
    (20) statement -> . map_declaration_values
    (21) statement -> . array_declaration
    (22) statement -> . array_literal
    (23) statement -> . slice_declaration
    (24) statement -> . make_stmt
    (25) statement -> . new_stmt
    (26) statement -> . break_stmt
    (27) statement -> . increment_stmt
    (28) statement -> . return_stmt
    (29) declaration -> . VAR VARIABLE type
    (30) declaration -> . VAR VARIABLE type ASIG expression
    (31) declaration -> . VAR VARIABLE type ASSIGN expression
    (35) assignment -> . VARIABLE ASSIGN expression
    (36) assignment -> . VARIABLE ASIG expression
    (37) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (38) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (39) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (80) continue_stmt -> . CONTINUE
    (84) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (85) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (40) func_def -> . FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (41) func_def -> . FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (43) func_no_params -> . FUNC VARIABLE LPAREN RPAREN block
    (44) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (45) func_call -> . VARIABLE LPAREN RPAREN
    (76) if_stmt -> . IF expression block
    (77) if_stmt -> . IF expression block ELSE block
    (78) for_stmt -> . FOR expression block
    (79) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update block
    (86) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (95) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (96) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (101) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (102) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (107) map_declaration_values -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
    (111) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (112) array_declaration -> . VAR VARIABLE ASSIGN array_literal
    (113) array_literal -> . LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (116) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (117) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (103) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (104) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (120) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (121) break_stmt -> . BREAK
    (122) increment_stmt -> . VARIABLE INCREMENT
    (123) increment_stmt -> . VARIABLE DECREMENT
    (42) return_stmt -> . RETURN expression

    VAR             shift and go to state 31
    VARIABLE        shift and go to state 32
    FMT             shift and go to state 33
    CONTINUE        shift and go to state 34
    FUNC            shift and go to state 35
    IF              shift and go to state 36
    FOR             shift and go to state 37
    TYPE            shift and go to state 38
    SWITCH          shift and go to state 39
    LBRACKET        shift and go to state 40
    BREAK           shift and go to state 41
    RETURN          shift and go to state 42

    program                        shift and go to state 285
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    assignment                     shift and go to state 9
    print_stmt                     shift and go to state 10
    input_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    struct_method                  shift and go to state 13
    func_def                       shift and go to state 14
    func_no_params                 shift and go to state 15
    func_call                      shift and go to state 16
    if_stmt                        shift and go to state 17
    for_stmt                       shift and go to state 18
    struct_def                     shift and go to state 19
    switch_stmt                    shift and go to state 20
    map_declaration                shift and go to state 21
    map_declaration_values         shift and go to state 22
    array_declaration              shift and go to state 23
    array_literal                  shift and go to state 24
    slice_declaration              shift and go to state 25
    make_stmt                      shift and go to state 26
    new_stmt                       shift and go to state 27
    break_stmt                     shift and go to state 28
    increment_stmt                 shift and go to state 29
    return_stmt                    shift and go to state 30

state 282

    (84) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type . LBRACE program RBRACE

    LBRACE          shift and go to state 286


state 283

    (109) map_kv_pairs -> map_kv_pair COMMA map_kv_pairs .

    RBRACE          reduce using rule 109 (map_kv_pairs -> map_kv_pair COMMA map_kv_pairs .)


state 284

    (110) map_kv_pair -> STRING COLON expression .
    (52) expression -> expression . PLUS term
    (53) expression -> expression . MINUS term
    (54) expression -> expression . AND expression
    (55) expression -> expression . OR expression
    (56) expression -> expression . EQ expression
    (57) expression -> expression . NE expression
    (58) expression -> expression . LT expression
    (59) expression -> expression . GT expression
    (60) expression -> expression . LE expression
    (61) expression -> expression . GE expression

    COMMA           reduce using rule 110 (map_kv_pair -> STRING COLON expression .)
    RBRACE          reduce using rule 110 (map_kv_pair -> STRING COLON expression .)
    PLUS            shift and go to state 98
    MINUS           shift and go to state 99
    AND             shift and go to state 100
    OR              shift and go to state 101
    EQ              shift and go to state 102
    NE              shift and go to state 103
    LT              shift and go to state 104
    GT              shift and go to state 105
    LE              shift and go to state 106
    GE              shift and go to state 107


state 285

    (85) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program . RBRACE

    RBRACE          shift and go to state 287


state 286

    (84) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE . program RBRACE
    (4) program -> . statement
    (5) program -> . statement program
    (6) statement -> . declaration
    (7) statement -> . assignment
    (8) statement -> . print_stmt
    (9) statement -> . input_stmt
    (10) statement -> . continue_stmt
    (11) statement -> . struct_method
    (12) statement -> . func_def
    (13) statement -> . func_no_params
    (14) statement -> . func_call
    (15) statement -> . if_stmt
    (16) statement -> . for_stmt
    (17) statement -> . struct_def
    (18) statement -> . switch_stmt
    (19) statement -> . map_declaration
    (20) statement -> . map_declaration_values
    (21) statement -> . array_declaration
    (22) statement -> . array_literal
    (23) statement -> . slice_declaration
    (24) statement -> . make_stmt
    (25) statement -> . new_stmt
    (26) statement -> . break_stmt
    (27) statement -> . increment_stmt
    (28) statement -> . return_stmt
    (29) declaration -> . VAR VARIABLE type
    (30) declaration -> . VAR VARIABLE type ASIG expression
    (31) declaration -> . VAR VARIABLE type ASSIGN expression
    (35) assignment -> . VARIABLE ASSIGN expression
    (36) assignment -> . VARIABLE ASIG expression
    (37) print_stmt -> . FMT DOT PRINTF LPAREN STRING COMMA expression RPAREN
    (38) print_stmt -> . FMT DOT PRINTLN LPAREN expression RPAREN
    (39) input_stmt -> . FMT DOT SCANLN LPAREN AMPER VARIABLE RPAREN
    (80) continue_stmt -> . CONTINUE
    (84) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (85) struct_method -> . FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (40) func_def -> . FUNC VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE
    (41) func_def -> . FUNC VARIABLE LPAREN RPAREN type LBRACE program RBRACE
    (43) func_no_params -> . FUNC VARIABLE LPAREN RPAREN block
    (44) func_call -> . VARIABLE LPAREN arg_list RPAREN
    (45) func_call -> . VARIABLE LPAREN RPAREN
    (76) if_stmt -> . IF expression block
    (77) if_stmt -> . IF expression block ELSE block
    (78) for_stmt -> . FOR expression block
    (79) for_stmt -> . FOR assignment SEMICOLON expression SEMICOLON for_update block
    (86) struct_def -> . TYPE VARIABLE STRUCT LBRACE struct_fields RBRACE
    (95) switch_stmt -> . SWITCH expression LBRACE case_list RBRACE
    (96) switch_stmt -> . SWITCH LBRACE case_list RBRACE
    (101) map_declaration -> . VAR VARIABLE MAP LBRACKET type RBRACKET type
    (102) map_declaration -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type
    (107) map_declaration_values -> . VARIABLE ASIG MAP LBRACKET type RBRACKET type LBRACE map_kv_pairs RBRACE
    (111) array_declaration -> . VAR VARIABLE LBRACKET NUMBER RBRACKET type
    (112) array_declaration -> . VAR VARIABLE ASSIGN array_literal
    (113) array_literal -> . LBRACKET NUMBER RBRACKET type LBRACE array_values RBRACE
    (116) slice_declaration -> . VAR VARIABLE LBRACKET RBRACKET type
    (117) slice_declaration -> . VARIABLE ASIG LBRACKET RBRACKET type LBRACE slice_values RBRACE
    (103) make_stmt -> . VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN
    (104) make_stmt -> . VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN
    (120) new_stmt -> . VARIABLE ASIG NEW LPAREN VARIABLE RPAREN
    (121) break_stmt -> . BREAK
    (122) increment_stmt -> . VARIABLE INCREMENT
    (123) increment_stmt -> . VARIABLE DECREMENT
    (42) return_stmt -> . RETURN expression

    VAR             shift and go to state 31
    VARIABLE        shift and go to state 32
    FMT             shift and go to state 33
    CONTINUE        shift and go to state 34
    FUNC            shift and go to state 35
    IF              shift and go to state 36
    FOR             shift and go to state 37
    TYPE            shift and go to state 38
    SWITCH          shift and go to state 39
    LBRACKET        shift and go to state 40
    BREAK           shift and go to state 41
    RETURN          shift and go to state 42

    program                        shift and go to state 288
    statement                      shift and go to state 7
    declaration                    shift and go to state 8
    assignment                     shift and go to state 9
    print_stmt                     shift and go to state 10
    input_stmt                     shift and go to state 11
    continue_stmt                  shift and go to state 12
    struct_method                  shift and go to state 13
    func_def                       shift and go to state 14
    func_no_params                 shift and go to state 15
    func_call                      shift and go to state 16
    if_stmt                        shift and go to state 17
    for_stmt                       shift and go to state 18
    struct_def                     shift and go to state 19
    switch_stmt                    shift and go to state 20
    map_declaration                shift and go to state 21
    map_declaration_values         shift and go to state 22
    array_declaration              shift and go to state 23
    array_literal                  shift and go to state 24
    slice_declaration              shift and go to state 25
    make_stmt                      shift and go to state 26
    new_stmt                       shift and go to state 27
    break_stmt                     shift and go to state 28
    increment_stmt                 shift and go to state 29
    return_stmt                    shift and go to state 30

state 287

    (85) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .

    VAR             reduce using rule 85 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    VARIABLE        reduce using rule 85 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    FMT             reduce using rule 85 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    CONTINUE        reduce using rule 85 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    FUNC            reduce using rule 85 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    IF              reduce using rule 85 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    FOR             reduce using rule 85 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    TYPE            reduce using rule 85 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    SWITCH          reduce using rule 85 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    LBRACKET        reduce using rule 85 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    BREAK           reduce using rule 85 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    RETURN          reduce using rule 85 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    $end            reduce using rule 85 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    RBRACE          reduce using rule 85 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    CASE            reduce using rule 85 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)
    DEFAULT         reduce using rule 85 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN RPAREN type LBRACE program RBRACE .)


state 288

    (84) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program . RBRACE

    RBRACE          shift and go to state 289


state 289

    (84) struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .

    VAR             reduce using rule 84 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    VARIABLE        reduce using rule 84 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    FMT             reduce using rule 84 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    CONTINUE        reduce using rule 84 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    FUNC            reduce using rule 84 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    IF              reduce using rule 84 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    FOR             reduce using rule 84 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    TYPE            reduce using rule 84 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    SWITCH          reduce using rule 84 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    LBRACKET        reduce using rule 84 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    BREAK           reduce using rule 84 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    RETURN          reduce using rule 84 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    $end            reduce using rule 84 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    RBRACE          reduce using rule 84 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    CASE            reduce using rule 84 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)
    DEFAULT         reduce using rule 84 (struct_method -> FUNC LPAREN VARIABLE VARIABLE RPAREN VARIABLE LPAREN param_list RPAREN type LBRACE program RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LBRACE in state 58 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 68 resolved as shift
WARNING: shift/reduce conflict for LBRACE in state 149 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 151 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 151 resolved as shift
WARNING: shift/reduce conflict for AND in state 151 resolved as shift
WARNING: shift/reduce conflict for OR in state 151 resolved as shift
WARNING: shift/reduce conflict for EQ in state 151 resolved as shift
WARNING: shift/reduce conflict for NE in state 151 resolved as shift
WARNING: shift/reduce conflict for LT in state 151 resolved as shift
WARNING: shift/reduce conflict for GT in state 151 resolved as shift
WARNING: shift/reduce conflict for LE in state 151 resolved as shift
WARNING: shift/reduce conflict for GE in state 151 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 152 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 152 resolved as shift
WARNING: shift/reduce conflict for AND in state 152 resolved as shift
WARNING: shift/reduce conflict for OR in state 152 resolved as shift
WARNING: shift/reduce conflict for EQ in state 152 resolved as shift
WARNING: shift/reduce conflict for NE in state 152 resolved as shift
WARNING: shift/reduce conflict for LT in state 152 resolved as shift
WARNING: shift/reduce conflict for GT in state 152 resolved as shift
WARNING: shift/reduce conflict for LE in state 152 resolved as shift
WARNING: shift/reduce conflict for GE in state 152 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 153 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 153 resolved as shift
WARNING: shift/reduce conflict for AND in state 153 resolved as shift
WARNING: shift/reduce conflict for OR in state 153 resolved as shift
WARNING: shift/reduce conflict for EQ in state 153 resolved as shift
WARNING: shift/reduce conflict for NE in state 153 resolved as shift
WARNING: shift/reduce conflict for LT in state 153 resolved as shift
WARNING: shift/reduce conflict for GT in state 153 resolved as shift
WARNING: shift/reduce conflict for LE in state 153 resolved as shift
WARNING: shift/reduce conflict for GE in state 153 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 154 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 154 resolved as shift
WARNING: shift/reduce conflict for AND in state 154 resolved as shift
WARNING: shift/reduce conflict for OR in state 154 resolved as shift
WARNING: shift/reduce conflict for EQ in state 154 resolved as shift
WARNING: shift/reduce conflict for NE in state 154 resolved as shift
WARNING: shift/reduce conflict for LT in state 154 resolved as shift
WARNING: shift/reduce conflict for GT in state 154 resolved as shift
WARNING: shift/reduce conflict for LE in state 154 resolved as shift
WARNING: shift/reduce conflict for GE in state 154 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 155 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 155 resolved as shift
WARNING: shift/reduce conflict for AND in state 155 resolved as shift
WARNING: shift/reduce conflict for OR in state 155 resolved as shift
WARNING: shift/reduce conflict for EQ in state 155 resolved as shift
WARNING: shift/reduce conflict for NE in state 155 resolved as shift
WARNING: shift/reduce conflict for LT in state 155 resolved as shift
WARNING: shift/reduce conflict for GT in state 155 resolved as shift
WARNING: shift/reduce conflict for LE in state 155 resolved as shift
WARNING: shift/reduce conflict for GE in state 155 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 156 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 156 resolved as shift
WARNING: shift/reduce conflict for AND in state 156 resolved as shift
WARNING: shift/reduce conflict for OR in state 156 resolved as shift
WARNING: shift/reduce conflict for EQ in state 156 resolved as shift
WARNING: shift/reduce conflict for NE in state 156 resolved as shift
WARNING: shift/reduce conflict for LT in state 156 resolved as shift
WARNING: shift/reduce conflict for GT in state 156 resolved as shift
WARNING: shift/reduce conflict for LE in state 156 resolved as shift
WARNING: shift/reduce conflict for GE in state 156 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 157 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 157 resolved as shift
WARNING: shift/reduce conflict for AND in state 157 resolved as shift
WARNING: shift/reduce conflict for OR in state 157 resolved as shift
WARNING: shift/reduce conflict for EQ in state 157 resolved as shift
WARNING: shift/reduce conflict for NE in state 157 resolved as shift
WARNING: shift/reduce conflict for LT in state 157 resolved as shift
WARNING: shift/reduce conflict for GT in state 157 resolved as shift
WARNING: shift/reduce conflict for LE in state 157 resolved as shift
WARNING: shift/reduce conflict for GE in state 157 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 158 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 158 resolved as shift
WARNING: shift/reduce conflict for AND in state 158 resolved as shift
WARNING: shift/reduce conflict for OR in state 158 resolved as shift
WARNING: shift/reduce conflict for EQ in state 158 resolved as shift
WARNING: shift/reduce conflict for NE in state 158 resolved as shift
WARNING: shift/reduce conflict for LT in state 158 resolved as shift
WARNING: shift/reduce conflict for GT in state 158 resolved as shift
WARNING: shift/reduce conflict for LE in state 158 resolved as shift
WARNING: shift/reduce conflict for GE in state 158 resolved as shift
WARNING: reduce/reduce conflict in state 56 resolved using rule (expression -> NUMBER)
WARNING: rejected rule (factor -> NUMBER) in state 56
WARNING: reduce/reduce conflict in state 57 resolved using rule (expression -> FLOAT)
WARNING: rejected rule (factor -> FLOAT) in state 57
WARNING: reduce/reduce conflict in state 58 resolved using rule (expression -> VARIABLE)
WARNING: rejected rule (factor -> VARIABLE) in state 58
WARNING: reduce/reduce conflict in state 68 resolved using rule (expression -> VARIABLE)
WARNING: rejected rule (factor -> VARIABLE) in state 68
WARNING: reduce/reduce conflict in state 260 resolved using rule (make_stmt -> VARIABLE ASIG MAKE LPAREN LBRACKET RBRACKET type RPAREN)
WARNING: rejected rule (make_expr -> MAKE LPAREN LBRACKET RBRACKET type RPAREN) in state 260
WARNING: reduce/reduce conflict in state 280 resolved using rule (make_stmt -> VARIABLE ASIG MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN)
WARNING: rejected rule (make_expr -> MAKE LPAREN MAP LBRACKET type RBRACKET type RPAREN) in state 280
